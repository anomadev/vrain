En PHP, el `type juggling` es la conversión automática de tipos de datos en ciertas operaciones, mientras que el `type casting` es la conversión explícita mediante operaciones o funciones como `(int)`, `(bool)` o `settype()`. Los contextos numérico, de cadena, lógico, bit a bit, comparativo y de función determinan como PHP interpreta y convierte los valores. PHP admite además un modo de coerción en tipos (cuando `strict_types` no está habilitado) que siguen un orden de preferencia para las conversaciones en declaraciones de tipo. Entre los operadores de casting disponibles están `(int)`, `(bool)`, `(float)`,` (string)`, `(array)`, `(object)` y `(unset)`(este último deprecado desde PHP 7.2 y eliminado en PHP 8.0). Comprender estas conversiones, tanto implícitas como explícitas, es esencial para escribir código robusto y evitar errores o vulnerabilidades por comparaciones sueltas.
### Definición
- **Type Juggling**: PHP no requiere definición explícita de tipo; el tipo de una variable se determina por el valor que contiene y puede cambiar según el contexto en que se use (aritmético, cadena, lógico, etc.)
- **Type Casting**: Conversión de un valor a un tipo específico mediante un operador de cast, escribiendo el tipo entre paréntesis antes del valor (por ejemplo `(int) $var`), o usando funciones como `settype()` para modificar el tipo de la variable.
### Conceptos clave
- **Contextos de conversión automática**:
	- **Numérico**: con operadores aritméticos, convierte a `int` o `float` según los operandos.
	- **Cadena**: en operadores de `echo`, `print`, interpolación o concatenación, convierte a `string`.
	- **Lógico**: en condiciones y operadores lógicos, convierte a `bool`.
	- **Bit a bit**: si todos los operando son `string` el resultado es `string`, de lo contrario `int`.
	- **Comparativo**: sigue reglas específicas según tipos.
	- **Función**: al pasar valores a parámetros o retornarlos, se aplican conversiones según declaraciones de tipo y `strict_types`.
- **Coerción de tipos**: cuando `strict_types` está desactivado (modo por defecto), PHP puede convertir internamente valores escalares ([[2.3 Data Types]]) a tipos permitidos en una unión, siguiendo el orden: `int`, `float`, `string`, `bool`.
- **Operadores de casting**:
	- `(int)`, alias `(integer)`.
	- `(bool)`, alias `(boolean)`.
	- `(float)`, alias `(double)` / `(real)`.
	- `(string)`, alias `(binary)`
	- `(array)`, `(object)`, `(unset)` (alias de `NULL`)
- **Aliases de cast no recomendados**: `(real)` deprecado en PHP 8.0; `(unset)` deprecado en PHP 7.2 y removido en PHP 8.0 ([[1.1 What is PHP]]).
- **Funciones de conversión**: `settype()`, `intval()`, `boolval()`, `floatval()`, `strval()`, que realizan casting de forma explícita.
### Ejemplos prácticos
##### Type Juggling implícito (suma de entero y cadena)
```php
<?php

$a = 10;
$b = '20';
$c = $a + $b; // '20' se convierte automáticamente a int
echo $c;      // 30

?>
```
##### Type Casting explícito a boolean
```php
<?php

$foo = 10;
$bar = (bool) $foo; // $bar es true
var_dump($bar);

?>
```
##### Equivalencia de casting y comillas dobles
```php
<?php

$foo = 10;
$str1 = (string)$foo;       // casting explícito
$str2 = "$foo";             // interpolación
var_dump($str1 === $str2);  // true

?>
```
##### Casting a array y a object
```php
<?php

$obj = (object) ['a' => 1, 'b' => 2];
$arr = (array) $obj;
var_dump($arr); // ['a' => 1, 'b' => 2]

?>
```
##### Eliminando el valor con `unset` (Deprecated)
```php
<?php

$x = 5;
$x (unset) $x;  // mismo que $x = NULL;
var_dump($x);   // NULL

?>
```

## Notas
---
- Evitar comparaciones con `==` para no caer en resultados inesperados por `type juggling`.
- Usar siempre `===` y declarar `strict_types` donde sea posible para mayor seguridad.