En PHP, una **función** es un bloque reutilizable de código que se invoca mediante su nombre o por medio de un valor `callable`. Existen funciones **definidas por el usuario**, declaradas con la palabra clave `function` ([[6.1 Function Declaration]]), y **funciones internas** provistas por el núcleo y extensiones. Las **firmas** de funciones aceptan **parámetros** pasados por valor, por referencia, con valores por defecto, listas de longitud variable y **argumentos nombrados** (PHP 8). Las funciones **devuelven** valores mediante `return`, o `null` si se omite ([[6.2 Parameters & Return Values]]). PHP soporta **funciones dinámicas** (`variable functions`), **funciones anónimas** (`closures`) ([[6.5 Anonymous Functions]]), `arrow functions` ([[6.7 Arrow Functions]]) (PHP 7.4) para expresiones cortas, y la sintaxis `callable` de primera clase (PHP 8.1) que convierte cualquier expresión `callable` en un `Closure` Esta flexibilidad hace que el manejo de `callbacks` ([[6.6 Callback Functions]]), la programación funcional y la escritura de código modular sean tareas naturales en PHP.
### Definición
Una función en PHP es un conjunto de instrucciones agrupadas bajo un nombre que puede:
- **Recibir** datos a través de **parámetros**
- **Procesar** lógica con esas entradas
- **Devolver** un valor opcional con `return`
- **Interrumpir** su ejecución inmediatamente al encontrar `return`
Las funciones pueden ser:
1. `User-defined functions`: creadas por el programador usando `function name(...) {...}`
2. `Internal (built-in) functions`: parte del lenguaje o de extensiones, organizadas en múltiples categorías
3. `Variable functions`: invocadas dinámicamente a través de variables que contienen el nombre de la función
4. `Anonymous functions (closures)`: funciones sin nombre asignables a variables o pasables como argumentos
5. `Arrow functions`: sintaxis abreviada (`fn(...) => expr`) que captura variable del ámbito padre
6. `First-class callables`: sintaxis `Foo::bar(...)` o `$obj->method(...)` que genera un `Closure` automáticamente (PHP 8.1)
### Conceptos clave
- **Definición y alcance**
	- Las funciones se definen con `function` y tienen **ámbito global**, pueden llamarse desde cualquier parte del script.
	- No hay **sobrecarga de funciones**: cada nombre debe ser único.
- **Parámetros y argumentos** ([[6.2 Parameters & Return Values]])
	- Por valor (predeterminado) o por referencia (`&$param`)
	- Valores por defecto permiten omitir argumentos
	- Listas variádicas (`...$args`) recogen múltiples valores en un array
	- Argumentos nombrados (`foo(bar: 1)`) hacen opcional el orden y salteo de parámetros (PHP 8)
- Retorno de valores ([[6.2 Parameters & Return Values]])
	- `return` detiene la función y devuelve valor; sin `return` retorna `null`
	- Para **múltiples valores**, retorna un `array` o estructura similar
	- Referencias de retorno (`function &foo()`) permiten asignar por referencia
- Llamadas dinámicas
	- `Variable functions`: `$f = 'strlen'; $f('text');`
	- No aplicables a constructo de lenguaje (`echo`, `ìsset`, etc.) sin wrappers
- Funciones anónimas y `closures` ([[6.5 Anonymous Functions]])
	- Se crean con `function(...) use (...) {...}` y heredan variables explícitamente con `use`
	- Capturan `$this` automáticamente cuando se definen en contexto de clase (PHP 7.0+)
	- `Static closures (static function)` deshabilitan la vinculación de `$this`
- `Arrow Functions` ([[6.7 Arrow Functions]])
	- Sintaxis `fn(params) => expr`, más concisa que `closures`
	- Capturan todas las variables del ámbito padre por valor, sin `use`
	- No permiten cuerpos de múltiples sentencias ni declaraciones `void`
- `First-class callable syntax`
	- PHP 8.1 permite crear un `Closure` con `callableExpre(...)`, p. ej. `$fn = $obj->method(...);`
	- Equivalente a `Closure::fromCallable(...)`, pero compatible con análisis estático
### Ejemplos prácticos
##### Función definida por el usuario
```php
<?php

function saludar (string $nombre = "Mundo"): string {
	return "Hola, $nombre!";
}

echo saludar();              // Hola, Mundo!
echo saludar(nombre: "Ana"); // Hola, Ana!

```
##### Lista variádica y parámetros de referencia
```php
<?php

function acumular (int &$total, ...valores): void {
	foreach ($valores as $v) {
		$total += $v;
	}
}

$suma = 0;
acumular($suma, 1, 2, 3);
echo $suma; // 6

```
##### `variable function`
```php
<?php

function doble($x) { return $x * 2 }
$f = 'doble';
echo $f(5); // 10

```
##### `closure` heredando variables
```php
<?php

$prefijo = "Valor: ";
$imprimir = function($v) use($prefijo) {
	echo $prefijo . $v;
}
$imprimir(42); // Valor: 42

```
##### `arrow functions`
```php
<?php

$factor = 3;
$mult = fn($n) => $n * $factor;
echo $mult(5); // 15

```
##### `First-class callable` PHP 8.1+
```php
<?php

class C {
	public function saludo() { return "Hola!"; }
}

$c = new C;
$fn = $c->saludo(...);
echo $fn(); // Hola!

```
## Notas
---
- Utilizar `arrow functions` en `callbacks` simples y `closures` cuando necesite más flexibilidad.
- Para pruebas combinar `named arguments` con valores por defecto para mantener la compatibilidad con futuros cambios.
