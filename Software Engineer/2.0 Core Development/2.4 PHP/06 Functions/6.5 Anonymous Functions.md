En PHP, las **funciones anónimas** (o _`closures`_) son bloques de código definidos _sobre la marcha_ sin un nombre explícito, implementados internamente como instancias de la clase `Closure` y extremadamente útiles como callbacks ([[6.6 Callback Functions]]) o para encapsular lógica ligera en línea. Se asignan a variables, se pasan directamente a otras funciones, y pueden **heredar variables** del ámbito padre mediante el lenguaje `use`, capturando valores por copia o referencia. En el contexto de clases, las closures ligan automáticamente `$this`, aunque pueden declararse `static` para evitarlo. Con PHP 7.4 llegaron las **arrow functions** ([[6.7 Arrow Functions]]) (`fn(...) => expr`) como sintaxis abreviada, y PHP 8.0 añadió la posibilidad de incluir una **coma final** en la lista de variables heredadas o en la declaración de parámetros. A partir de PHP 8.1, las closures pueden usar objetos ([[11.1 Classes and Objects]]) (`new Clase()`) como valores por defecto. Todo ello permite construir código modular, legible y seguro frente a variables indefinidas.
### Definición 
Las funciones anónimas, o `closures`, son funciones sin nombre que pueden asignarse a variables o pasarse como argumentos, y se representan como objetos de la clase interna `Closure`.
### Conceptos clave
- **Implementación:** Internamente son instancias de la clase `Closure`. [PHP](https://www.php.net/manual/en/functions.anonymous.php?utm_source=chatgpt.com)
- **Asignación a variables:** PHP convierte automáticamente la expresión en un `Closure` al asignarla. [PHP](https://www.php.net/manual/en/functions.anonymous.php)
- **Uso como `callbacks`:** Ideales para parámetros de tipo `callable` (por ejemplo en `preg_replace_callback`, `array_map`). [PHP](https://www.php.net/manual/en/functions.anonymous.php?utm_source=chatgpt.com) [W3Schools.com](https://www.w3schools.com/php/php_callback_functions.asp?utm_source=chatgpt.com)
- **Herencia de variables (`use`):** Permite capturar valores del ámbito externo por copia o por referencia (`use ($var)` o `use (&$var)`). [PHP](https://www.php.net/manual/en/functions.anonymous.php)
- **Ámbito de `$this`:**
    - **Automático** en `closures` definidas dentro de métodos (se liga el objeto actual).
    - **`static` `closures`** impiden el enlace automático de `$this`. [PHP](https://www.php.net/manual/en/functions.anonymous.php)
- **Parámetros y retorno:** ([[6.2 Parameters & Return Values]]) Pueden aceptar parámetros regulares y tener tipo de retorno, incluso tras la cláusula `use`. [PHP](https://www.php.net/manual/en/functions.anonymous.php)
- **Comas finales:** Desde PHP 8.0, las clausulas `use` pueden terminar con coma sin error. [PHP](https://www.php.net/manual/en/functions.anonymous.php)
- **Sintaxis abreviada (`Arrow Functions`) ([[6.7 Arrow Functions]]):** Con `fn(args) => expr`, crean `closures` de una sola expresión y capturan todas las variables del ámbito padre por valor (PHP 7.4+). [PHP Tutorial](https://www.phptutorial.net/php-tutorial/php-arrow-functions/?utm_source=chatgpt.com)
- **Obsolescencia de `create_function()`:** Se recomienda no usar `create_function()` (deprecated) en favor de `closures` nativas. [GeeksforGeeks](https://www.geeksforgeeks.org/php-create_function-function/?utm_source=chatgpt.com)
- **Funciones condicionales e internas:** Puedes definir `closures` dentro de otras funciones o condicionales; solo existen tras la ejecución de su bloque contenedor.
### Ejemplos prácticos
##### Callback con `preg_replace_callback`
```php
<?php

echo preg_replace_callback(
	'/-([a-z])/',
	function($m) {
		return strtoupper($m[1]);
	},
	'hello-world'
);
// helloWorld

```
##### Asignación a variable y llamado múltiple
```php
<?php

$greet = function($name) {
	printf("Hello %s\n", $name);
};

$greet('World');
$greet('PHP');

```
##### Herencia de variables por copia y referencia
```php
<?php

$msg = 'hi';

$fn1 = function() use ($msg) { var_dump($msg); };   // copia
$fn2 = function() use (&$msg) { var_dump($msg); };  // referencia

$msg = 'hello';
$fn1();   // string(2) "hi"
$fn2();   // string(5) "hello"

```
##### `Closure` en método y enlace de `$this`
```php
<?php

class Test {
	public function getLogger() {
		return function($msg) {
			echo get_class($this) . ": $msg\n";
		};
	}
}

$t = new Test;
$log = $t->getLogger();
$log("ok"); // Test: ok

```
##### `Closure` estática sin `$this`
```php
<?php

class Foo  {
	public function __construct() {
		$f = static function() {
			var_dump(isset($this));
		};
		$f();
	}
}

new Foo;

```
##### `Arrow function` para mapeo
```php
<?php

$nums = [1, 2, 3];
$squares = array_map(fn($n) => $n ** 2, $nums);
print_r($squares); // [1, 4, 9]

```
## Notas
---
- Usar `closures` para `callbacks` en colecciones (`array_map`, `array_filter`) y para encapsular validaciones puntuales.
- Usar `arrow functions` cuando la lógica cabe en una sola expresión, pues mejora la legibilidad.
- Evitar definir `closures` dentro de condicionales salvo que sea estrictamente necesario para no cargar el intérprete.
