En PHP, una **función de `callback`** (o _`callable`_) es cualquier constructo que puede invocarse como función: un nombre de función, un método de objeto, un método estático o una **`Closure`** ([[6.5 Anonymous Functions]]) [PHP](https://www.php.net/manual/en/language.types.callable.php?utm_source=chatgpt.com). Se emplean para inyectar lógica dinámica en funciones o métodos de orden superior, como `array_map()`, `usort()` o `preg_replace_callback()`, permitiendo `decoupling` y reutilización de código [W3Schools.com](https://www.w3schools.com/php/php_callback_functions.asp?utm_source=chatgpt.com) [W3Schools.com](https://www.w3schools.com/php/func_regex_preg_replace_callback.asp?utm_source=chatgpt.com). PHP valida que un valor sea **invocable** con `is_callable()` o mediante declaraciones de tipo `callable` en firmas de función, lanzando un `TypeError` si no lo es [PHP](https://www.php.net/manual/en/function.is-callable.php?utm_source=chatgpt.com). Desde PHP 8.1 ([[1.1 What is PHP]]), la **sintaxis first‑class callable** (`$obj->método(...)`) simplifica la creación de `Closure` a partir de cualquier callable, mejorando la compatibilidad con análisis estático [PHP](https://www.php.net/manual/en/functions.first_class_callable_syntax.php?utm_source=chatgpt.com). El uso de callbacks es esencial para escribir APIs flexibles, handling de eventos y construcción de pipelines de procesamiento en aplicaciones PHP modernas [DEV Community](https://dev.to/martinkordas/practical-use-of-callback-functions-in-php-2fcm?utm_source=chatgpt.com).
### Definición
Un `callback` es un `callable` que se pasa como argumento a otra función o método, de manera que esa función pueda "llamar de vuelta" a la lógica suministrada cuando sea necesario. PHP representa los `callables` como:
1. `Strings` con el nombre de la función global, p. ej. `strlen`. ([[2.3 Data Types]])
2. `Arrays` `[Clase, "staticMethod"]` o `[$objeto, "method"]`. ([[3.1 Arrays]])
3. Instancias de `Closure` (funciones anónimas). ([[6.5 Anonymous Functions]])
4. `First-class callables` (`$obj->method(...)`) en PHP 8.1+
### Conceptos clave
- **Tipo `callable`**: Puede usarse en la firma de funciones para forzar que el argumento sea invocable, p.ej. `function foo(callable $cb) { … }` [PHP](https://www.php.net/manual/en/language.types.callable.php?utm_source=chatgpt.com).
- **`is_callable()`**: Verifica en tiempo de ejecución si un valor puede invocarse como función sin error [PHP](https://www.php.net/manual/en/function.is-callable.php?utm_source=chatgpt.com).
- **Funciones de orden superior**: PHP provee funciones internas que reciben `callbacks`, como `array_map()`, `usort()`, `call_user_func()`, `preg_replace_callback()` [TutorialsPoint](https://www.tutorialspoint.com/implementing-callback-in-php?utm_source=chatgpt.com) [W3Schools.com](https://www.w3schools.com/php/func_regex_preg_replace_callback.asp?utm_source=chatgpt.com).
- **`call_user_func*`**: Permiten invocar un `callable` dinámicamente, tanto con argumentos posicionales (`call_user_func`) como `arrays` de argumentos (`call_user_func_array`) [PHP Tutorial](https://www.phptutorial.net/php-tutorial/php-call_user_func_array/?utm_source=chatgpt.com).
- **`Closure` vs `Callable` clásico**: Una `Closure` es un objeto de la clase interna `Closure`, pero cualquier `callable` válido (`string`, `array`, `closure`) puede usarse [PHP](https://www.php.net/manual/en/language.types.callable.php?utm_source=chatgpt.com).
- **`First‑class callable syntax`**: Con PHP 8.1, `[$obj, "método"](...)` o `$obj->método(...)` devuelve directamente un `Closure` sin usar `Closure::fromCallable` [PHP](https://www.php.net/manual/en/functions.first_class_callable_syntax.php?utm_source=chatgpt.com).
- **Beneficios**: Facilitan la inyección de comportamiento, la creación de frameworks de eventos, middleware y pipelines sin acoplar componentes fuertemente [DEV Community](https://dev.to/martinkordas/practical-use-of-callback-functions-in-php-2fcm?utm_source=chatgpt.com).
### Ejemplos prácticos
##### `Callback` con `array_map`
```php
<?php

$nums = [1, 2, 3];
$doubles = array_map(function($n) { return $n * 2; }, $nums);
// [2, 4, 6]

```
##### `usort` con función nombrada
```php
<?php

function cmp($a, $b) { return $a <=> $b }
$arr = [3, 1, 2];
usort($arr, 'cmp');
// [1, 2, 3]

```
##### `preg_replace_callback` para `camelCase`
```php
<?php

$str = 'hello-world';
echo preg_replace_callback(
	'/-([a-z])/',
	fn($m) => strtoupper($m[1]),
	$str
);
// helloWorld

```
##### `call_user_func_array` con `unpacking`
```php
<?php

function sum($a, $b, $c) { return $a + $b + $c }
$args = [1,2,3];
echo call_user_func_array('sum', $args); // 6

```
##### `first-class callable` (PHP 8.1+)
```php
<?php

class C { public function hi() { return 'hola'; } }
$c = new C;
$fn = $c->hi(...);
echo $fn(); // hola

```
## Notas
---
- Usar `first-class callable syntax` cuando migramos a PHP 8.1 para mejorar la legibilidad y facilitar `refactors`.
- Combinar `is_callable()` y `type hints callable` ayuda a detectar errores de firma antes de ejecutar la lógica principal.
