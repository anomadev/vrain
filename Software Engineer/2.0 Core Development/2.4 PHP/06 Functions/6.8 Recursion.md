En PHP, la **recursión** es una técnica de programación donde una función ([[6.0 Functions]]) se invoca a sí misma hasta que se cumple una **condición base**, lo que permite descomponer problemas complejos en subproblemas más simples [TutorialsPoint](https://www.tutorialspoint.com/php/php_recursive_functions.htm?utm_source=chatgpt.com). Esta aproximación resulta muy útil para operaciones como el cálculo de factoriales, la generación de la serie de Fibonacci o la recorrida de estructuras de datos anidadas [SitePoint](https://www.sitepoint.com/understanding-recursion/?utm_source=chatgpt.com). Cada llamada recursiva añade un nivel al **call stack** y, al alcanzar el caso base, la pila se va desapilando conforme retornan los valores [SitePoint](https://www.sitepoint.com/understanding-recursion/?utm_source=chatgpt.com). Sin embargo, la recursión conlleva riesgos de **desbordamiento de pila** y alto consumo de memoria si no se diseña con un caso base adecuado y sin aproximarse al **`tail call optimization`**, la cual PHP no implementa [GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-recursion-2/?utm_source=chatgpt.com). En la práctica, PHP ofrece clases como `RecursiveDirectoryIterator` para recorrer directorios y funciones como `array_walk_recursive` para procesar `arrays` multidimensionales de forma recursiva [PHP](https://www.php.net/manual/en/class.recursivedirectoryiterator.php?utm_source=chatgpt.com).
### Definición
Una función recursiva es aquella que se llama a sí misma dentro de su propio cuerpo durante la ejecución, repitiendo este proceso hasta que se alcanza una condición de terminación (caso base) que evita llamadas infinitas.
La recursión puede ser:
- Directa, cuando la misma función se invoca a sí misma
- Indirecta, cuando varias funciones se llaman en cadena (`a` -> `b` -> `a` ...)
### Conceptos clave
##### Caso base y caso recursivo
- **Caso base:** condición simple que, al cumplirse, retorna un valor sin más llamadas recursivas, deteniendo la recursión [GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-recursion-2/?utm_source=chatgpt.com).
- **Caso recursivo:** parte de la función donde ésta se invoca a sí misma con parámetros modificados para acercarse progresivamente al caso base [Scaler](https://www.scaler.com/topics/php-tutorial/recursive-function-in-php/?utm_source=chatgpt.com).
##### Call Stack
Cada invocación crea un `frame` en la pila de llamadas, almacenando variables locales y dirección de retorno; al cumplirse el caso base, los `frames` se desapilan en orden inverso [SitePoint](https://www.sitepoint.com/understanding-recursion/?utm_source=chatgpt.com).
##### Limitaciones y rendimiento
- **Sin optimización de cola:** PHP no implementa `tail call optimization`, por lo que llamadas recursivas profundas pueden llevar a desbordamientos de pila y uso intensivo de memoria [GeeksforGeeks](https://www.geeksforgeeks.org/introduction-to-recursion-2/?utm_source=chatgpt.com).
- **Límites de profundidad:** extensiones como `Xdebug` establecen `xdebug.max_nesting_level` para evitar bucles infinitos; conviene diseñar la recursión para no acercarse a estos límites [Scaler](https://www.scaler.com/topics/php-tutorial/recursive-function-in-php/?utm_source=chatgpt.com)
##### Recursión vs Iteración
- La recursión aporta **claridad** y se adapta bien a problemas naturalmente recursivos (árboles, grafos).
- La iteración suele ser más **eficiente** en memoria y velocidad cuando el problema no requiere descomposición en subproblemas [Scaler](https://www.scaler.com/topics/php-tutorial/recursive-function-in-php/?utm_source=chatgpt.com).
### Ejemplos prácticos
##### Factorial de un número
```php
<?php

function factorial(int $n): int {
	if ($n <= 1) {
		return 1;                     // Caso base
	}
	return $n * factorial($n - 1);    // Caso recursivo
}

echo factorial(5); // 120

```
Este ejemplo muestra cómo cada llamada escala hacia el caso base `n <= 1` y luego retorna multiplicativamente.
##### Serie de Fibonacci (recursiva)
```php
<?php

function fibonacci(int $n): int {
	if ($n === 0) return 0;      // Caso base
	if ($n === 1) return 1;      // Caso base
	return fibonacci($n - 1) +
		   fibonacci($n - 2);    // Caso recursivo
}

// Imprimir los primeros 10 términos
for ($i = 0; $i < 10; $i++) {
	echo fibonacci($i) . ' ';
}

```
Cada llamada a `fibonacci` genera dos llamadas recursivas hasta llagar a `0` o `1`.
##### Recorrido recursivo de un directorio
```php
<?php

function listarArchivos(string $ruta): void {
	$it = new RecursiveDirectoryIterator($ruta);
	$recIt = new RecursiveIteratorIterator($it);

	foreach ($recIt as $archivo) {
		echo $archivo->getPathname() . "\n";
	}
}

listarArchivos(__DIR__ . '/vendor');

```
Utiliza `RecursiveDirectoryIterator` y `RecursiveIteratorIterator` para navegar anidamientos de carpetas.
## Notas
--- 
- Usar `iteración` para bucles simples de longitud conocida y `recursión` cuando la estructura de datos es jerárquica.
- Para algoritmos intensivos, convierte recursión en memorización o en iteración de pila explícita.