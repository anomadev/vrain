PHP incluye una extensión JSON (`ext-json`) que proporciona funciones nativas para serializar datos a JSON (`json_encode`) y deserializar cadenas JSON a valores PHP (`json_decode`), así como utilidades para manejar errores (`json_last_error`, `json_last_error_msg`) y lanzar excepciones (`JsonException`) cuando se solicita.
Estas funciones respetan el estándar RFC7159, operan sobre UTF-8 y ofrecen múltiples opciones avanzadas de control: profundidad máxima de anidado, conversión de objetos a `arrays` asociativos ([[3.3 Associative Arrays]]), manejo de enteros grandes (`JSON_BIGINT_AS_STRING`) y control de caracteres inválidos (`JSON_INVALID_UTF8_IGNORE`).
En entornos modernos, conviene emplear el modo excepción (`JSON_THROW_ON_ERROR`) para capturar errores de forma robusta, y aprovechar la interfaz `JsonSerializable` en objetos para personalizar la serialización.

---
### Definición de funciones clave
```php
json_encode(
	mixed $value, 
	int $flags = 0, 
	int $depth = 512
): string|false
```
Serializa un valor PHP (array, objetos, escalares) ([[2.3 Data Types]]) a una cadena JSON válida.

```php
json_decode(
	string $json, 
	?bool $associative = null, 
	int $depth = 512, 
	int $flags = 0
): mixed
```
Convierte una cadena JSON en un valor PHP. Con `$associative = true` devuelve `arrays` asociativos; con `false` devuelve objetos; si es `null`, usa la bandera `JSON_OBJECT_AS_ARRAY`.

```php
json_last_error(): int
```
Retorna el código del último error ocurrido en la serialización/deserialización cuando no se usa `JSON_THROW_ON_ERROR`.

```php
json_last_error_msg(): string
```
Devuelve un mensaje descriptivo del último error de JSON.

`JsonException`: Clase de excepción lanzada por `json_encode` o `json_decode` si se específica la bandera `JSON_THROW_ON_ERROR` a partir de PHP 7.3 ([[1.1 What is PHP]]).

---
### Conceptos Clave
- **Opciones de serialización y deserialización**
	- Profundidad (`$depth`): controla cuán anidada puede estar la estructura antes de fallar; útil para protegerse contra datos maliciosos.
	- Banderas (`$flags`):
		- `JSON_PRETTY_PRINT` para salida legible.
		- `JSON_BIGINT_AS_STRING` para tratar enteros grandes como cadenas en `json_decode`.
		- `JSON_INVALID_UTF8_IGNORE`/`JSON_INVALID_UTF8_SUBSTITUTE` para manejar UTF-8 malformado.
		- `JSON_THROW_ON_ERROR` para lanzar `JsonException` en errores.
- **Manejo de Errores**
	- Sin `JSON_THROW_ON_ERROR`, `json_last_error()` y `json_last_error_msg()` son necesarios para diagnosticar problemas después de cada llamada.
	- Con `JSON_THROW_ON_ERROR`, los errores generan excepciones, lo que simplifica el flujo con `try/catch`.
- **Interfaces y Extensibilidad**
	- La interfaz `JsonSerializable` permite que un objeto defina su propia serialización JSON implementando `jsonSerialize()`.
	- `json_validate(string $json): bool` (PHP 8.3+) verifica si una cadena es JSON válido sin decodificarla.
- **Requisitos de Codificación**
	- Solo funciona con UTF-8; otras codificaciones deben convertirse previamente para evitar errores `JSON_ERROR_UTF8`.

---
### Ejemplos Prácticos
##### API REST: Serializar respuesta
```php
<?php

header('Content-Type: application/json; charset=UTF-8');
$data = ['status' => 'ok', 'users' => $userArray];
echo json_encode($data, JSON_THROW_ON_ERROR | JSON_PRETTY_PRINT);

```
Envía respuesta JSON legible y lanza excepción si hay error.
##### Decodificar `payload` de JSON en POST
```php
<?php

$body = file_get_contents('php://input');

try {
	$payload = json_decode($body, true, 512, JSON_THROW_ON_ERROR);
} catch (JsonException $e) {
	http_response_code(400);
	exit(json_encode(['error' => $e->getMessage()]));
} 
// Procesar $payload como array asociativo

```
Garantizar manejo robusto de entrada de cliente.
##### Convertir objetos PHP a JSON usando `JsonSerializable`
```php
<?php

class User implements JsonSerializable {
	public function __construct(private string $name, private string $age) {}
	public function jsonSerialize(): array {
		return ['name' =>  $this->name, 'age' => $this->age];
	}
}

echo json_encode(new User('Ana', 30));

```
Define control fino de la serialización.
##### Manejo de enteros grandes
```php
<?php

$json = '{"big":12345678901234567890}';
$obj = json_decode($json, false, 512, JSON_BIGINT_AS_STRING);
var_dump($obj->big); // string

```
Evita pérdida de precisión en enteros de 64+ bits.
##### Validar JSON sin decodificar
```php
<?php

$isValid = json_validate($string); // PHP 8.3+
```
Útil para filtros previos en formularios o APIs.

---
## ✍️ Notas
- En pequeñas utilidades usar `json_encode`/`json_decode` con excepciones para código más limpio.
- Para grandes volúmenes, verificar siempre `MEMORY_LIMIT` y proceso en streaming con `fgets()` + `json_decode`.
- Uso `JsonSerializable` para mantener objetos coherentes y evitar filtrar propiedades sensibles.
