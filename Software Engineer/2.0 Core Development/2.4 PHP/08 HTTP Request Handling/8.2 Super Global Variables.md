En PHP existen tres superglobals específicas para manejar datos de solicites HTTP. `$_GET` captura variables pasadas en la cadena de consulte de la URL, `$_POST` recoge datos enviados al script mediante el método `HTTP POST` con `Content-Types` `application/x-www-form-urlencoded` o `multipart/form-data`, y `$_REQUEST` unificada, por defecto, los contenidos de `$_GET`, `$_POST` y `$_COOKIE` según las directivas `request_order` y `variables_order`. Además, la superglobal `$_SERVER` expone metadatos del entorno de ejecución y cabeceras de la petición (p. ej. `REQUEST_METHOD`, `REQUEST_URI`, variables `HTTP_*`). Estas variables son fundamentales para procesar formularios, construir `APIs RESTful` y adaptar la lógica según el método o ruta, asegurando un manejo seguro y eficiente de la entrada del usuario.

---
### Definición de `Superglobals HTTP`
- `$_GET`: Un array asociativo ([[3.3 Associative Arrays]]) que contiene variables pasadas al script actual a través de la `query string` en la URL. Se puebla incluso si la petición no es `GET`, siempre que exista una cadena de consulta.
- `$_POST`: Un array asociativo ([[3.3 Associative Arrays]]) de variables enviadas al script mediante `HTTP POST`, válido cuando el `Content-Type` es `application/x-www-form-urlencoded` o `multipart/form-data`.
- `$_REQUEST`: Un array asociativo ([[3.3 Associative Arrays]]) que, por configuración predeterminada, combina `$_GET`, `$_POST` y `$_COOKIE`. El orden y presencia de variables se rige por las directivas de PHP `request_order` y `variables_order`.
- `$_SERVER`: Un array ([[3.1 Arrays]]) con información del servidor y entorno de ejecución: cabe destacar `REQUEST_METHOD` (método HTTP), `REQUEST_URI` (URI solicitada), `QUERY_STRING`, `SCRIPT_NAME` y todas las cabeceras HTTP disponibles como elementos `HTTP_*`.

---
### Conceptos Clave
##### Diferencias entre `GET` y `POST`
- Visibilidad: `$_GET` expone los datos en la URL (`query string`); no usarlo para información sensible.
- Límites y tipos: `GET` está limitado a cadenas ASCIII en la URL (~2048 caracteres), mientras que `POST` admite datos binarios y cargas de archivos según `post_max_size` ([[20.4 Configuration Files]]).
- Idempotencia: `GET` es idempotente (repetirlo no causa cambios), `POST` NO (cada envío puede crear o modificar recursos).
##### Seguridad y Validación
- Validar siempre la existencia y tipo de cada índice antes de usar (`ìsset`, filtros) para evitar `undefined index` y ataques de inyección.
- Escapar con `htmlspecialchars()` o filtros (`filter_input()`) al renderizar datos en HTML o al pasarlos a la base de datos.
##### `$_REQUEST` y su orden
- Su uso no recomendado en entornos donde se mezclen cookies, `GET` y `POST` sin distinción, pues dificulta saber el origen del dato.
- Se puede emplear en scripts sencillos, pero conviene usar `$_GET`/`$_POST` explícitamente en `APIs` o formularios críticos.
##### Metadatos en `$_SERVER`
- `REQUEST_METHOD`: controla flujo según método (`GET`, `POST`, `PUT`, `DELETE`) ([[8.1 HTTP Methods]]).
- **Cabeceras HTTP**: disponibles como `$_SERVER['HTTP_ACCEPT']`, `$_SERVER['HTTP_USER_AGENT']`, etc. sin necesidad de extensiones adicionales ([[1.06 HTTP Headers]]).
- **Rutas y `URIs`**: `REQUEST_URI` y `SCRIPT_NAME` permiten construir `routers` y `middlewares` propios.

---
### Ejemplos Prácticos
##### Procesar un formulario de búsqueda (`GET`)
```php
<?php

// URL: /buscar.php?q=php+superglobals
if (isset($_GET['q'])) {
	$term = htmlspecialchars($_GET['q']);
	echo "Resultados para: $term";
} else {
	echo "Por favor, ingresa tu búsqueda.";
}

```
Utilizar `GET` para búsquedas facilita compartir enlaces y guardar historial.
##### Enviar datos de contacto (`POST`)
```php
<?php
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $name  = filter_input(INPUT_POST, 'name', FILTER_SANITIZE_STRING);
    $email = filter_input(INPUT_POST, 'email', FILTER_VALIDATE_EMAIL);
    
    // Guardar en base de datos o enviar correo
    echo "Gracias, $name. Te contactaremos en $email.";
}
?>

<form method="post">
  <input name="name" required>
  <input name="email" required>
  <button>Enviar</button>
</form>
```
`filter_input` combina lectura segura y saneamiento.
##### Lectura mixta con `$_REQUEST`
```php
<?php

$action = $_REQUEST['action'] ?? 'default';
switch ($action) {
    case 'login':    // puede venir de GET, POST o COOKIE
        // lógica de login
        break;
    case 'register':
        // registro
        break;
    default:
        // vista por defecto
}

```
Útil en scripts muy sencillos; no recomendado en `APIs REST`.
##### Control de método con `$_SERVER`
```php
<?php

if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    http_response_code(405);
    header('Allow: POST');
    exit('Método no permitido');
}

```
Garantiza cumplimiento de contrato HTTP.
##### Leer cabeceras personalizadas
```php
<?php

$token = $_SERVER['HTTP_X_API_TOKEN'] ?? null;
if (!$token) {
    http_response_code(401);
    exit('Token requerido');
}

```
Acceso directo a cabeceras sin librerías extra.

---
## ✍️ Notas
- Usar `$_GET` para operaciones idempotentes (búsquedas, filtros) y `$POST` para creación o modificación de recursos.
- Evitar `$_REQUEST` en `APIs` y sistemas críticos; usar `filter_input()` siempre que sea posible.
- Usar `$_SERVER` para construir `routers` simples y leer cabeceras personalizadas sin dependencias externas.
