La inyección SQL es una de las vulnerabilidades más críticas en aplicaciones en PHP, ya que permite a atacantes inyectar y ejecutar instrucciones SQL maliciosas mediante la inserción de datos manipulados directamente en las consultas de `backend` ([owasp.org](https://owasp.org/www-community/attacks/SQL_Injection?utm_source=chatgpt.com)[Acunetix](https://www.acunetix.com/blog/articles/prevent-sql-injection-vulnerabilities-in-php-applications/?utm_source=chatgpt.com)). PHP, por sí solo, no proviene estas inyecciones; es responsabilidad del desarrollador usar consultas preparadas con parametrización, escapa adecuado de datos y validación estricta de entradas para separar siempre la lógica SQL de los datos de usuario. 

---
### Definición 
La inyección SQL (`SQLi`) es un ataque donde se inserta o inyecta código SQL malicioso en las entradas de usuario que luego se concatenan en consultas a la base de datos sin aislamiento apropiado, permitiendo a un atacante leer, modificar o eliminar datos, e incluso ejecutar comando administrativos del SGBD ([owasp.org](https://owasp.org/www-community/attacks/SQL_Injection?utm_source=chatgpt.com)). En PHP esto suele ocurrir al usar funciones de extensión `MySQLi` ([[10.2 MySQLi]]) o `PDO` ([[10.1 PDO]]) de forma incorrecta, concatenando variables directamente en cadenas SQL ([php.net](https://www.php.net/manual/en/security.database.sql-injection.php?utm_source=chatgpt.com)).

---
### Conceptos Clave
1. Tipos de `SQL Injection`
	- Inyección basada en cadena: valores malformados en parámetros `string` (`' OR '1'='1`).
	- Inyección numérica: manipulación de parámetros numéricos (`1 OR 1=1`).
	- Segunda orden: datos "limpios" almacenados y reinyectados posteriormente sin sanitizar.
2. Analogía del Control de Acceso: Imagínate una puerta donde pones tu nombre en una lista. Si la puerta también acepta instrucciones (`"Permitido" OR "Todos"`), un intruso puede engañarla para entrar sin estar en la lista ([owasp.org](https://owasp.org/www-community/attacks/SQL_Injection?utm_source=chatgpt.com)). Las consultas preparadas son como un portero que separa la lista de nombres de las instrucciones, asegurando que solo los nombres válidos sean considerados.
3. Puntos de Inyección
	- Formularios HTML (`$_GET`, `$_POST`) [[8.1 HTTP Methods]]
	- Cabeceras HTTP (`$_SERVER['HTTP_USER_AGENT']`) [[1.06 HTTP Headers]]
	- Cookies (`$_COOKIE`) [[8.5 State Management (Cookies)]]
---
### Ejemplos Prácticos
##### Vulnerabilidad (Consulta Dinámica Peligrosa)
```php
<?php

$user = $_GET['user'];
$query = "SELECT * FROM users WHERE username = '$user'";
$result = mysqli_query($conn, $query);
```
Si `user` es `admin' --`, la consulta se convierte en:
```sql
SELECT * FROM users WHERE username = 'admin' --';
```
Obteniendo acceso como `admin`.
##### Prevención con PDO y Consultas Preparadas
```php
<?php

$stmt = $pdo->prepare('SELECT * FROM users WHERE username = :user');
$stmt->execute(['user' = $_GET['user']]);
$user = $stmt->fetch();
```
Los parámetros se envían por separado, impidiendo inyección.
##### Prevención con `mysqli` y `Bind`
```php
<?php

$stmt = $mysqli->prepare('SELECT * FROM users WHERE username = ?');
$stmt->bind_param('s', $_POST['user']);
$stmt->execute();
$result = $stmt->get_result();
```
`?` marca el `placeholder` y `bind_param` asigna el valor de manera segura.
##### Validación Adicional
Antes de preparar, validar formato de entrada.
```php
<?php

if (!preg_match('/^[a-z0-9_]{3,20}$/i', $_POST['user'])) {
	die('Usuario inválido.');
}
```
Añade una capa extra de defensa.

---
## ✍️ Notas

- Usar PDO ([[10.1 PDO]]) por defecto en nuevos proyectos y nunca concatenar variables directamente.
- Implementar `logging` y alertas si se detecta un `pattern` sospechoso en las consultas o errores de base de datos para responder rápidamente ante ataques.

