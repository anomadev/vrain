El `Cross-Site Scripting` (XSS) es una de las vulnerabilidades más comunes y peligrosas en aplicaciones web. Consisten en inyectar scripts maliciosos en el navegador de otro usuario, generalmente a través de entradas no sanitizadas ([[9.7 Sanitization Techniques]]).
PHP proporciona una función sencilla pero poderosa para mitigar este riesgo: `htmlspecialchars()`. Esta función convierte caracteres especiales en entidades HTML seguras, evitando que el navegador los interprete como código ejecutable.

---
### Definición
XSS `Cross-Site Scripting` permite que un atacante inserte código JavaScript malicioso en páginas que otros usuarios visitan. Esto puede:
- Robar cookies ([[8.5 State Management (Cookies)]])
- Capturar datos de formularios ([[8.3 Form Processing]])
- Redirigir a sitios maliciosos
- Suplantar identidad visual de la app
La función `htmlspecialchars()` escapa caracteres especiales (`<`, `>`, `"`, `'`, `&`) para que no se ejecuten como HTML o JavaScript.
```php
htmlspecialchars(string $string, int $flags, = ENT_QUOTES | ENT_SUBSTITUTE, string|null $encoding = null, bool $double_encode = true): string
```

> Entrada sin `htmlspecialchars()` = como dejar las puertas abiertas de tu casa, cualquiera entra (scripts incluidos). 
> Entrada con `htmlspecialchars()` = como poner vidrio antibalas entre tú y el público: lo que dicen puede verse, pero no hacerte daño.

##### Vulnerable (sin escapar la salida)
```php
$name = $_GET['name'];
echo "Hola $name!";
```
Si el usuario visita:
```javascript
script.php?name=<script>alert('hackeado')</script>
```
El navegador ejecutará el `alert()`.
##### Seguro con `htmlspecialchars()`
```php
$name = htmlspecialchars($_GET['name'], ENT_QUOTES, 'UTF-8');
echo "Hola $name!";
```
El navegador muestra y no ejecuta nada.
```php
Hola &lt;script&gt;alert('hackeado')&lt;/script&gt;
```

### Parámetros clave de `htmlspecialchars()`
- `ENT_QUOTES`: Escapa comillas simples y dobles (`'` y `"`)
- `ENT_HTML5` o `ENT_XML1`: Define el estándar para las entidades
- `UTF-8`: Codificación recomendada
- `double_encode`: Si `false`, no vuelve a codificar lo ya escapado
### Buenas prácticas para prevenir XSS
- Escape en la salida, no solo en la entrada: Sanitiza los datos justo antes de imprimirlos.
- Usa `htmlspecialchars()` o `htmlentities()` para HTML: Evita ejecución de etiquetado JS.
- Escapa valores en atributos HTML, URLs, etc.: Diferente contexto requiere escapes distintos.
- Usa cabeceras `Content-Type: text/html; charset=UTF-8`: Ayuda a prevenir interpretaciones raras ([[1.06 HTTP Headers]]).
- Nunca confíes en el contenido almacenado: Siempre vuelve a escapar antes de mostrar.

---
### Ejemplos prácticos
##### En un título HTML
```php
echo "<h1>" . htmlspecialchars($title, ENT_QUOTES, 'UTF-8') . "</h1>";
```
##### En un atributo
```php
echo '<input value="' . htmlspecialchars($value, ENT_QUOTES, 'UTF-8') . '">';
```
##### Error común: escapar en la entrada
Guardar el dato ya escapado y volver a escaparlo causa problemas visuales y funcionales:
```php
$comment = htmlspecialchars($_POST['comment']);
// Luego en HTML
echo htmlspecialchars($comment); // Doble escape innecesario
```

---
## ✍️ Notas

- Siempre escapar en la salida, no al guardar. Así se puede reutilizar los datos sin problemas.
- Si el dato se mostrará en HTML, usar `htmlspecialchars()`. Si va en una URL, usar `urlencode()`.
- Asegurarse que todos los `templates` o vistas tengan una capa central que escapen automáticamente las variables (`Blade`, `Twig`, `Latte`, etc.).
  
