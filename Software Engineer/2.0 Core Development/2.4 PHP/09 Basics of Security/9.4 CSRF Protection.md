La protección sobre CSRF (`Cross-Site Request Forgery`) en PHP se basa en generar un token único y secreto por sesión, incrustarlo en cada formulario o petición mutante y validarlo en el servidor antes de procesar la acción solicitada ([PHP Tutorial](https://www.phptutorial.net/php-tutorial/php-csrf/?utm_source=chatgpt.com)). Este token debe ser impredecible (ej. generado con `random_bytes()` o `md5(uniqid())`) y almacenado en sesión (`$_SESSION`), para luego compararlo con el valor enviado por el cliente, rechazando cualquier petición con token ausente, inválido o expirado ([TutorialsPoint](https://www.tutorialspoint.com/php/php_csrf.htm?utm_source=chatgpt.com)). Además es recomendable configurar una fecha de expiración del token, reutilizarlo solo una vez o regenerarlo tras validación, y combinar esta técnica con políticas de cabeceras seguras (`SameSite`, `Secure`, `HttpOnly`) ([[1.06 HTTP Headers]]) para mitigar otros vectores de ataque ([Laravel](https://laravel.com/docs/12.x/csrf?utm_source=chatgpt.com)). 

---
### Definición
El CSRF es un ataque en el que un sitio malicioso induce al usuario autenticado en otro sitio a ejecutar acciones no deseadas (por ejemplo, transferencias bancarias) aprovechando que el navegador envía automáticamente las cookies de sesión ([[1.07 Cookies]], [[8.5 State Management (Cookies)]]). La prevención consiste en insertar un token anti-CSRF generado por el servidor en formularios mutantes (`POST`, `PUT`, `DELETE`) ([[8.1 HTTP Methods]]) y verificarlo en cada petición antes de ejecutar la acción.

---
### Conceptos Clave
1. **Generación y Almacenamiento**
	- **Token único**: utilice `bin2hex(random_bytes(32))` o `md5(uniqid(mt_rand(), true))` para crear un valor impredecibles.
	- **Sesión** ([[8.6 Sessions]]): almacene el token en `$_SESSION['_csrf_token']` junto a una marca de tiempo si desea expiración.
2. **Inyección en Formularios** ([[8.3 Form Processing]]): Añada un campo oculto en cada formulario que realice cambios:
	`<input type="hidden" name="csrf_token" value="<?php echo $_SESSION['_csrf_token']; ?>">`.
3. **Validación del token**: Al procesar el formulario, compare el token enviado con el de sesión y opcionalmente verifique expiración:
	`if (!hash_equeals($_SESSION['_csrf_token'], $_POST['csrf_token'] ?? '' )) {}`
4. **Buenas prácticas**
	- **Un solo uso**: al validarlo, considere eliminarlo y regenerar uno nuevo.
	- **Expiración**: guarde `$_SESSION['_csrf_token_time']` y rechace tokens viejos (ej. 30 min.)
	- **Cabeceras seguras** ([[1.06 HTTP Headers]]): combine con `SameSite=Lax` o `Strict` en cookies y `Secure`/`HttpOnly`.

---
### Ejemplos Prácticos
##### Generar y mostrar el token
```php
<?php

session_start();

if (empty($_SESSION['_csrf_token']) || $_SESSION['_csrf_token_tome'] < time() - 1800) {
	$_SESSION['_csrf_token'] = bin2hex(random_bytes(32));
	$_SESSION['_csrf_token_time'] = time();
}
?>

<form method="post" action="procesar.php">
  <input type="hidden" name="csrf_token" value="<?= $_SESSION['_csrf_token'] ?>">
  <!-- demás campos -->
  <button>Enviar</button>
</form>
```
##### Validar el token en el procesamiento
```php
<?php

session_start();

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
	$userToken = $_POST['csrf_token'] ?? '';

	if (!hash_equals($_SESSION['_csrf_token'] ?? '', $userToken)) {
		die('CSRF token inválido');
	}

	// Elimimar token tras usar
	unset($_SESSION['_csrf_token'], $_SESSION['_csrf_token_time']);
	// Procesar lógica del formulario
}
```
##### Incluir token en peticiones AJAX (`fetch`)
```javascript
fetch('/api/editar', {
	method: 'POST',
	headers: {
		'Content-Type':'application/json',
	    'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
	},
	body: JSON.stringify({ dato: valor })
});
```

```html
<meta name="csrf-token" content="<?= $_SESSION['_csrf_token'] ?>">
```
##### Protección adicional con `referer`
```php
$ref = $_SERVER['HTTP_REFERER'] ?? '';
if (parse_url($ref, PHP_URL_HOST) !== 'tu-dominio.com') {
	die('Origen invalido');
}
```
Actúa como segunda capa, aunque no infalible.

---
## ✍️ Notas

- Usar siempre tokens de un solo y corto periodo para disminuir la ventana de ataque.
- Complementar con cabeceras seguras ([[1.06 HTTP Headers]]) y verificación de origen (aunque no infalible) para mayor robustez.
