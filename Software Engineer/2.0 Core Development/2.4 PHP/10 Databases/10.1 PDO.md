PDO (`PHP Data Objects`) es las extensión estándar de PHP para acceder a bases de datos de forma segura, consistente y portátil. Proporciona una capa de abstracción que permite escribir el mismo código para `MySQL`, `PostgreSQL`, `SQLite` y otros SGBD, sin alterar consultas principales ([PHP](https://www.php.net/manual/en/intro.pdo.php?utm_source=chatgpt.com)). Su soporte de sentencias preparadas aísla los datos del usuario de la lógica SQL, mitigando inyecciones SQL. Además PDO facilita el manejo de errores mediante excepciones, soporta transacciones para garantizar la integridad de los datos y expone un conjunto de métodos orientados a objetos que simplifican operaciones complejas como la vinculación de parámetros y la obtención de resultados. En producción, permite cambiar de motor de base de datos solo ajustando el DSN, sin tocar lógica de consulta, lo que acelera mantenibilidad y escalabilidad ([Stack Overflow](https://stackoverflow.com/questions/6980792/what-is-pdo-why-should-i-use-it?utm_source=chatgpt.com)).

---
### Definición 
La extensión PDO define una interfaz de acceso a base que es independiente del sistema subyacente. Cada SGBD se implementa mediante un controlador PDO específico (p. ej. `pdo_mysql`, `pdo_pgsql`) que se conecta al servidor y ejecuta consultas bajo la misma API ([[1.01 What are APIs]]).

--- 
### Conceptos Clave
##### Conexión y DSN
Para crear una conexión, se instancia la clase `PDO` con un DSN (`Data Source Name`), usuario y contraseña:
```php
$pdo = new PDO(
	'mysql:host=localhost;dbname=testdb;charset=utf8mb4',
	'usuario',
	'contraseña'
);
```
EL DSN varía según el controlador:
- MySQL: `mysql:host=...;dbname=...`
- SQLite: `sqlite:/ruta/a/archivo.db`
##### Manejo de Errores
Configura PDO para que lance excepciones en lugar de silencios o `warnings`:
```php
$pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);
```
Así puedes `try/catch` para centralizar la lógica de errores.
##### Sentencias Preparadas
Separan la consulta de los datos, usando `placeholders`:
```php
$stmt = $pdo->prepare('SELECT * FROM users WHERE email = :email');
$stmt->execute(['email' => $emailUsuario]);
$usuario = $stmt->fetch();
```
Esto escapa automáticamente los valores vinculados, evitando inyección SQL.
##### Transacciones
Permite agrupar varias operaciones atómicas:
```php
$pdo->beginTransaction();
try {
	// Varias operaciones
	$pdo->commit();
} catch (Exception $e) {
	$pdo->rollBack();
	throw $e;
}
```
Clave para mantener la consistencia en transferencias de fondos, inventarios, etc.
##### Portabilidad
Cambiar el motor solo implica modificar el DSN; el resto del código permanece igual:
```php
$pdo = new PDO('sqlite:/ruta/mi.sqlite');
```
Esto acelera migraciones y pruebas en diferentes entornos.

---
### Ejemplos Prácticos
##### Inserción Segura
```php
$sql = "INSERT INTO productos (nombre, precio) VALUES (:nombre, :precio)";
$stmt = $pdo->prepare($sql);
$stmt->execute([
	'nombre' => 'Taza',
	'precio' => 9.99
]);
```
Inserta sin concatenar `string` ([[2.3 Data Types]]) a mano, protegiendo datos de usuario.
##### Obtención de varios registros
```php
$rows = $pdo->prepare('SELECT id, nombre FROM categorias')
	->fetchAll(PDO::FETCH_ASSOC);
```
`fetchAll` con `PDO::FETCH_ASSOC` devuelve `arrays` asociativos claros y legibles.
##### Uso de `placeholders` posicionales
```php
$stmt = $pdo->prepare('SELECT * FROM orders WHERE status = ? AND total > ?');
$stmt->execute(['pendiente', 100]);
$orders = $stmt->fetchAll();
```
Alternativa a los marcadores nombrados, útil en scripts rápidos.
##### `Count` con `Binding`
```php
$stmt = $pdo->prepare('SELECT COUNT(*) FROM visitas WHERE pagina = :pagina');
$stmt->execute(['pagina' => '/home']);
$total = $stmt->fetchColumn();
```
`fetchColumn` extrae directamente el primer campo de la primera fila.
##### Cambiar modo de `fetch`
```php
$stmt = $pdo->prepare('SELECT * FROM usuarios');
$stmt->execute();
$stmt->setFetchMode(PDO::FETCH_CLASS, Usuario::class);
while ($user = $stmt->fetch()) {
	// $user es instancia de Usuario
}
```
Convierte filas en objetos con propiedades y métodos, ideal en patrones `Active Record`.

---
## ✍️ Notas

- Usar sentencias preparadas siempre, incluso para consultas estáticas, por consistencia
- Para consultas de alta frecuencia, implementar un `pool` de conexiones o reutilizar instancias de PDO.
