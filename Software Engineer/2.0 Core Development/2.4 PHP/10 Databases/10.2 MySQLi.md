La extensión MySQL (`MySQL Improved`) en PHP ofrece una interfaz procedural y orientada a objetos para interactuar con servidores MySQL de versión 4.1 en adelante. Proporciona sentencias preparadas que aíslan datos del usuario de la lógica SQL, previniendo inyecciones ([[9.2 SQL Injection]]), y soporte nativo de transacciones para garantizar la integridad de datos en operaciones complejas. `MySQLi`  permite controlar errores mediante propiedades y funciones integradas, así como configurar el modo de informe para lanzar excepciones o advertencias. Su DSN procedural (`mysqli_connect`) y la clase `mysqli` en modo OO (`mysqli::__construct`) facilitan la conexión y configuración avanzada (opciones, persistencia). Además, funciones como `mysqli_execute_query()` combinan `prepare`/`execute` en solo paso para simplificar el código. `MySQLi` es, por tanto, la opción estándar de PHP para bases de datos MySQL, equilibrando seguridad, rendimiento y portabilidad.

---
### Definición
La extensión `MySQLi` define dos formas de uso:
- **Procedural**: funciones como `mysqli_connect()`, `mysqli_query()`, `mysqli_prepare()`.
- **Orientada a objetos**: la clase `mysqli` con métodos como `->query()`, `->prepare()`, `->begin_transaction()`.
Requiere habilitar la extensión `mysqli` en PHP y se conecta a MySQL4.1+. 

---
### Conceptos Clave
##### Conexión a la base de datos
- Procedural
```php
$link = mysqli_connect('localhost', 'user', 'pass', 'db');
if (!$link) {
	die('Error de conexión: ' . mysqli_connect_error());
}
```
- Orientado a objetos
```php
$mysqli = new mysqli('localhost', 'user', 'pass', 'db');
if ($mysqli->connect_error) {
	die("Error " . $mysqli->connect_error);
}
```
##### Manejo de Errores
- Silencioso por defecto en procedural, o con excepciones/advertencias en OO ajustando `mysqli_report()` o `$mysqli->report_mode`.
- Funciones para último error: `mysqli_error()`, `mysqli_error_list()` en procedural, o `$mysqli->error`, `$mysqli->error_list` en OO.
##### Sentencias preparadas
1. Prepare
```php
$stmt = $mysqli->prepare('SELECT * FROM users WHERE id = ?');
```
2. `Bind`
```php
$smtm->bind_param('i', $id);
```
3. `Execute`
```php
$stmt->execute();
$result = $stmt->get_result();
```
Repite con los nuevos valores de `$id` para múltiples ejecuciones sin re-preparar.
##### Transacciones
```php
$mysqli->begin_transaction();
try {
	$mysqli->query("UPDATE accounts SET balance = balance - 100 WHERE id = 1");
	$mysqli->query("UPDATE accounts SET balance = balance - 100 WHERE id = 2");
	$mysqli->commit();
} catch (Exception $e) {
	$mysqli->rollback();
	throw $e;
}
```
Requiere motor `InnoDB` activo.
##### Características Avanzadas
Opciones antes de conectar:
```php
$mysqli = mysqli_init();
$mysqli->options(MYSQLI_OPT_CONNECT_TIMEOUT, 5);
$mysqli->real_connect(...);
```
- Multi-query con `multi_query()` y recuperación secuencial.
- `execute_query()` en PHP 8+: atajo para `prepare` + `bind` + `execute` + `get_result`.

---
### Ejemplos Prácticos
##### Inserción Simple (Procedural)
```php
$name = $mysqli->real_escape_string($_POST['name']);
$myqli->query("INSERT INTO products (name) VALUES ('$name')");
```
##### Consulta con `Placeholders` (OO)
```php
$stmt = $mysqli->prepare('SELECT email FROM users WHERE username = ?');
$stmt->bind_param('s', $user);
$stmt->execute();
$stmt->bind_result($email);
$stmt->fetch();
```
##### Ejecutar Múltiples Consultas
```php
$sql = "UPDATE a SET x=1; DELETE FROM b WHERE id=2;";
if ($mysqli->multi_query($sql)) {
	do {
		if ($res = $mysqli->store_result()) {
			$res->free();
		}
	} while ($mysqli->more_results() && $mysqli->next_result()); 
}
```
##### Obtener Columna Directamente
```php
$result = $mysqli->query("SELECT COUNT(*) FROM visits");
$count = $result->fetch_row()[0];
```
##### Modo de Reporte de Errores
```php 
mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);
$mysqli = new mysqli(...);

// Ahora lanza excepciones en errores
```

---
## ✍️ Notas

- Usar `mysqli_report()` para convertir `warnings` en excepciones y unificar el flujo de manejo de errores.
- En proyectos con requerimientos de alta concurrencia, configurar `timeouts` y evaluar persistencia de conexiones.
