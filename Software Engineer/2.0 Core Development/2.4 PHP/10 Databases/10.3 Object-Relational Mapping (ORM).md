Un `Object-Relational Mapper` (ORM) es una capa de software que traduce automáticamente entre objetos en tu lenguaje de programación y registros en una base de datos relacional, creando un "mapa" que oculta la complejidad de SQL tras una interfaz orientada a objetos. Al usar un ORM, dejas de escribir manualmente sentencias SQL y pasas a invocar métodos en clases y propiedades, lo que acelera el desarrollo, promueve el principio DRY y facilita la portabilidad entre SGBD. Sin embargo, abusar de él puede llevara sobrecarga de rendimiento y consultas ineficientes; por eso conviene conocer tanto sus ventajas (modelo unificado, consultas seguras, abstracción de DB) como sus limitaciones (curva de aprendizaje, tunning manual para casos complejos).

---
### Definición
- ORM: Técnica de programación para convertir datos entre un modelos de objetos y un modelo relacional en la base de datos, proporcionando un "almacén virtual de objetos" accesible desde el código.
- En la práctica, un `ORM Library` es simplemente una librería en tu lenguaje que encapsula la lógica de SQL, permitiéndote interactuar con base de datos a través de objetos y métodos en lugar de cadenas SQL.

---
### Conceptos Clave
1. **Abstracción y portabilidad**: Un ORM desacopla tu código del SGBD concreto; cambias el DSN o el controlador (`MySQL`, `PostgreSQL`, `SQLite` …) y tu lógica de acceso a datos sigue funcionando sin apenas cambios.
2. **Sentencias preparadas automáticas**: Al usar métodos como `find`, `save()` o `query()`, el ORM genera tras bambalinas consultas parametrizadas, aislando los datos de usuario del SQL y previniendo inyecciones.
3. **DRY y Modelo Único**: Defines tu modelo de datos (clases y relaciones) en un único lugar, y el ORM se encarga de mantenerlo sincronizado con la base de datos, evitando duplicar la estructura en código y SQL.
4. **Control de Relaciones y `Lazy/Eager Loading`**: Los `ORMs` permiten definir relaciones (uno a uno, uno a muchos, muchos a muchos) y elegir cómo y cuándo cargar datos relacionados (carga perezosa vs ansiosa), optimizando el uso de memoria y tiempo de consulta.
5. **Limitaciones y Rendimiento**
	- **Curva de aprendizaje**: Dominar la API del ORM y su configuración inicial lleva tiempo.
	- **Consultas compleja**: Para operaciones muy especializadas o del alto rendimiento, un SQL master suele superar al ORM.
	- **`Overhead`**: Cada capa de abstracción añade procesamiento, por lo que en bucles intensivos conviene medir y, si es necesario, escribir SQL manual.

---
### Ejemplos Prácticos
##### Consulta básica con un ORM inventado
```php
// Sin ORM
$sql = "SELECT * FROM library WHERE author = 'Linus'";
$rows = $db->query($sql);
$books = [];
foreach ($rows as $row) {
	$b = new Book();
	$b->author = $row['author'];
	$books[] = $b;
}

// Con ORM
$books = Book::query()->where('authors', 'Linus')->get();
```
##### Inserción de un nuevo registro
```php
// Asumiendo un ORM estilo ActiveRecord
$user = new User();
$user->name = 'Maria';
$user->email = 'maria@example.com';
$user->save(); // Genera INSERT automáticamente
```
##### Definiendo relaciones
```php
class Post extends Model {
	public function comments() {
		return $this->hasMany(Comment::class);
	}
}

// Carga perezosa (lazy)
$post = Post::find(1);
$comments = $post->comments;
```
##### Cambio de base de datos
```php
// MySQL
ORM::configure('mysql:host=localhost;dbname=blog');
// SQLite
ORM::configure('sqlite:/path/to/blog.sqlite');
// Sin cambiar el código de consultas
```
##### Uso de `frameworks`
- **PHP**: [Doctrine](https://www.doctrine-project.org) y [Eloquent (Laravel)](https://laravel.com/docs/12.x/eloquent).
- **Java**: Hibernate ORM.
- **Python**: [SQLAlchemy](https://www.sqlalchemy.org/) .
- **.NET**: [Dapper](https://github.com/DapperLib/Dapper), Entity Framework.

---
## ✍️ Notas

- Usar la mayoría operaciones (`CRUD`), pero escribir `SQL` a mano cuando necesites máximo rendimiento o consultas muy especializadas.
- Siempre monitorear el registro de consultas en desarrollo para detectar cargas excesivas o patrones ineficientes.
