Las transacciones de base de datos en PHP mediante PDO ([[10.1 PDO]]) garantiza que un conjunto de operaciones (`INSERT`, `UPDATE`, `DELETE`, etc.) se ejecute de manera atómica, aislada, consistente y duradera (propiedades ACID). Por defecto, PDO inicia cada consulta en `autocommit`, donde cada sentencia es su propia transacción implícita ([PDO](https://www.php.net/manual/en/pdo.transactions.php)). Para agrupar varias consultas en una única transacción, se utiliza `beginTransaction()`, seguido de `commit()` para aplicar todos los cambios o `rollBack()` para deshacerlos si ocurre un error. Esto no solo mejora la seguridad (evita estados intermedios inconsistentes) sino también el rendimiento, al reducir la sobrecarga de `commits` individuales. Cuando una transacción está activa, `inTransaction()` permite verificar se estado en tiempo de ejecución. Sin embargo, hay que tener cuidado con sentencias DDL ([[3.1 DDL]]) (p. ej. `DROP TABLE`), pues en MySQL provocan un `commit` implícito que impedirá el `rollback` de cambios previos en la transacción.

---
### Definiciones Principales
- `Autocommit`: Modo predeterminado en PDO donde cada sentencia SQL se ejecuta y se confirma automáticamente como una transacción individual. Si el motor de base de datos no soporta transacciones, funciona igual sin posibilidad de `rollback`.
- Transacción (Atomicidad, Consistencia, Aislamiento, Durabilidad - ACID):
	- Atomicidad: Todas las operaciones dentro de la transacción deben completarse o ninguna lo hace.
	- Consistencia: La base de datos pasa de un estado válido a otro válido.
	- Aislamiento: Operaciones concurrentes no interfieren entre sí.
	- Durabilidad: Una vez confirmada (`commit`), la transacción es permanente, incluso tras fallos de sistemas.
- `beginTransaction()`: Deshabilita el modo `autocommit` y marca el inicio de una nueva transacción.
	```php
	$pdo->beginTransaction();
	```
	Devuelve `true` si el controlador de base de datos la soporta y no había otra transacción activa.
- `commit`: Aplica de manera permanente todos los cambios desde que se llamó a `beginTransaction()`.
	```php
	$pdo->commit();
	```
	Si no había transacción activa lanza `PDOException`.
- `rollBack()` Revierte todos los cambios realizados desde `beginTransaction()`, devolviendo la bade de datos al estado anterior.
	```php
	$pdo->rollBack()
	```
	Si no hay transacción activa lanza `PDOException`.
- `inTransaction()`: Retorna un booleano indicando si actualmente hay una transacción en curso en ese objeto PDO.
```php
	 $pdo->inTransaction();
```
Útil para condicionar lógicas que dependen de un estado transaccional.

---
### Conceptos Clave
##### Modo `autocommit` vs Modo Manual
- `autocommit` (por defecto):
	- Cada `INSERT`, `UPDATE` o `DELETE` se ejecuta en su propia transacción y se confirma inmediatamente.
	- Evita bloqueos prolongados en la base de datos, pero impide revertir grupos de operaciones.
- Modo Manual (Transaccional):
	- Llamas a `beginTransaction` para deshabilitar `autocommit`.
	- Todas las consultas subsecuentes hasta `commit()` o `rollBack()` se agrupan en una única transacción.
	- Mejora la consistencia y permite `rollback` en caso de error.
> Analogía: Imagina `autocommit` como pagar cada artículo en el supermercado por separado (cada envío es irreversiblemente aplicado). Una transacción es como poner todos los productos en un carrito y solo pagar todo junto en caja; si algo está mal (por ejemplo, un producto dañado), devuelves todo antes de pagar.
##### Flujo de Uso Básico
```php
// Conectar: Crear instancia PDO y configurar manejo de errores:
$pdo = new PDO($dsn, $user, $pass, [
	PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
]);

// Iniciar Transacción
$pdo->beginTransaction();

// Ejecutar Consultas:
$pdo->exec("UPDATE cuentas SET saldo = saldo - 100 WHERE id=1");
$pdo->exec("UPDATE cuentas SET saldo = saldo + 100 WHERE id=2");

// Validar y Confirmar
if ($todoBien) {
	$pdo->commit();
} else {
	$pdo->rollbBack();
}
```
Estado final: luego del `commit()` o `rollBack()`, PDO restaura el modo `autocommit` automáticamente.
##### Manejo de Errores con Excepciones
- Configurar `PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION` permite capturar cualquier fallo SQL con un `PDOException` en lugar de manejar códigos de error manualmente.
- Dentro de un bloque `try/catch`, si ocurre excepción entre `beginTransaction()` y `commit()`, se debe llamar a `rollBack()` en el bloque `catch` para revertir los cambios parciales.
##### Implicaciones de Sentencias DDL
- En MySQL, cualquier sentencia DDL (p. ej. `CREATE TABLE`, `DROP TABLE`) provoca un `commit` implícito y cierra la transacción actual sin advertencia, haciendo imposible revertir cambios previos.
- Para evitar sorpresas, se recomienda no incluir DDL dentro de transacciones o usar bases de datos que soporten DDL transaccional (p. ej. PostgreSQL).
##### Ventajas Adicionales de usar Transacciones
- Integridad de Datos: Si un procedimiento involucra múltiples actualizaciones aseguras que ningún paso quede a medias.
- Rendimiento: Agrupar muchas actualizaciones dentro de una sola transacción puede ser más rápido que confirmar cada una por separado.
- Aislamiento: Evitas que otras conexiones vean datos intermedios hasta que `commit()` los haga visibles.

---
### Ejemplos Prácticos
##### Transferencia de fondos entre cuentas
```php
<?php

try {
	$pdo = new PDO($dsn, $user, $pass, [
		PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
	]);

	// Inicia transacción
	$pdo->beginTransaction();

	// Debitar cuenta No. 1
	$stmt = $pdo->prepare("UPDATE cuentas SET saldo = saldo - :monto WHERE id = :id");
	$stmt->execute(['monto' => 100, 'id' => 1]);

	// Acreditar cuenta No. 2
	$stmt->execute(['monto' => 100, 'id' => 2]);

	// Confirma ambos cambios
	$pdo->commit();
	echo "Transferencia exitosa";
} catch (PDOException $e) {
	// Revierte si falla cualquiera de las dos consultas
	if ($pdo->inTransaction()) {
		$pdo->rollBack();
	}
	echo "Error en la transferencia: " . $e->getMessage();
}
```
La transacción asegura que ambas operaciones de saldo se apliquen o ninguna.
##### Inserción masiva de registros
```php
<?php

$data = [
	['nombre' => 'Manzana', 'color' => 'rojo', 'calorias' => 52],
    ['nombre' => 'Banana', 'color' => 'amarillo', 'calorias' => 96],
    // … más frutas
];

try {
	$pdo->beginTransaction();
	$stmt = $pdo->prepare("INSERT INTO frutas (nombre, color, calorias) VALUES (?, ?, ?)");
	foreach ($data as $f) {
		$stmt->execute([$f['nombre'], $f['color'], $f['calorias']]);
	}
	$pdo->commit();
	echo "Inserción masiva completada";
} catch (PDOException $e) {
	$pdo->rollBack();
	echo "Error en inserción: " . $e->getMessage();
}
```
Insertar múltiples filas dentro de una transacción mejora rendimiento y evita estados intercambios inconsistentes.
##### Verificar estado de transacción
```php
<?php

$pdo->beginTransaction();
if ($pdo->inTransaction()) {
	echo "Estamos dentro de una transacción activa";
}
$pdo->rollBack();
```
`inTransaction()` retorna `true` mientras la transacción no haya sido confirmada o revertida.
##### Control de `DDL` y `Commit` implícito
```php
<?php

try {
	$pdo->beginTransaction();

	// Operación DDL en MySQL causa commit implícito
	$pdo->exec("DROP TABLE IF EXISTS temporal");  // commit implícito
	$pdo->exec("UPDATE inventario SET cantidad = cantidad - 1 WHERE id = 5");

	// Este rollBack() ya no revertirá el DROP TABLE
	$pdo->rollBack();
} catch (PDOException $e) {
	echo "Error: " . $e->getMessage();
}
```
El `DROP TABLE` genera un `commit` implícito, haciendo que el `rollBack()` posterior no tenga efecto sobre la eliminación.
##### Uso de transacciones con funciones personalizadas `wrapper`
```php
<?php

function withTransaction(PDO $pdo, callable $callback) {
	try {
		$pdo->beginTransaction();
		$result = $callback($pdo);
		$pdo->commit();

		return $result;
	} catch (PDOException $e) {
		if ($pdo->inTransaction()) {
			$pdo->rollBack();
		}
		throw $e;
	}
}

// En código cliente
try {
	withTransaction($pdo, function($db) {
		$db->exec("UPDATE cuentas SET saldo -= 50 WHERE id = 3");
		$db->exec("DELETE FROM buses WHERE id = 42");

		return "Operación completada";
	});
} catch (PDOException $e) {
	echo "Falló la operación: " . $e->getMessage();
}
```
Simplifica el patrón `try/catch` y garantiza `rollBack` automático en caso de error.

---
## ✍️ Notas

- Considera las transacciones como un "seguro de accidentes", aseguran que grupos de cambios críticos se apliquen todos o ninguno.
- Evita incluir `DDL` en transacciones MySQL por el `commit` implícito, salvo que el DBMS lo soporte (PostgreSQL).
- Siempre usa `inTransaction()` antes de `rollBack()` en bloques de error para evitar excepciones adicionales si ya se salió de la transacción.
