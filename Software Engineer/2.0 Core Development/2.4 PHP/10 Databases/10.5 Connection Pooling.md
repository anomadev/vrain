En PHP, el `Connection Pooling` se logra principalmente mediante conexiones persistentes, que mantienen viva la conexión a la base de datos más allá del ciclo de vida de cada script. Para Oracle, la extensión OCI8 ofrece `oci_pconnect`, que reutiliza conexiones en caché entre procesos PHP y puede integrarse con `Oracle Database Resident Connection Pooling` (DRCP) en Oracle 11g+ para un escalado eficiente. En MySQL, tanto `MySQLi` como `PDO_MYSQL` permiten conexiones persistentes --en `MySQLi` ([[10.2 MySQLi]]) se antepone `p:` al host y en PDO ([[10.1 PDO]]) se usa `PDO::ATTR_PERSISTENT`, guardando conexiones en un `pool` listo para ser reutilizado por nuevos scripts. Estos mecanismos reducen el sobrecosto de abrir/cerrar conexiones continuamente, mejoran el rendimiento y la escalabilidad de aplicaciones web. No obstante, es crucial manejar correctamente el estado de la conexión en cada uso: `MySQLi` ejecuta automáticamente `mysqli_change_user()` para limpiar conexiones antes de reutilizarlas, y en OCI8 se recomienda configurar parámetros como `oci8.max_persistent` y `oci8.persistent_timeout` o usar DRCP con un `connection_class` consistente para evitar saturar el pool con credenciales diversas.

---
### Definiciones Principales
##### Conexión Persistente
Una conexión persistente no se cierra al finalizar el script PHP. En su lugar, queda en un pool dentro del proceso (o hijo de Apache ([[22.1 Apache]])/PHP-FPM ([[19.6 PHP-FPM]])) para que un nievo script la reutilice, evitando la sobrecarga de conexión al servidor de base de datos.
##### OCI8 (`oci_pconnect`)
- `oci_pconnect(string $username, string password, string $connection_string, string $encoding = "", int $session_mode = OCI_DEFAULT)`: Crea una conexión persistente a Oracle y la coloca en un caché que persiste entre solicitudes HTTP, por proceso PHP.
- DRCP (`Database Resident Connection Pooling`): Pool de conexiones manejado por Oracle 11g+ en el servidor, que OCI8 aprovecha para reusar sesiones sin abrir nuevas conexiones físicas.
##### `MySQLi` Persistente
- Host con prefijo `p:`: Para abrir una conexión persistente en `MySQLi` ([[10.2 MySQLi]]), se antepone `p:` al nombre de host en `new mysqli('p:localhost', 'user', 'pass', 'db')`.
- `mysqli_change_user()`: Antes de devolver una conexión a un script, `MySQLi` limpia el estado interno (`rollback` de transacciones, cierre de tables temporales, desbloqueo de tablas, reseteo de variables de sesión) llamando internamente a `mysql_change_user()`.
##### PDO Persistente
- Opción `PDO::ATTR_PERSISTENT`: Al crear un objeto PDO ([[10.1 PDO]]) para MySQL (`new PDO($dsn, $user, $pass, [PDO::ATTR_PERSISTENT => true])`), se utiliza un `pool` de conexiones persistentes compartidas por cada hilo de PHP, reduciendo el `overhead` de apertura.

---
### Conceptos Clave
##### Ventajas del `Connection Pooling`
- **Rendimiento**: Reutilizar una conexión existente evita el "`handshake`" de autenticación y la inicialización de sesión en el servidor de BD, acelerando el tiempo de respuesta del script.
- **Escalabilidad**: En entornos de alta concurrencia, un `pool` evita agotar el límite de conexiones simultáneas en la base de datos al reciclar conexiones activas y cerrarlas solo cuando ya no se necesiten.
- **Consistencia**: La limpieza automática (`rollback`, reseteo de sesiones) en `MySQLi` y la gestión de DRCP en Oracle ayudan a que cada script arranque con un estado "nutrido" y evite comportamientos impredecibles.
##### Configuración en OCI8
- `oci8.max_persistent`: Número máximo de conexiones persistentes que un proceso PHP mantendrá en su cache. Un valor de `-1` significa "sin limite".
- `oci8.persistent_timeout`: Segundos que una conexión persistente permanece ociosa antes de cerrarse para liberar recursos.
- `oci8.connection_class`: La identidad de grupo de DRCP. Al usar el mismo `connection_class` en varios web servers, todos toman conexiones del mismo `pool` DRCP, reutilizando sesiones compartidas equilibrando la carga.
##### Configuración de `MySQLi`
- Prefijo `p:` al host: abre una conexión persistente:
```php
	$mysqli = new mysql('p:localhost', 'usuario', 'password', 'base_datos');
	```
- `mysqli.allow_persistent`: Directiva en `php.ini` que habilita o deshabilita conexiones persistentes en `MySQLi`.
- `mysql.max_persistent`: Número máximo de conexiones persistentes permitidas por proceso PHP.
- `cleanup` automático: `MySQLi` llama a `mysql_change_user()` para resetear la conexión antes de devolverla al `pool`, evitando "estado sucio" como transacciones sin cerrar o `locks` pendientes.
##### Configuración en `PDO`
- `PDO::ATTR_PERSISTENT`: Se pasa como opción al constructor de PDO:
```php
$pdo = new PDO($dsn, $usuario, $pass, [
	PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
	PDO::ATTR_PERSISTENT => true,
]);
```
- `Pool` interno de PDO: implementado por el driver específico (p. ej. `PDO_MYSQL`), reutiliza la conexión cuando se crea una nueva instancia PDO con las mismas credenciales dentro del mismo proceso.
- Limitaciones: A diferencia de `MySQLi`, PDO no siempre garantiza una limpieza automatizada del estado (depende del driver); se recomienda cerrar punteros (`$stmt = null`) antes de reutilizar la conexión.
##### Riesgos y Buenas Prácticas
- Estado socio de la conexión: Si no se limpian transacciones o `locks`, el script siguiente hereda esos estados y puede comportarse de forma errática. `MySQLi` mitiga esto con `mysql_change_user()`, pero en PDO se debe invocar manualmente `ROLLBACK` o cerrar manualmente recursos.
- Límite de conexiones: Configurar `mysql.max_persistent`, `oci8.max_persistent` y monitorear el tamaño del `pool` para evitar agotar la base de datos con conexiones inactivas.
- Manejo de errores: En `MySQLi`, usar `mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT)` para que falle rápidamente y se limpien las conexiones tras errores. En PDO, acostumbrar a `PDO::ERRMODE_EXCEPTION`.
- DRCP: Para Oracle en entornos de gran escala, habilitar DRCP y fijar `oci8.connection_class` uniforme en todos los servidores web para compartir el pool del lado de BD y optimizar uso de recursos.

---
### Ejemplos Prácticos
##### Oracle `OCI8` con `Persistent` + DRCP
```php
<?php

// Antes de conectar, configurar la clase de conexión para DRCP
ini_set('oci8.connection_class', 'app_pool_class');
ini_set('oci8.max_persistent', 50);
ini_set('oci8.persistent_timeout', 3600);

try {
	// Conexión persistente, reutilizará si existe
	$conn = oci_pconnect('usuario', 'password',
		'(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=miHost)(PORT=1521))
          (CONNECT_DATA=(SERVICE_NAME=miServicio)(SERVER=POOLED)))'
	, 'AL32UTF8');
	echo "Conectando usando pool DRCP"
} catch (Exception $e) {
	echo "Error de conexión: " . $e->getMessage();
}
```
- DSN con `(SERVER=POOLED)`: Indica a Oracle que use DRCP
- El primer `oci_pconnect()` crea la conexión, posteriormente se sirve desde el DRCP `pool` en Oracle, reduciendo `overhead` en el servidor de DB.
##### `MySQLi` con Conexión Persistente
```php
<?php

mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);

$host   = 'p:localhost';       // Prefijo p: para persistente
$user   = 'miUsuario';
$pass   = 'miPassword';
$dbname = 'miBaseDeDatos';

try {
    $mysqli = new mysqli($host, $user, $pass, $dbname);
    echo "Conexión MySQLi persistente establecida";
    
    // Ejemplo de consulta
    $stmt = $mysqli->prepare("SELECT nombre, correo FROM usuarios WHERE id = ?");
    $id = 1;
    $stmt->bind_param('i', $id);
    $stmt->execute();
    $stmt->bind_result($nombre, $correo);
    $stmt->fetch();
    echo "Usuario: $nombre ($correo)";
    
    $stmt->close();  // Libera recursos antes de terminar
} catch (mysqli_sql_exception $e) {
    echo "Error MySQLi: " . $e->getMessage();
}
```
- `MySQLi` reusa esta conexión persistente en el mismo proceso para futuras solicitudes, limpiando automáticamente transacciones o tablas temporales.
- `mysqli_report()` con `MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT` fuerza excepciones en errores.
##### `PDO_MySQL` con opción persistente
```php
<?php

$dsn = 'mysql:host=localhost;dbname=miapp;charset=utf8mb4';
$options = [
    PDO::ATTR_ERRMODE            => PDO::ERRMODE_EXCEPTION,
    PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    PDO::ATTR_PERSISTENT         => true,  // Conexión persistente
];

try {
    $pdo = new PDO($dsn, 'miUsuario', 'miPass', $options);
    echo "Conexión PDO persistente establecida";
    
    // Ejemplo de consulta
    $stmt = $pdo->prepare("SELECT COUNT(*) FROM visitas WHERE pagina = ?");
    $stmt->execute(['/inicio']);
    $count = $stmt->fetchColumn();
    echo "Visitas a /inicio: $count";
} catch (PDOException $e) {
    echo "Error PDO: " . $e->getMessage();
}
```
- El `pool` de conexiones de `PDO_MYSQL` reutiliza la conexión en el mismo proceso PHP, si se solicitan con las mismas credenciales.
- A diferencia de `MySQLi`, no siempre existe limpieza automática de estado (depende de `mysqlnd`), por lo que conviene liberar `$stmt` y cerrar transacciones manualmente.
##### Limitar conexiones persistentes en `MySQLi`
- En `php.ini`
```ini
mysqli.allow_persistent = On
mysqli.max_persistent   = 5     
mysqli.max_links        = 50
```
- Con esto el proceso PHP solo podrá mantener 5 conexiones persistentes activas; nuevas peticiones tendrán que esperar o abrir conexiones no persistentes.
##### Uso de conexiones persistentes en múltiples scripts
```php
<?php

// script1.php
$pdo1 = new PDO($dsn, 'user', 'pass', [PDO::ATTR_PERSISTENT=>true]);
$pdo1->query("UPDATE contador SET valor = valor + 1");

// script2.php (simultáneo)
$pdo2 = new PDO($dsn, 'user', 'pass', [PDO::ATTR_PERSISTENT=>true]);
$sth = $pdo2->prepare("SELECT valor FROM contador");
$sth->execute();
echo $sth->fetchColumn();
```
- Ambos scripts comparten la misma conexión persistente en el `pool` si corren en el mismo procesos PHP, evitando múltiples conexiones abiertas contra el servidor de DB.
