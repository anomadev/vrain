Optimizar el rendimiento al trabajar con la extensión MySQL (original) en PHP implica tanto buenas prácticas SQL (índices, SELECT específicos, LIMIT) como aprovechar funciones nativas de la API de PHP ([[1.01 What are APIs]]) para reducir la sobrecarga: conexiones persistentes, consultas "no bufferizadas", liberar resultados y manejar adecuadamente la codificación de caracteres. Aún cuando la extensión `mysql_*` está en desuso frente a `MySQLi` ([[10.2 MySQLi]]) y `PDO` ([[10.1 PDO]]), es útil comprender sus mecanismos de rendimiento si se mantiene código legado.

---
### Definiciones Principales
- Conexiones persistentes (`mysql_pconnect`): Mantiene viva la conexión en un `pool` entre peticiones evitando el coste de reconectar en cada script.
- Consultas no bufferizadas (`mysql_unbuffered_query`): Permiten procesar resultados fila a fila sin cargar todo el `dataset` en memoria, ideal cuando se esperan grandes volúmenes de datos.
- Liberar memoria (`mysql_free_result`): Después de leer un `mysql_query`, es crucial llamar `mysql_free_result()` para devolver el buffer al sistema y evitar consumo excesivo de RAM.
- Escape de cadenas (`mysql_real_escape_string`): Sanitiza entradas para incluirlas en SQL, más rápido y seguro que `mysql_escape_string`, ya que respeta el `charset` de la conexión.
- `mysql_set_charset`: Configura la codificación de caracteres en la conexión para evitar conversiones costosas en cada consulta.

---
### Conceptos Clave
##### Conexiones Persistentes vs No Persistentes
- No persistentes (`mysql_connect`): Cada llamada abre y cierra una conexión al terminar el script. Esta apertura/cierre repetido es costoso en entornos de alta concurrencia.
- Persistentes (`mysql_pconnect`): PHP intenta reutilizar una conexión ya abierta en lugar de crear una nueva. Evita el "`handshake`" con el servidor MySQL, reduciendo latencia en scripts sucesivos.

> Analogía: conexión no persistente = llamar al taxista cada vez que necesitas un trayecto. Conexión persistente = el taxista te espera en tu puerta, listo para la siguiente carrera sin volver a llamar.

```php
<?php

$link = mysql_pconnect('localhost', 'usuario', 'password');
if (!$link) {
	die('No se pudo conectar: ' . mysql_error());
}
mysql_select_db('mibase', $link);
```
##### Consultas No Bufferizadas
- Bufferizadas (`mysql_query`): Traen todos los resultados a memoria antes de procesarlos. Para tablas pequeñas está bien, pero con millones de filas el consumo de RAM se dispara.
- No bufferizadas (`mysql_unbuffered_query`): Permiten iterar fila a fila mientras  se va descargando de la red, reduciendo el uso de memoria. Útil en reportes o scripts de migración de datos.

> Analogía:: Bufferizada = llenar maletero completo con todas las cajas antes de revisarlas. No bufferizadas = abrir la puerta del camión y sacar una caja a la vez.

```php
<?php

$result = mysql_unbuffered_query("SELECT id, nombre FROM usuarios");
while ($row = mysql_fetch_assoc($result)) {
	// Procesar cada fila sin cargar todo el set en memoria
	echo $row['id'] . ' - ' . $row['nombre'] . "\n";
}
```
##### Liberar Resultados y Recursos
Inmediatamente después de trabajar con un conjunto de resultados, llama a `mysql_free_result($result)` para liberar la memoria asignada. Si tu script ejecuta múltiples consultas, esto evita "fugas" de memoria que afectan el rendimiento en procesos de larga duración.

```php
<?php

$result = mysql_query("SELECT * FROM productos");
// procesar...
mysql_free_result($result);

// Ahora la memoria queda disponible para otras operaciones
```
##### Escapado Eficiente de Cadenas
Usa `mysql_real_escape_string($cadena, $link)` en lugar de `mysql_escape_string`. La primera considera el `charset` de la conexión, evitando conversaciones redundantes y posibles errores de codificación.

```php
<?php

$link = mysql_connect('localhost', 'user', 'pass');
mysql_select_db('midb', $link);
mysql_set_charset('utf8', $link);

$text = "O'Reilly & Co.";
$textoSeguro = mysql_real_escape_string($texto, $link);
$query = "INSERT INTO editorial (nombre) VALUES ('{$textoSeguro}')";
mysql_query($query, $link);
```
##### Configurar Codificación de Caracteres
Antes de cualquier `mysql_query`, invoca `mysql_set_charset('utf8', $link)` para asegurar que PHP y MySQL hablan el mismo idioma. Si no lo haces, MySQL puede re-convertir cada cadena generando sobrecarga.

> Analogía: Imagínate hablando español con alguien que solo entiende inglés; cada frase debe traducirse al vuelo, ralentizando la conversación. Si ambos hablan el mismo idioma, fluye de inmediato.

---
### Ejemplos Prácticos
##### Minimizar Carga en Tablas Grandes
Escenario: Tabla `logs` con 10 millones de filas. Quieres procesar solo 100 filas a la vez.
```php
<?php

$link = mysql_connect('localhost', 'user', 'pass');
mysql_select_db('db', $link);
mysql_set_charset('utf8', $link);

$offset = 0;
$limit = 100;

while (true) {
	$sql = "SELECT id, mensaje FROM logs ORDER BY id LIMIT {$offset}, ${limit}";
	$res = mysql_query($sql, $link);

	if (mysql_num_rows($res) === 0) {
		mysql_free_result($res);
		break; // Ya no hay filas
	}

	while ($row = mysql_fetch_assoc($res)) {
		// Procesar registro
		echo "[{$row['id']}] {$row['mensaje']}\n";
	}

	mysql_free_result($res);
	$offset += $limit;
}
```
El uso de `LIMIT ... OFFSET` y `mysql_free_result` evita cargar 10 millones de filas de una sola vez en memoria.
##### Extracción Masiva con Consulta No Bufferizada
Escenario: Exportar la tabla `reportes` a CSV sin saturar la memoria.
```php
<?php

$link = mysql_connect('localhost', 'user', 'pass');
mysql_select_db('mi_base', $link);
mysql_set_charset('utf8', $link);

header('Content-Type: text/csv');
header('Content-Disposition: attachment; filename="reportes.csv"');
echo "id,fecha,valor\n";

$res = mysql_unbuffered_query("SELECT id, fecha, valor FROM reportes", $link);

while ($row = mysql_fetch_assoc($res)) {
    // Escapar valores para CSV
    $line = implode(',', [
        $row['id'],
        '"' . str_replace('"', '""', $row['fecha']) . '"',
        $row['valor']
    ]);
    echo $line . "\n";
}

mysql_free_result($res);
```
`mysql_unbuffered_query` asegura que PHP no intente guardar todo el `dataset` en memoria, procesándolo fila a fila.
##### Conexiones Persistentes en Entorno de Alta Concurrencia
Escenario: Sitio con decenas de solicitudes por segundo, cada script requiere conexión a BD.
```php
<?php

$link = mysql_pconnect('localhost', 'user', 'pass');
if (!$link) {
    die('No se pudo conectar: ' . mysql_error());
}
mysql_select_db('db', $link);
mysql_set_charset('utf8', $link);

// Consulta normal
$res = mysql_query("SELECT id, nombre, precio FROM productos WHERE stock > 0", $link);
while ($p = mysql_fetch_assoc($res)) {
	echo "{$p['nombre']} - {$p['precio']}\n";
}
mysql_free_result($res);
```
Gracias a `mysql_pconnect`, el servidor MySQL no ve abrirse y cerrarse conexiones constantemente, reduciendo latencia.
##### Evitar Bloqueo de Consultas "`SLOW`"
Escenario: Identificas que `mysql_query` tarda demasiado en una consulta compleja.
Solución:
1. Revisar índices en la tabla
2. Reescribir la consulta con `JOIN` o subconsultas más eficientes/
3. Si la consulta es "inolvidable" y no cambia a menudo, crear una tabla de resumen (`materialized view`) que se actualice nocturnamente y consultarla en lugar de la tabla original.
```sql
--- Índice compuesto
CREATE INDEX idx_usuario_fecha ON transacciones(usuario_id, fecha);

-- Consulta optimizada
SELECT t.usuario_id, SUM(t.valor)
FROM transacciones t
WHERE t.fecha BETWEEN '2023-01-01' AND '2023-01-31'
GROUP BY t.usuario_id;
```
Aquí, el índice en `(usuario_id, fecha)` acelera la búsqueda de rango de fechas con agrupamiento.

---
