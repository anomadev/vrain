La programación orientada a objetos (OOP) en PHP permite estructurar el código creando clases (plantillas) y objetos (instancias), fomentando la reutilización, mantenibilidad y modularidad. Una clase define propiedades (datos) y métodos (funciones) ([[11.3 Properties and Methods]]) que describen el comportamiento y estado de los objetos derivados de ella. PHP soporta cinco niveles de visibilidad ([[11.4 Access Specifiers]]) (`public`, `protected`, `private`, `static`, `cost`), así como herencia ([[11.6 Inheritance]]), interfaces ([[11.9 Interfaces]]), `traits` ([[11.10 Traits]]) y espacios de nombres ([[11.11 Namespaces]]) para organizar proyectos grandes. Aprender estos conceptos es esencial para diseñar sistemas limpios y escalables, especialmente al interactuar con bases de datos (repositorios que devuelven objetos, modelos Active Record, etc.).

---
### Definición
- Clase: Plantilla o molde que define un tipo de objeto mediante propiedades (variables) y métodos (funciones). Ejemplo: `class Usuario { ... }`.
- Objeto: instancia concreta de una clase. Cuando haces `$u = new Usuario();`, crear un objeto con el comportamiento y atributos definidos en la clase `Usuario`.
- Propiedades: Variables declaradas dentro de la clase que representan el estado del objeto, p. ej. `$this->nombre`.
- Métodos ([[11.3 Properties and Methods]]): Funciones definidas dentro de la clase que actúan sobre las propiedades o realizan acciones p. ej. `public function guadar() { ... }`.
- Visibilidad ([[11.4 Access Specifiers]]): Controla el acceso a propiedades y métodos:
	- `public`: accesible desde cualquier parte
	- `protected`: accesible solo dentro de la clase y sus subclases
	- `private`: accesible solo dentro de la propia clase
- Herencia ([[11.6 Inheritance]]): Una subclase extiende a otra (clase padre) y hereda sus propiedades y métodos. Se usa `extends`.
- Constructores y destructores ([[11.2 Constructor and Destructor]]):
	- `__construct`: método especial que se ejecuta al crear el objeto para inicializar propiedades.
	- `__destruct()`: se ejecuta al destruir el objeto (liberar recursos).
- `Static` y `const` ([[11.5 Static Methods and Properties]])
	- `static`: Propiedades o métodos asociados a la clase en sí (no a instancias)
	- `const`: Constantes de clase de valor inmutable
- Interfaces ([[11.9 Interfaces]]): Contratos que definen métodos que una clase debe implementar, sin proveer su cuerpo.
- `Traits` ([[11.10 Traits]]): Bloques de código reutilizables que una o más clases pueden "incluir" para compartir funcionalidades sin herencia directa.
- `Namespaces` ([[11.11 Namespaces]]): Permiten agrupar clases, interfaces y funciones bajo un prefijo (espacio de nombres) para evitar colisiones y organizar el código.

---
### Conceptos Clave
##### Clase y Objeto como Analogía
> **Analogía de plano y casa**:
> Clase es como los planos de una casa (dibujo técnico): define cuántos cuartos, puertas, ventanas y cómo se conectan.
> Objeto es la casa construida según esos planos: cada casa (objeto) puede tener colores o muebles distintos (valores de propiedades), pero siguen la misma estructura.
##### Propiedades y Métodos
- Propiedades: variables propias del objeto. p. ej. un `Usuario` podría tener `$nombre`, `$email`, `$edad`.
- Métodos: funciones que describen el comportamiento, p. ej. `login()`, `guardar()`, `actualizarEmail($nuevoEmail)`.
```php
<?php

class Usuario {
	public $nombre;
	protected $email;
	private $contrasena;

	public function __construct($nombre, $mail, $contrasena) {
		$this->nombre = $nombre;
		$this->email = $email;
		$this->contrasena = password_hash($contrasena, PASSWORD_DEFAULT);
	}

	public function guardar(PDO $pdo) {
		$stmt = $pdo->prepare("INSERT INTO usuarios (nombre, email, password) VALUES (?, ?, ?)");
		$stmt->execute([$this->nombre, $this->email, $this->contrasena]);
	}

	public function actualizarEmail($nuevoEmail) {
		$this->email = $nuevoEmail;
	}

	public function validarEmail($nuevoEmail) {
		return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
	}
}
```
- Aquí, `Usuario` define tres propiedades con visibilidad distinta, un constructor para inicializar y métodos que interactúan con base de datos.
##### Visibilidad: `public`, `protected`, `private`
- `public` cualquier parte del código, incluso fuera de la clase, puede acceder:
```php
$u = new Usuario(...);
echo $u->nombre; // accesible
$u->nombre = "Ana"; // modificable
```
- `protected`: solo la clase y sus subclases pueden acceder. Útil para implementar lógica interna que no debe verse desde afuera.
- `private`: Solo la propia clase puede usar la propiedad o método. Se usa para detalles internos (encapsulación).
##### Herencia
```php
// Extender una clase:
class UsuarioAdmin extends Usuario {
	public function borrarUsuario($idUsuario) {
		// Lógica de administrador
	}
}
```
La subclase `UsuarioAdmin` hereda `nombre`, `email`, `contrasena` y los métodos de `Usuario`, y agrega su propia funcionalidad.

---
### Ejemplos Prácticos
##### Modelo de Conexión a Base de Datos
```php
class Database {
	private static $instancia = null;
	private $pdo;

	private function __construct() {
		$dsn = 'mysql:host=localhost;dbname=miapp;charset=utf8mb4';
		$this->pdo = new PDO($dsn, 'user', 'pass', [
			PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION
		]);
	}

	// Patrón Singleton para reutilizar la misma conexión
	public static function getInstancia(): self {
		if (self::$instancia === null) {
			self::$instancia = new self();
		}
		return self::$instancia;
	}

	public function getPdo(): PDO {
		return $this->pdo;
	}
}
```
Solo existe una instancia de `Database`, se una en toda la aplicación, evitando múltiples conexiones.
##### Repositorio de Usuarios
```php
interface UsuarioRepositorio {
	public function findById(int $id): ?Usuario;
	public function findAll(): array;
	public function save(Usuario $usuario): bool;
}

class MySqlUsuarioRepositorio implements UsuarioRepositorio {
	private $pdo;

	public function __construct(PDO $pdo) {
		$this->pdo = $pdo;
	}

	public function findById(int $id): ?Usuario {
		$stmt = $this->pdo->prepare("SELECT * FROM usuarios WHERE id = ?");
		$stmt->execute([$id]);
		$fila = $stmt->fetch(PDO::FETCH_ASSOC);
		if ($fila) {
			return new Usuario($fila['nombre'], $fila['email'], '');
		}
		return null;
	}

	public function findAll(): array {
		$stmt = $this->pdo->query("SELECT * FROM usuarios");
		$usuarios = [];
		while ($fila = $stmt->fetch(PDO::FETCH_ASSOC)) {
			$usuarios[] = new Usuario($fila['nombre'], $fila['email'], '');
		}
		return $usuarios;
	}
	
	public function save(Usuario $usuario): bool {
		return $usuario->guardar($this->pdo);
	}
}
```
Este repositorio aísla la lógica de consultas SQL, exponiendo métodos orientados a objetos (`findById`, `findAll`, `save`).
##### `Trait` para `Logger`
```php
trait Logger {
	public function log(string $mensaje): void {
		error_log(date('Y-m-d H:i:s') . " - " . $mensaje . PHP_EOL, 3, __DIR__ . '/app/log');
	}
}

class ServicioUsuarios {
	use Logger;

	public function crear(array $datos) {
		// Lógica de creación
		$this->log("Usuario creado: " . $datos['email']);
	}
}
```
Reutilizas `log()` en varias clases sin duplicar código.

---
## Notas

- Usar `traits` para extender funcionalidades sin engrosar jerarquías de herencia.
- En aplicaciones con bases de datos, crear repositorios como clases que usan PDO ([[10.1 PDO]]) y MySQLi ([[10.2 MySQLi]]) para aislar la lógica SQL, liberando el controlador de detalles de persistencia.
- Al usar inversión de control, inyectar la instancia de conexión `Database::getInstance()` en los servicios, facilitando pruebas y cambiando la capa de datos in reescribir lógica de negocio.
