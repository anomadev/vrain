Los `traits` en PHP son un mecanismo para reutilizar código en múltiples clases ([[11.1 Classes and Objects]]) sin recurrir a herencia múltiple ([[11.6 Inheritance]]). Actúan como "módulos" de funcionalidades que puedes "inyectar" en cualquier clase mediante la palabra clave `use`. Con `traits` evitas duplicar métodos comunes (por ejemplo, registros de `logs`, validaciones, serialización), y a la vez mantienes jerarquías de clase limpias. Al usar `traits` puedes insertar comportamiento en clases que ya extienden otras, superando la limitación de herencia simple de PHP. Sin embargo, si no se emplean con cuidado, pueden generar colisiones de nombres y acoplamientos ocultos.

--- 
### Definiciones
`Trait`: Un fragmento de código reutilizable que agrupa métodos (y propiedades, aunque recomendablemente solo métodos) y que se inserta dentro de una o varias clases mediante `use TraitName`;
```php
# uso básico
trait LoggerTrait {
	public function log(string $message): void {
		echo "[Log] $message\n";
	}
}

class ServiceA {
	use LoggerTrait;
}

class ServiceB {
	use LoggerTrait;
}
```
Tanto `ServiceA` como `ServiceB` heredan `log()` sin heredar de una superclase común.
**Conflictos de Nombres**: Si dos `traits` definen métodos con el mismo nombre, o si una clase define un método idéntico, se resuelve con las palabras clave `insteadof` y `as`.

---
### Conceptos Clave
##### Reutilización sin Herencia Múltiple
- Los `traits` permiten incluir métodos en cualquier clase sin heredar de un ancestro común.
- Evita duplicar lógica cuando varias clases distintas requieren la misma funcionalidad.

> **Analogía**: Imagina los `traits` como módulos de LEGO que contienen piezas específicas (métodos). Cada clase (construcción) puede "adjuntar" ese módulo para tener esas funciones sin cambiar su estructura base.
##### Sintaxis y Declaración
```php
trait Timestamplable {
	public function createAt(): string {
		return $this->created_at ?? date('Y-m-d H:i:s');
	}

	public function setCreatedAt(string $time): void {
		$this->created_at = $time;
	}
}

class Post {
	use Timestampable;

	private string $created_at;
	// ... otros métodos
}

class Comment {
	use Timestampable;

	private string $create_at;
	// ... otros métodos
}
```
Ambos `Post` y `Comment` heredan `createdAt()` y `setCreatedAt()` sin necesidad de heredar de una clase `Timestampable`.
##### Múltiples `Traits` y Resolución de Conflictos
Al usar varios `traits`, puede haber métodos ([[11.3 Properties and Methods]]) con el mismo nombre. PHP obliga a resolver el conflicto:
```php
trait Serializer {
	public function serialize(): string {
		return json_encode($this);
	}
}

trait XmlSerializer {
	public function serialize(): string {
		// lógica para XML
		return '<object>...</object>'
	}
}

class Product {
	use Serializer, XmlSelializer {
		XmlSerializer::serialize insteadof Serializer;
		Serializer::serialize as seraalizeJson;
	}
}

// Uso:
$p = new Product();
echo $p->serialize();

// Para JSON
echo $p->serializeJson();
```
- Con `insteadof` eliges qué implementación aplicar si hay colisión.
- Con `as` puedes renombrar para dejar acceso a ambas versiones.
##### Propiedades en `Traits`
Aunque los `traits` pueden declarar propiedades, es recomendable limitarlos a métodos para evitar sorpresas de colisiones en propiedades:
```php
trait Identifiable {
	private string $id;

	public function getId(): string {
		return $this->id;
	}

	public function setId(string $id): void {
		$this->id = $id;
	}
}

class User {
	use Identifiable;
	// ...
}
```
Si dos `traits` usan la misma propiedad `$id`, causará error. Se debe renombrar una o resolver conflicto manualmente.
##### Mejores prácticas
- Cohesión: Un `trait` debe agrupar métodos relacionados (p. ej. `ValidationTrait`, `LoggingTrait`, `NotificationTrait`).
- Evitar estado oculto: No declares propiedades en `traits` salvo que sea necesario; así reduces colisiones y haces el `trait` más predecible.
- Resolver conflictos explícitamente: Cuando varios `traits` aportan el mismo método, usa `insteadof` y `as` para aclarar la intención.

---
### Ejemplos Prácticos
##### `Logging` reutilizable en múltiples servicios
```php
<?php

trait LoggerTrait {
    public function log(string $level, string $message): void {
        $timestamp = date('Y-m-d H:i:s');
        echo "[$timestamp] [$level] $message\n";
    }
}

class UserService {
    use LoggerTrait;

    public function createUser(string $name): void {
        // Lógica para crear usuario
        $this->log('INFO', "User '$name' created.");
    }
}

class OrderService {
    use LoggerTrait;

    public function createOrder(int $orderId): void {
        // Lógica para crear orden
        $this->log('INFO', "Order '$orderId' created.");
    }
}

// Uso:
$userService  = new UserService();
$orderService = new OrderService();

$userService->createUser('Alice');   
// [2025-06-01 09:00:00] [INFO] User 'Alice' created.
$orderService->createOrder(123);     
// [2025-06-01 09:00:01] [INFO] Order '123' created.
```
`LoggerTrait` aporta `log()`, reutilizable en cualquier clase sin depender de una jerarquía común.
##### Validaciones comunes en entidades
```php
trait ValidationTrait {
    public function validateEmail(string $email): bool {
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }

    public function validateNotEmpty(array $data): bool {
        foreach ($data as $key => $value) {
            if (empty($value)) {
                return false;
            }
        }
        return true;
    }
}

class RegistrationForm {
    use ValidationTrait;

    public function submit(array $data): void {
        if (!$this->validateNotEmpty($data)) {
            echo "All fields are required.\n";
            return;
        }
        if (!$this->validateEmail($data['email'])) {
            echo "Invalid email.\n";
            return;
        }
        // Continuar lógica de registro
        echo "Registration successful.\n";
    }
}

class ContactForm {
    use ValidationTrait;

    public function send(array $data): void {
        if (!$this->validateNotEmpty($data)) {
            echo "Please fill all fields.\n";
            return;
        }
        if (!$this->validateEmail($data['email'])) {
            echo "Email is not valid.\n";
            return;
        }
        // Enviar mensaje
        echo "Message sent.\n";
    }
}

// Uso:
$regForm = new RegistrationForm();
$regForm->submit(['name'=>'Bob','email'=>'bob@example.com']);

$contactForm = new ContactForm();
$contactForm->send(['name'=>'', 'email'=>'bademail']); 
```
`ValidationTrait` agrupa validaciones comunes (`validateEmail`, `validateNotEmpty`) para diferentes formularios.
##### Serialización de modelos con conflicto de métodos
```php
trait JsonSerializeTrait {
    public function serialize(): string {
        return json_encode($this->toArray());
    }
}

trait XmlSerializeTrait {
    public function serialize(): string {
        // Simplificado para ejemplo
        $elements = '';
        foreach ($this->toArray() as $key => $value) {
            $elements .= "<$key>$value</$key>";
        }
        return "<object>$elements</object>";
    }
}

class Product {
    use JsonSerializeTrait, XmlSerializeTrait {
        JsonSerializeTrait::serialize insteadof XmlSerializeTrait;
        XmlSerializeTrait::serialize as toXml;
    }

    private int $id;
    private string $name;
    private float $price;

    public function __construct(int $id, string $name, float $price) {
        $this->id    = $id;
        $this->name  = $name;
        $this->price = $price;
    }

    public function toArray(): array {
        return [
            'id'    => $this->id,
            'name'  => $this->name,
            'price' => $this->price,
        ];
    }
}

// Uso:
$product = new Product(1, 'Shirt', 29.99);
echo $product->serialize(); // JSON
echo $product->toXml();     // XML
```
Se resuelve el conflicto `serialize()` usando `insteadof` para JSON y `as` para exponer XML como `toXml()`.

---
## Notas

- Ver los `traits` como módulos de funcionalidad (p. ej. `Logging`, `Validation`, `Serialization`) que puede "inyectar" en cualquier clase, sin alterar la jerarquía de herencia.
- Evitar copiar y pegar métodos repetitivos; en su lugar, colocar ese comportamiento en un `trait` bien nombrado (`LoggerTrait`, `ValidationTrait`) y lo incluyo donde haga falta.