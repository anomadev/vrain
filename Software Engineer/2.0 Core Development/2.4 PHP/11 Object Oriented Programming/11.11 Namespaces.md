Los `namespaces` en PHP permiten organizar y aislar el código agrupándolo en espacios de nombres separados, evitando colisiones entre clases ([[11.1 Classes and Objects]]), funciones ([[6.0 Functions]]) y constantes ([[2.6 Constants]]) con nombres idénticos. Al usar `namespaces`, es posible tener dos clases `User` en contextos distintos, por ejemplo, `App\Models\User` y `App\Controllers\User` sin conflicto. Esto es especialmente relevante en proyectos grandes o cuando se integran librerías externas. Además, los `namespaces` facilitan el `autoloading` y la lectura de código, ya que reflejan la estructura de carpetas en el sistema de archivos. Con `use` y alias (`as`), se pueden referir a clases largas con nombres cortos, haciendo el código más limpio.

---
### Definición
Un `namespace` es un contenedor lógico para agrupar clases, interfaces, funciones y constantes, definido al principio de un archivo PHP con la sintaxis:
```php
namespace App\Models;
```
Todo elemento declarado bajo ese `namespace` adquiere un FQN (`Fully Qualified Name`) como `App\Models\User`.
Para usar elementos de otro `namespace` dentro de un mismo archivo, se emplea:
```php
use App\Service\EmailService;

# o con Alias:
use App\Service\EmailService as Mailer;
```

---
### Conceptos Clave
##### Declarar un `namespace`
```php
<?php

namespace App\Models;

class User {
	// ...
}
```
- El archivo asocia la clase `User` con el `namespace`: `App\Models`.
- Internamente, la FQN de esta clase es `\App\Models\User`.
##### Estructura de carpetas y PSR-4
Convención PSR-4 ([[18.1 PHP Framework Interoperability Group]]): mapea `namespaces` a rutas de carpetas:
```bash
src/
	Models/
		User.php              # namespace App\Models
	Controllers/
		UserController.php    # namespace App\Controllers
```
Un `autoloader` (`Composer`) cargará automáticamente `App\Models\User` desde `src/Models/User.php`.
##### Usar `use` para importar `namespaces`
Para instanciar una clase con `namespace` sin escribir el FQN completo cada vez:
```php
namespace App\Controllers;

use App\Models\User;
use App\Services\NotificationService as Notifier;

class UserController {
    public function register(array $data): void {
        $user = new User($data);
        $notifier = new Notifier();
        $notifier->sendWelcome($user);
    }
}
```
- `use App\Models\User;` importa la clase para referirse como `User`.
- `as Notifier` renombra `App\Services\NotificationService` a `Notifier`.
##### Espacio de nombres globales (`\`)
Cuando llamas a una función o clase sin `namespace` dentro de `namespace`, PHP primero busca en el `namespace` actual. Para forzar la búsqueda en el espacio global, se antepone una barra invertida:
```php
namespace App\Utils;

class Helper {
    public function now(): string {
        return \date('Y-m-d H:i:s'); // Llama a date() global
    }
}
```
De lo contrario, `date()` buscaría `App\Utils\date`, que no existe.
##### Agrupación de importaciones (PHP 7+)
Se pueden importar múltiples clases desde el mismo `namespace` con una sintaxis agrupada:
```php
<?php
namespace App\Controllers;

use App\Models\{User, Product, Order};
use App\Services\{EmailService as Mailer, SmsService};

```
##### `Sub-namespaces`
Los `namespaces` pueden anidarse:
```php
namespace App\Repositories\Database;
class UserRepository { /* ... */ }
```
La estructura de carpetas suele reflejar esta jerarquía
```bash
src/
	Repositories/
		Database/
			UserRepository.php # namespace App\Repositories\Database
```

---
### Ejemplos Prácticos
##### Evitar colisiones de clases
`src/Models/User.php`
```php
namespace App\Models;

class User {
    public function __construct(private string $name) {}

    public function getName(): string {
        return $this->name;
    }
}
```
`src/Controllers/UserController.php`
```php
<?php
namespace App\Controllers;

use App\Models\User;

class UserController {
    public function show(): void {
        $user = new User('Alice');
        echo "Hello, " . $user->getName();
    }
}

```
`src/Admin/User.php`
```php
<?php
namespace App\Admin;

class User {
    public function getRole(): string {
        return 'admin';
    }
}

```
`public/index.php`
```php
<?php
require __DIR__ . '/../vendor/autoload.php';

use App\Controllers\UserController;
use App\Admin\User as AdminUser;

$ctrl = new UserController();
$ctrl->show(); // Hello, Alice

$admin = new AdminUser();
echo $admin->getRole(); // admin

```
- Dos clases `User` existen en `namespaces` distintos: `App\Model\User` y `App\Admin\User`.
- `as AdminUser` evita colisión en `index.php`
##### Funciones y constantes en `namespaces`
`src/Utils/Helpers.php`
```php
<?php
namespace App\Utils;

function formatDate(string $date): string {
    return \date('d-m-Y', strtotime($date));
}

const VERSION = '1.0.0';

```
`src/SomeService.php`
```php
<?php
namespace App\Services;

use function App\Utils\formatDate;
use const App\Utils\VERSION;

class SomeService {
    public function info(): void {
        echo "App version: " . VERSION . "\n";
        echo "Today is: " . formatDate('now') . "\n";
    }
}

```
- `use function` y `use const` importan funciones/constantes de otro `namespace`.
##### Agrupar importaciones
```php
<?php
namespace App\Controllers;

use App\Models\{User, Product, Order};
use App\Services\{EmailService as Mailer, SmsService};

class DashboardController {
    public function dashboard(): void {
        $user = new User('Bob');
        $product = new Product('Shirt', 25);
        $order = new Order($user, $product);
        
        $mailer = new Mailer();
        $mailer->send("Welcome, " . $user->getName());

        $sms = new SmsService();
        $sms->send($user->getName() . ", your order is confirmed.");
    }
}

```
- Notación compacta para importar múltiples clases de un mismo `namespace`

---
### Analogías para interiorizar
- Carpetas del sistema de archivos: Los `namespaces` funcionan como carpetas en un disco. Puedes tener un archivo `User.php` en `src/Models` y otro `User.php` en `src/Controllers/`; no habrá conflicto, porque cada uno reside en una ruta distinta.
- Direcciones de correo electrónico: Dos personas pueden llamarse "John Smith" si viven en ciudades diferentes; su `namespace` sería la ciudad `john@newyork.com` versus `john@london.co.uk`.
- Directorios de módulos: Piensa en un gran almacén donde cada departamento (Electrónica, Ropa, Alimentos) tiene su propia sección. Cada departamento puede tener un producto llamado "Laptop" o "Camisa", pero al anteponer el departamento (`namespace`) distingues claramente: `Electronics\Laptop` vs `Clothing\Shirt`.

---
## Notas
- Configurar `Composer` con PSR-4 para que al hacer `composer dump-autoload` las clases se carguen automáticamente sin `require` manual.
- Usar alias (`as`) para importar clases cuando hay colisiones de nombres o cuando quiera un nombre más corto en el archivo.
