Los métodos mágicos en PHP son funciones especiales que comienzan con `__` y PHP invoca automáticamente en ciertos eventos del ciclo de vida de un objeto o cuando se interactúa con propiedades/métodos inexistentes. Por ejemplo `__construct()` ([[11.2 Constructor and Destructor]]) inicializa objetos, `__get()` y `__set()` gestionan accesos a propiedades inaccesibles, y `__call()` atrapa llamadas a métodos que no existen. Estos métodos permiten agregar comportamientos dinámicos, como `proxies`, validaciones automáticas o serialización personalizada, sin romper la sintaxis normal del lenguaje. Sin embargo, abusar de ellos puede dificultar la lectura y el `debugging`, por lo que se recomienda usarlos con moderación y sólo cuando realmente añadan valor.

---
### Definiciones Principales
1. `__construct()`: Llamado automáticamente al crear una instancia de la clase. Suele usarse para inicializar propiedades, inyectar dependencias o abrir conexiones.
2. `__destruct()`: Ejecutado cuando el objeto se destruye (al salir del script o al hacer `unset()`). Ideal para cerrar recursos (archivos, conexiones) o finalizar transacciones pendientes.
3. `__get($name)`: Invocado al leer una propiedad inaccesible (privada/protegida o inexistente). Permite, por ejemplo, implementar "propiedades virtuales" o cargar datos perezosamente.
4. `__set($name, $value)`: Llamado al asignar valor a una propiedad inaccesible o inexistente. Útil para validar o transformar valores antes de almacenarlos o guardarlos en un arreglo interno.
5. `__isset($name)` y `__unset($name)`
	- `__isset()`: Invocado al usar `__isset($obj->prop)` en una propiedad inaccesible.
	- `__unset()`: Invocado al hacer `__unset($obj->prop)` sobre una propiedad inaccesible.
6. `__call($method, $args)`: Se dispara al invocar un método que no existe o no es accesible (por visibilidad). Permite implementar "métodos mágicos" o `proxies`, redirigiendo la llamada de forma dinámica.
7. `__callStatic($method, $args)`: Similar a `__call()`, pero para métodos estáticos inexistentes.
8. `__toString()`: Devuelve una representación en cadena cuando el objeto se trate como `string`, p. ej. `echo $obj;`.
9. `__invoke($args...)`: Llamado al usar un objeto como función, p. ej. `$obj($param)`.
10. `__sleep()` y `__wakeup()`
	- `__sleep()`: Invocado antes de serializar un objeto (`serialize()`), retorna un `array` de propiedades a incluir.
	- `__wakeup()`: Llamado tras unserializar (`unserialize()`), puede reabrir conexiones o reconfigurar el estado.
11. `__serialize()` y `__unserialize()` (PHP 7.4+): Reemplazo moderno de `__sleep()`/`wakeup()`. Permite controlar exactamente cómo serializar y deserializar datos.
12. `__clone()`: Ejecutado al clonar un objeto con `clone $obj`. Permite, por ejemplo, clonar recursos internos o resetear identificadores.
13. `__debugInfo()` (PHP 5.6+): Proporciona un `array` personalizado para mostrar en `var_dump()` o `debug`.

---
### Conceptos Clave
##### Inicialización y limpieza: `__construct` y `__destruct`
- `__construct()` garantiza que el objeto siempre se crea en un estado válido (p. ej. conexión a base de datos, configuración básica).
- `__destruct()` libera recursos antes de que el `script` termine o antes de que se destruya la instancia (cierre de archivos, `commits`/`rollbacks`, etc.).

> Analogía: Piensa en `__construct()` como encender un coche: chequeas los niveles, arrancas el motor y dejas todo listo. Y en `__destruct()` como apagar el coche: armas el freno de mano, apagas luces y detienes el motor para que no queme combustible innecesario.

```php
class DatabaseConnection {
    private PDO $pdo;

    public function __construct(string $dsn, string $user, string $pass) {
        $this->pdo = new PDO($dsn, $user, $pass, [PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION]);
    }

    public function getPdo(): PDO {
        return $this->pdo;
    }

    public function __destruct() {
        // Cierra conexión al destruir el objeto
        $this->pdo = null;
        echo "Connection closed.\n";
    }
}

// Uso:
$conn = new DatabaseConnection('mysql:host=localhost;dbname=app', 'user', 'pass');
// Al final del script o al hacer unset($conn), se cierra la conexión.
```
##### Propiedades dinámicas: `__get()`, `__set()`, `__isset()`, `__unset()`
Se usan para implementar propiedades virtuales, persistencia en arreglos internos o validaciones de acceso.

> Analogía: Imagina una taquilla con cerradura. Si una persona intenta leer o escribir en un casillero que no existe o está bloqueado, la taquilla (`__get`/`__set`) decide si da la clave, lanza error o almacena el objeto en un espacio separado.

```php
class DynamicProperties {
    private array $data = [];

    public function __get(string $name) {
        // Devuelve valor si existe en $data, sino null
        return $this->data[$name] ?? null;
    }

    public function __set(string $name, $value) {
        // Almacena en $data
        $this->data[$name] = $value;
    }

    public function __isset(string $name): bool {
        return isset($this->data[$name]);
    }

    public function __unset(string $name) {
        unset($this->data[$name]);
    }
}

// Uso:
$obj = new DynamicProperties();
$obj->foo = 'bar';             // Llama __set('foo','bar')
echo $obj->foo;                // Llama __get('foo') → 'bar'
echo isset($obj->baz);         // Llama __isset('baz') → false
unset($obj->foo);              // Llama __unset('foo')

```
##### Métodos mágicos: `__call()` y `__callStatic()`
- Se dispara cuando se invoca un método inexistente o inaccesible.
- Permiten crear `proxies`, delegadores o APIs fluidas sin definir cada método manualmente.

> Analogía: Piensa en un asistente que recibe solicitudes (llamadas a métodos). Si el ejecutivo (clase) no reconoce esa solicitud (`__call()`) decide a quién derivarla o cómo manejarla.

```php
class ApiClient {
    public function __call(string $method, array $args) {
        // Imagina que mapea llamadas a endpoints REST
        $endpoint = strtolower($method);
        $params   = $args[0] ?? [];
        return $this->request($endpoint, $params);
    }

    private function request(string $endpoint, array $params) {
        // Lógica para enviar HTTP request a /api/{endpoint} con $params
        return "Request to /api/{$endpoint} with " . json_encode($params);
    }
}

// Uso:
$api = new ApiClient();
echo $api->getUser(['id' => 5]);  // Llama __call('getUser', [['id'=>5]])
// Imprime: Request to /api/getuser with {"id":5}
```

```php
class StaticProxy {
    public static function __callStatic(string $method, array $args) {
        return "Called static method {$method} with " . json_encode($args);
    }
}

// Uso:
echo StaticProxy::foo(1, 2, 3);  // Llama __callStatic('foo',[1,2,3])
```
##### Representaciones: `__toString()` y `__invoke()`
- `__toString()`: Permite que un objeto se convierta a `string` al hacer `echo` o concatenando.
- `__invoke()`: Hace que un objeto sea "invocable" como si fuera una función, p. ej. `$obj($param)`.
```php
class Person {
    public function __construct(private string $name, private int $age) {}

    public function __toString(): string {
        return "{$this->name}, age {$this->age}";
    }
}

class Greeter {
    public function __invoke(string $name): string {
        return "Hello, {$name}!";
    }
}

// Uso:
$person = new Person('Alice', 30);
echo $person;  // "Alice, age 30"

$greeter = new Greeter();
echo $greeter('Bob');  // Llama __invoke('Bob') → "Hello, Bob!"
```
##### Serialización y clonación: `__sleep()`, `__wakeup()`, `__serialize()`, `__unserialize()`, `__clone()`
- `__sleep()`: Antes de `serialize()`, retorna un array con nombres de propiedades que se serializarán.
- `__wakeup()`: Tras `unserialize()`, reconstituye estado (p. ej. reabrir conexiones).
- `__serialize()`/`__unserialize()`: API moderna (PHP 7.4+) para controlar la serialización de manera más versátil.
- `__clone()`: Llamado al clonar un objeto (`$new = clone $old`), permite clonar correctamente recursos internos.
```php
class SessionData {
    private $conn;
    public array $data;

    public function __construct(PDO $pdo) {
        $this->conn = $pdo;
        $this->data = [];
    }

    public function __sleep(): array {
        // Sólo serializa $data, no la conexión
        return ['data'];
    }

    public function __wakeup(): void {
        // Reestablece la conexión (debe existir $pdo global o similar)
        global $pdo;
        $this->conn = $pdo;
    }
}

class Config {
    private array $settings;

    public function __construct() {
        $this->settings = ['env' => 'prod'];
    }

    public function __serialize(): array {
        // Incluye todo en un array
        return ['settings' => $this->settings];
    }

    public function __unserialize(array $data): void {
        $this->settings = $data['settings'];
    }
}

class ResourceHolder {
    public $resource;

    public function __construct($r) {
        $this->resource = $r;
    }

    public function __clone() {
        // Por ejemplo, abrir una copia del recurso
        $this->resource = clone $this->resource;
    }
}
```
##### Debugging: `__debugInfo()`
- Permite personalizar la información que muestra `var_dump($obj)`
- Retorna un array de datos que quieres exponer durante el debugging.
```php
class Product {
    private int $id;
    private string $name;
    private float $price;
    private string $internalCode; // No exponer

    public function __construct(int $id, string $name, float $price, string $code) {
        $this->id           = $id;
        $this->name         = $name;
        $this->price        = $price;
        $this->internalCode = $code;
    }

    public function __debugInfo(): array {
        return [
            'id'    => $this->id,
            'name'  => $this->name,
            'price' => $this->price,
            // Ocultar internalCode
        ];
    }
}

// Uso:
$product = new Product(1, 'Shirt', 19.99, 'X123');
var_dump($product);
// Muestra solo id, name y price, no internalCode.
```

---
### Analogías para interiorizar
1. **`__get()`/`__set()` como una taquilla dinámica**: Piensa en un objeto con comportamientos (propiedades). Si alguien pide acceso a un casillero que no existe, el portero (`__get`) decide si crear uno nuevo o devolver `null`. Si alguien coloca algo en un casillero inexistente, el portero (`__set`) crea ese casillero y guarda el valor.
2. **`__call()` como asistente telefónico**: Cuando llamas a un número (método), el asistente (representa `__call()`) escucha el nombre solicitado. si el ejecutivo (método) no está disponible, el asistente redirige la llamada a la persona correcta o anuncia que no existe.
3. **`__toString()` como carnet de identidad**: Un objeto es como una persona y `__toString()` es su tarjeta de presentación. Si pides que se muestre, el objeto entrega cómo quiere "ser visto" en texto, sin obligar al consumidor a indagar en propiedades internas.
4. **`__invoke()` como caja registradora**: Un objeto con `__invoke()` se comporta como si fuera un botón de "Procesar Pago". Al "presionar" el objeto como función (`$checkout()`), ejecuta la lógica de cobro sin que el usuario llame a un método específico.

