La inyección de dependencias (DI) en PHP es un patrón que separa la creación de objetos de su uso, permitiendo que las dependencias (servicios, repositorios, configuraciones) se provean a las clases desde afuera, en lugar de que las mismas clases las instancien internamente. Al delegar la construcción de objetos a un **contenedor de dependencias** (por ejemplo, PHP-DI), se logra un código más modular, testable y desacoplado. En lugar de tener en cada clase líneas como `$this->db = new PDO(...)`, se inyecta `PDO` ([[10.1 PDO]]) en el constructor ([[11.2 Constructor and Destructor]]) o mediante métodos ([[11.3 Properties and Methods]]), promoviendo el Principio de Inversión de Dependencias de SOLID. 

---
### Definiciones Principales
- **Dependencia**: Cualquier objeto, clase o servicio que una clase necesita para funcionar (por ejemplo, un repositorio, un adaptador de base de datos, un cliente HTTP).
- **Inyección de Dependencias (DI)**: Patrón que consiste en proveer dichas dependencias desde afuera de la clase, generalmente a través del constructor, métodos `setters` o propiedades públicas.
- **Contenedor de Dependencias (`Dependency Injection Container`, `DIC`)**: Biblioteca o `framework` (como PHP-DI) que resuelve y gestiona el ciclo de vida de las dependencias, inyectándolas automáticamente según la configuración o anotaciones.
- **Principio de Inversión de Dependencias (D de SOLID)**: Las clases de alto nivel no deberían depender de clases de bajo nivel; ambas deberían depender de abstracciones (interfaces).

---
### Conceptos Clave
##### Inyección vía Constructor
```php
<?php
class UserService {
    private PDO $pdo;

    // Inyectamos PDO en el constructor
    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    public function getUserById(int $id): array {
        $stmt = $this->pdo->prepare('SELECT * FROM users WHERE id = ?');
        $stmt->execute([$id]);
        return $stmt->fetch();
    }
}
```
La clase no crea el objeto `PDO`, Lo recibe como parámetro: así se puede sustituir por un `mock` en pruebas.
##### Inyección vía `Setter` (`Set Injection`)
```php
<?php
class ReportGenerator {
    private LoggerInterface $logger;

    public function setLogger(LoggerInterface $logger): void {
        $this->logger = $logger;
    }

    public function generate(): void {
        // ...
        $this->logger->log('Report generated.');
    }
}

// Uso:
$reporter = new ReportGenerator();
$reporter->setLogger(new FileLogger('/var/log/report.log'));
$reporter->generate();
```
Permite inyectar la dependencia luego de instanciar el objeto, a través de un método público.
##### Inyección vía propiedad (`Property Injection`)
```php
<?php
class EmailSender {
    public MailerInterface $mailer; // public property inyectada

    public function sendWelcome(string $email): void {
        $this->mailer->send($email, 'Welcome!', 'Thanks for joining!');
    }
}

// Configurado por un contenedor DI:
$emailSender = new EmailSender();
$emailSender->mailer = new SmtpMailer('smtp.example.com');
```
Menos común debido a visibilidad pública, pero útil en `frameworks` que inyectan directamente.
##### Ventajas de DI
- **Testabilidad**: puedo pasar `mocks` o `stubs` en pruebas unitarias, aislando lógica interna.
- **Desacoplamiento**: La clase no depende de implementaciones concretas, sino de abstracciones (interfaces [[11.9 Interfaces]]).
- **Configuración**: Centralizar la configuración de dependencias en un contenedor evita repetir `new` en toda la app.
- **Reemplazo fácil de implementaciones**: Cambiar `PDO` ([[10.1 PDO]]) por `MySQLi` ([[10.2 MySQLi]]) o un repositorio en memoria sin modificar la clase consumidora.
##### Contenedor de Dependencias (PHP-DI)
- Se crea un `container builder`, se configura mapeos interface -> implementación o definiciones explícitas.
- El contenedor resuelve la inyección automática al instanciar objetos ([[11.1 Classes and Objects]]):
```php
<?php
use DI\ContainerBuilder;

require 'vendor/autoload.php';

$builder = new ContainerBuilder();
$builder->addDefinitions([
    PDO::class => function() {
        return new PDO('mysql:host=localhost;dbname=app', 'user', 'pass');
    },
    LoggerInterface::class => DI\autowire(FileLogger::class)
                         ->constructor('/var/log/app.log'),
]);
$container = $builder->build();

// El contenedor inyecta automáticamente PDO y FileLogger
$userService = $container->get(UserService::class);
$reporter    = $container->get(ReportGenerator::class);
```
`autowire()` permite interferir constructor y parámetros sin configurarlos explícitamente.

---
### Ejemplos Prácticos
##### Servicios de Notificaciones con DI
```php
<?php
interface NotificationServiceInterface {
    public function notify(string $recipient, string $message): void;
}

class EmailNotificationService implements NotificationServiceInterface {
    private MailerInterface $mailer;

    public function __construct(MailerInterface $mailer) {
        $this->mailer = $mailer;
    }

    public function notify(string $recipient, string $message): void {
        $this->mailer->send($recipient, 'Notification', $message);
    }
}

class SmsNotificationService implements NotificationServiceInterface {
    private SmsGatewayInterface $smsGateway;

    public function __construct(SmsGatewayInterface $smsGateway) {
        $this->smsGateway = $smsGateway;
    }

    public function notify(string $recipient, string $message): void {
        $this->smsGateway->send($recipient, $message);
    }
}

class OrderService {
    private NotificationServiceInterface $notifier;

    public function __construct(NotificationServiceInterface $notifier) {
        $this->notifier = $notifier;
    }

    public function placeOrder(int $userId): void {
        // Lógica de orden...
        $this->notifier->notify('user@example.com', 'Your order has been placed.');
    }
}

// Configuración manual (sin contenedor):
$mailer = new SmtpMailer('smtp.example.com');
$emailNotifier = new EmailNotificationService($mailer);

$orderService = new OrderService($emailNotifier);
$orderService->placeOrder(42);

```
`OrderService`: no sabe si la notificación es por email o SMS; el cliente decide qué implementación inyectar.
##### Repositorio y Controlador con PHP-DI
```php
<?php
use DI\ContainerBuilder;
use Psr\Container\ContainerInterface;

class UserRepository {
    private PDO $pdo;

    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    public function findAll(): array {
        return $this->pdo->query('SELECT * FROM users')->fetchAll();
    }
}

class UserController {
    private UserRepository $userRepo;

    public function __construct(UserRepository $userRepo) {
        $this->userRepo = $userRepo;
    }

    public function index(): void {
        $users = $this->userRepo->findAll();
        foreach ($users as $user) {
            echo $user['name'] . PHP_EOL;
        }
    }
}

// Configuración PHP-DI:
require 'vendor/autoload.php';

$builder = new ContainerBuilder();
$builder->addDefinitions([
    PDO::class => function () {
        return new PDO('mysql:host=localhost;dbname=app', 'user', 'pass');
    }
]);
$container = $builder->build();

// PHP-DI inyecta PDO en UserRepository, y UserRepository en UserController
$controller = $container->get(UserController::class);
$controller->index();
```
Sin instanciar manualmente `PDO` o `UserRepository`, el contenedor resuelve toda la cadena de dependencias.

---
### Analogías
- **Restaurante y Chefs especializados**: Un chef (clase) necesita ingredientes (dependencias) para preparar un plato (método). En lugar de ir él mismo al almacén (instanciar `new Ingredient()`), alguien (contenedor DI) le entrega los ingredientes ya listos en su mesa (`constructor`), permitiendo que el chef se concentre en cocinar.
- **Constructor de muebles y herramientas**: Un montador de muebles (clase) requiere varias herramientas: un taladro, un martillo y destornillador. En lugar de que el montador cargue todo en su bolsillo (instanciar internamente), el jefe de obra (contenedor) le provee esas herramientas según el trabajo que deba hacer. Así, si cambia a un modelo de taladro más eficiente, sólo se actualiza el proveedor de herramientas, sin cambiar el montador.
- **Biblioteca de plugins de software**: Un core del sistema (clase principal) define puntos de extensión (interfaces). Los plugins (implementaciones) se registran en el contenedor. El sistema no conoce detalles de cada plugin; pide algo que implemente `PluginInterface`, y el contenedor le devuelve el plugin que corresponda.

---
## Notas
- Diseñar clases para depender de **interfaces** (`MailerInterface`, `UserRepositoryInterface`) en lugar de implementaciones concretas (`SmtpMailer`, `MySqlUserRepository`), facilitando la sustitución y el testing.
- Cuando un constructor recibe muchas dependencias (más de 3 o 4), considera refactorizar: tal vez algunas dependencias pueden agruparse en un servicio más cohesivo o usar un patrón **facade**.