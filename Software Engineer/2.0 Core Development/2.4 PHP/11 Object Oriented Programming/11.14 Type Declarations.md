> [!info] Type Declarations (Roadmap SH)
> Las declaraciones de tipo, también conocidas como sugerencias de tipo, son una característica de PHP que proporciona opciones para especificar el tipo de variable que se espera que reciba una función o el tipo de valor que debe devolver. No solo ayuda a depurar el código rápidamente, sino que también lo hace más legible. En PHP, las declaraciones de tipo pueden ser tanto para parámetros de una función (declaraciones de tipo de parámetro) como para valores de retorno de una función (declaraciones de tipo de retorno). Se pueden aplicar a clases, interfaces, tipos invocables y escalares (`int`, `float`, `string`, `bool`).

Las `Type Declarations` en PHP permiten especificar qué tipo de dato deben recibir los parámetros de una función o método, así como qué tipo deben devolver. A partir de PHP 7, esto ayuda a detectar errores antes y a documentar mejor el código. Con `declare(strict_types=1)` al inicio de un archivo, PHP exige que los valores coincidan exactamente con los tipos declarados ([[2.3 Data Types]]), evitando conversiones implícitas. En última instancia, clarifica la intención de cada función, hace el código más confiable y facilita la detección temprana de `bugs`.

### Contenido Clave
##### Sintaxis básica
```php
# Parámetros
function doSomething(int $a, string $b) { ... }

# Retorno
function getSum(int $x, int $y): int {
	return $x + $y;
}
```
##### Tipos permitidos
- Escalares: `int`, `float`, `string`, `bool`
- Compuestos: `array`, `object`, `callable`, `iterable`
- Clases/Interfaces: cualquier nombre de clase o interfaz válida
- Nulos (`nullable`): anteponiendo `?`, p. ej. `?string` acepta `string` o `null`
- `mixed` (PHP 8.0+): acepta cualquier tipo
- `Self`/`parent`/`static`: referirse al tipo de clase actual o padre en métodos estáticos.
##### `strict_types` (modo estricto)
```php
# Por defecto: convierte tipos débilmente
function add(int $a, int $b): int { return $a + $b; }
echo add("2", "3"); // devuelve 5
```
Con `declare(strict_types=1);` exige coincidencias exacta (`TypeError` si pasas `string` en vez de `int`).
##### Declarar tipos en propiedades (7.4+)
```php
class User {
	public int $id;
	private string $name;
	protected ?string $email; // nullable
}
```
### Beneficios principales
- Detección temprana de errores de tipo (`TypeError` en lugar de bugs difíciles)
- Documentación implícita: queda claro qué espera cada función
- Mejor autocompletado en `IDEs` y menos ambigüedad
- Facilita pruebas unitarias, al saber exactamente qué tipo se debe `mockear`
### Analogías 
- **Ropa con tallas**: Si una camiseta es talla M (`string "M"`), no cabe en un pantalón talla M (`int M`); declara tipos es como etiquetar la penda con "solo para camiseta talla M", evitando que alguien meta un pantalón donde no corresponda.
- Encajar piezas de LEGO: Cada pieza (función) tiene huecos de formas específicas (`type hints`). Si intentas conectar una pieza circular (`string`) en un hueco cuadrado (`int`), no encaja y sabes que algo está mal.
### Ejemplos Prácticos
##### Cálculo de precios con tipo estricto
```php
<?php
declare(strict_types=1);

function calculateTotal(float $price, int $quantity): float {
    return $price * $quantity;
}

echo calculateTotal(10.5, 3);  // 31.5
// echo calculateTotal("10.5", "3"); // TypeError en modo estricto
?>

```
En entornos de facturación, evitarás multiplicar `strings` (`"10.5"`) y acabar con valores incorrectos.
##### Inyección de dependencias tipada
```php
<?php
declare(strict_types=1);

class Database {
    private PDO $pdo;

    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    public function query(string $sql): array {
        $stmt = $this->pdo->query($sql);
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

class UserService {
    private Database $db;

    public function __construct(Database $db) {
        $this->db = $db;
    }

    public function getUsers(): array {
        return $this->db->query('SELECT * FROM users');
    }
}

// Al configurar el container o manualmente:
$pdo = new PDO('mysql:host=localhost;dbname=app','user','pass');
$db  = new Database($pdo);
$svc = new UserService($db);
$users = $svc->getUsers(); // siempre recibes array, no null ni string
?>

```
Garantiza que `UserService` siempre tenga un objeto `Database` válido, evitando errores en tiempo de ejecución.
##### Propiedad `nullable` y método que devuelve `null`
```php
<?php
declare(strict_types=1);

class Profile {
    private ?string $bio; // puede ser string o null

    public function __construct(?string $bio = null) {
        $this->bio = $bio;
    }

    public function getBio(): ?string {
        return $this->bio;
    }
}

$profile1 = new Profile("Hello, I am John");
// $profile1->getBio() siempre string
$profile2 = new Profile();
// $profile2->getBio() devuelve null
?>

```
En un formulario opcional de biografía, quien no lo complete obtendrá `null` en lugar de `string` vacío.
## Notas
- Usar `declare(strict_types=1)` en la mayoría de controladores y clases de servicio para detectar errores de tipo de inmediato.
- Al método público ([[11.3 Properties and Methods]]), especificar el tipo de parámetros y retorno para que otros desarrolladores («y yo mismo en el futuro») sepan exactamente qué entregar y recibir.
- En funciones con parámetros opcionales, usar `?Type` en lugar de verificar manualmente si es nulo dentro.