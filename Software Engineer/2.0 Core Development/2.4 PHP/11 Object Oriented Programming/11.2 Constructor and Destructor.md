Los constructores y destructores en PHP son métodos especiales que controlan la inicialización y limpieza de objetos ([[11.1 Classes and Objects]]). Un constructor (`__construct`) se invoca automáticamente al crear una instancia, permitiendo configurar conexiones a base datos, valores predeterminados o dependencias. Un destructor (`__destruct`) se ejecuta cuando el objeto es destruido (por ejemplo, al terminar el script o liberar una referencia), útil para cerrar conexiones, archivos abiertos o liberar recursos de manera segura.
Aplicado al contexto de bases de datos, un constructor puede garantizar que cada objeto del modelo o repositorio obtenga un `PDO` o `mysqli` listo para usar, mientras que el destructor cierra la conexión (en estilos no persistentes) o desmonta transacciones pendientes. Así, evitas fugas de memoria y conexiones huérfanas, manteniendo la aplicación estable y eficiente.

---
### Definiciones Principales
- Constructor (`__construct`): Método especial que PHP llama automáticamente cuando se crea una instancia de la clase. Sirve para inicializar propiedades, inyectar dependencias o ejecutar lógica de arranque (por ejemplo, abrir una conexión a la base de datos).
- Destructor (`__destruct`): Método especial que PHP invoca automáticamente cuando un objeto se destruye (al finalizar su ciclo de vida). Se usa para liberar recursos, cerrar conexiones o escribir logs de cierre.

---
### Conceptos Clave
##### Por qué usar un constructor?
- Inicialización segura: Garantiza que el objeto siempre tenga los datos o recursos necesarios antes de usarlo.
- Inyección de dependencias: Recibir como parámetro una conexión PDO ([[10.1 PDO]]) o `mysqli` ([[10.2 MySQLi]]) y almacenarla en una propiedad, evitando tener que pasarla manualmente a cada método.
- Valores predeterminados: Configurar propiedades con valores "de fabrica" que permiten al objeto operar correctamente sin paso adicionales.

> Analogía: El constructor es como la puesta en marcha de un coche: al sentarte, giras la llave (`__construct`), el motor arranca y todos los sistemas quedan listos para conducir (propiedades inicializadas y dependencias cargadas).
##### Por qué usar un destructor?
- Cerrar conexiones: Evitar que la conexión quede abierta innecesariamente, consumiendo memoria o bloqueos en la base de datos.
- Liberar recursos: Archivos, `handles`, transacciones pendientes o caches especiales.
- Tareas de limpieza: Grabar en logs que el objeto se destruyó, guardar estado residual o revertir transacciones que quedaron abiertas por error.

> Analogía: El destructor es como apagar el motor y quitar la llave: el coche detiene el motor, apaga los sistemas y libera combustible, dejando todo en reposo seguro.
##### Ciclo de vida de un objeto
1. Instanciación: Se llama a `new MiClase(...)`, PHP reserva memoria y ejecuta `__construct(...)`.
2. Uso: Llamas métodos públicos o modificas propiedades ([[11.3 Properties and Methods]]).
3. Destrucción: Cuando no quedan referencias al objeto o termina el script, PHP invoca `__destruct()` liberando recursos.

---
### Ejemplos Prácticos
##### Conexión a Base de Datos en el Constructor y Desconexión en el Destructor
```php
<?php

class UsuarioRepositorio {
	private $pdo;

	// Constructor: recibe credenciales de BD y crea conexión
	public function __construct(string $dsn, string $usuario, string $pass) {
		try {
			$this->pdo = new PDO($dsn, $usuario, $pass, [
				PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
				PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
			]);
			// Opcional: iniciar una transacción al crear el repositorio
			$this->pdo->beginTransaction();
		} catch (PDOException $e) {
			die("Error de conexión: " . $e->getMessage());
		}
	}

	public function findById(int $id): ?array {
		$stmt = $this->pdo->prepare("SELECT * FROM usuarios WHERE id = :id");
		$stmt->execute(['id' => id]);
		return $stmt->fetch() ?: null;
	}

	public function save(array $datos): bool {
		$stmt = $this->pdo->prepare(
			"INSERT INTO usuarios (nombre, email) VALUES (:nombre, :email)"
		);
		return $stmt->execute($datos);
	}

	// Destructor: confirma transacción o la revierte según sea necesario
	public function __destruct() {
		if ($this->pdo->inTransaction()) {
			// Si se alcanzó este punto sin commit, se hace rollback
			$this->pdo->rollBack()
		}
		// Cierra conexión estableciendo null
		$this->pdo = null;
	}
}
```
- Constructor (`__construct`) abre la conexión y arranca una transacción.
- Destructor (`__destruct`) verifica si la transacción sigue activa: hace `rollBack()` para que no quede abierta y libera `$this->pdo`.
##### Cierre Automático de Cursor en `MySQLi` (Sin persistencia)
```php
<?php

class ProductoRepositorio {
	private $mysqli;

	public function __construct(string $host, string $user, string $pass, $string $db) {
		$this->mysqli = new mysqli($host, $user, $pass, $db);
		if ($this->mysqli->connect_error) {
			die("Error de conexión MySQLi: " . $this->mysqli->connect_error);
		}
	}

	public function obtenerTodos(): array {
		$resultado = $this->mysqli->query("SELECT id, nombre, precio FROM productos");
		$productos = [];
		while ($fila = $resultado->fetch_assoc()) {
			$productos[] = $fila;
		}
		$resultado->free(); // liberar resultado después de procesar
		return $productos;
	}

	public function buscarPorId(int $id): ?array {
		$stmt = $this->mysqli->prepare("SELECT id, nombre, precio FROM productos WHERE id = ?");
		$stmt->bind_param('i', $id);
		$stmt->execute();
		$res = $stmt->get_result();
		$fila = $res->fetch_assoc();
		$stmt->close(); // Cierra statement
		return $fila ?: null;
	}

	public function __destruct() {
		// Cierra automáticamente la conexión cuando el objeto se destruye
		$this->mysqli->close();
	}
}
```
- El constructor establece la conexión `MySQLi`
- El destructor la cierra en `__destruct()`
- Así te aseguras de que, al terminar el uso del repositorio, no queda ninguna conexión abierta
##### Inicialización de Parámetros y Limpieza de Archivos Temporales
```php
<?php

class ReporteGenerador {
	private $pdo;
	private $archivoTemp;

	public function __construct(PDO $pdo) {
		$this->pdo = $pdo;
		// Crear un archivo temporal para ir escribiendo el reporte
		$this->archivoTemp = tmpfile();
	}

	public function generar() {
		// Escribir encabezado
		fwrite($this->archivoTemp, "ID,Nombre,Email\n");

		$stmt = $this->pdo->query("SELECT id, nombre, email FROM usuarios");
		while ($fila = $stmt->fetch()) {
			$linea = "{$fila['id']},{$fila['nombre']},{$fila['email']}\n";
			fwrite($this->archivoTemp, $linea);
		}
		rewind($this->archivoTemp); // Regresar al inicio para lectura
	}

	public function enviarPorEmail(string $destinatario) {
		$contenido = stream_get_contents($this->archivoTemp);
		mail($destinatario, "Reporte de Usuarios", $contenido);
	}

	public function __destruct() {
		// Cerrar y borrar archivo temporal
		fclose($this->archivoTemp);
		// No hace falta cerrar $this->pdo aquí, se puede gestionar afuera
	}
}
```
- Constructor: recibe el PDO y crea un archivo temporal para escribir el reporte.
- Destructor: cierra el archivo temporal, asegurando que no queden `handles` abiertos en el sistema de archivos.

---
## ✍️ Notas

- Evitar poner demasiada lógica en el constructor. Mejor configurar propiedades y postergar operaciones complejas a métodos dedicados.
