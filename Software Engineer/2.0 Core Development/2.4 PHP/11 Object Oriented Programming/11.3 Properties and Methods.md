En PHP, las propiedades y métodos son los bloques fundamentales para definir el comportamiento y el estado de una clase ([[11.1 Classes and Objects]]). Una propiedad es una variable interna de la clase que almacena datos (por ejemplo, una conexión a la base de datos o información de usuario), mientras que un método es una función asociada a la clase que opera sobre esas propiedades (por ejemplo, guardar un registro o realiza una consulta). Con las visibilidades (`public`, `protected`, `private`, `static`) ([[11.4 Access Specifiers]]), PHP permite controlar quién puede acceder o modificar cada propiedad o quién puede invocar cada método, manteniendo un alto nivel de encapsulación.
Para desarrolladores de cualquier nivel, comprender cómo declarar, acceder y modificar propiedades, así como definir y llamar métodos, es esencial para estructurar modelos o repositorios en la sección de bases de datos.

---
### Definiciones Principales
- **Propiedad**: Variable declarada dentro de una clase, que representa el "estado" o datos asociados a cada objeto. Se define con una visibilidad (`public`, `protected`, `private`) ([[11.4 Access Specifiers]]) y puede tener un valor predeterminado.
- **Método**: Función ([[6.0 Functions]]) declarada dentro de una clase que define un "comportamiento" o acción que los objetos de esa clase pueden ejecutar. También lleva una visibilidad y puede recibir parámetros o retornar valores.
- **Visibilidad** ([[11.4 Access Specifiers]]):
	- `public`: Accesible desde cualquier parte del código (fuera o dentro de la clase)
	- `protected`: Solo accesible desde la propia clases o sus subclase (herencia)
	- `private`: Solo accesible dentro de la misma clase; ni subclases ni código externo pueden verlo
	- `static`: Puede aplicarse a propiedades o métodos para asociarlos a la clase misma, no a instancias, permitiendo accederlos con `ClassName::method()` o `ClassName::$property`

---
### Conceptos Clave
##### Declaración de Propiedades
```php
class Usuario {
	public string $name;                  // Cualquier parte del código
	protected string $email;              // Solo la clase y subclases
	private string $password;             // Solo la propia clase

	public static int $usersCounter = 0;  // Compartida por todos los objetos
}
```
- Usar tipos de datos ([[2.3 Data Types]]) (`string`, `int`, etc.) a partir de PHP 7.4 mejora la seguridad y claridad.
- Una propiedad sin tipo declarado (`public $edad;`) es válida, pero menos segura: puede recibir cualquier valor.
##### Acceso y Modificación de Propiedades
```php
$user = new Usuario();
$user->name = 'María';                // válido porque $name es public

// $user->email = 'maria@email.com'      error: email es protected
// echo $user->password;                 error: password es private

Usuario::$usersCounter++;             // incrementa la propiedad estática
```
- Para acceder a `protected` o `private`, normalmente se usan métodos `getter`/`setter` dentro de la clase o sus subclases.
##### Declaración de Métodos
```php
class Usuario {
	public function __construct(string $name, string $email, string password) {
		$this->name = $name;
		$this->email = $email;
		$this->password = password_hash($password, PASSWORD_DEFAULT);
		self::$usersCounter++;
	}

	public function save(PDO $pdo): bool {
		$stmt = $pdo->prepare(
			"INSERT INTO usuarios (name, email, password) VALUES (:n, :e, :p)"
		);
	
		return $stmt->execute([
			'n' => $this->name,
			'e' => $this->email,
			'p' => $this->password 
		]);
	}

	protected function validateEmail(string email): bool {
		return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
	}

	private function generateToken(): string {
		return bin2hex(random_bytes(16));
	}

	public static function totalUsers(): int {
		return self::$usersCounter;
	}
}
```
- `__construct` es un método especial que se invoca al crear el objeto ([[11.2 Constructor and Destructor]]).
- Un método `public` como `save` puede usarse desde fuera de la clase para persistir datos en la DB.
- Métodos `protected` y `private` suele contener lógica interna (validaciones, generación de tokens) que no debe exponerse directamente.
##### Métodos Estáticos (`static`)
Se asocian a la clase, no a instancias. Útiles para operaciones globales, como contar instancias o ejecutar consultas sin crear un objeto:
```php
class Configuration {
	public static array $values = [];

	public static function load(string $file): void {
		self::$values = parse_ini_file($file);
	}

	public static function get(string $key, $default = null) {
		return self::$values[$key] ?? $default;
	}
}

Configuration::load('config.ini');
echo Configuration::get('db_host', 'localhost');
```
##### Sobrecarga de Propiedades y Métodos Mágicos
PHP permite definir métodos mágicos que actúan cuando se intenta acceder a una propiedad o método inexistente:
```php
class Model {
	private array $data = [];

	public function __get(string $prop) {
		return $this->data[$prop] ?? null;
	}

	public function __set(string $prop, $value) {
		$this->data[$prop] = $value;
	}

	public function __call(string $method, array $args) {
		throw new BadMethodCallException("Método {$method} no existe");
	}
}
```
Estas herramientas permiten implementar repositorios o `DTOs` flexibles, pero pueden reducir claridad si se abusan.

---
### Ejemplos Prácticos
##### Modelo Simple con `Getter` / `Setter`
```php
class Cliente {
    private int    $id;
    private string $nombre;
    private string $email;

    public function __construct(int $id, string $nombre, string $email) {
        $this->id     = $id;
        $this->nombre = $nombre;
        $this->setEmail($email);  // usar setter para validar
    }

    public function getId(): int {
        return $this->id;
    }

    public function getNombre(): string {
        return $this->nombre;
    }

    public function setNombre(string $nombre): void {
        $this->nombre = trim($nombre);
    }

    public function getEmail(): string {
        return $this->email;
    }

    public function setEmail(string $email): void {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException("Email inválido");
        }
        $this->email = strtolower($email);
    }
}
```
Los métodos `get` y `set` controlan acceso a propiedades `private`, aplicando validaciones y formatos.
##### Repositorio con Propiedades y Métodos
```php
class ProductoRepositorio {
    private PDO $pdo;

    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    public function obtenerPorId(int $id): ?Producto {
        $stmt = $this->pdo->prepare("SELECT * FROM productos WHERE id = ?");
        $stmt->execute([$id]);
        $fila = $stmt->fetch(PDO::FETCH_ASSOC);
        if (!$fila) {
            return null;
        }
        return new Producto($fila['id'], $fila['nombre'], $fila['precio']);
    }

    public function guardar(Producto $producto): bool {
        if ($producto->getId() === 0) {
            // insertar
            $stmt = $this->pdo->prepare(
                "INSERT INTO productos (nombre, precio) VALUES (?, ?)"
            );
            $exito = $stmt->execute([$producto->getNombre(), $producto->getPrecio()]);
            if ($exito) {
                $producto->setId((int)$this->pdo->lastInsertId());
            }
            return $exito;
        } else {
            // actualizar
            $stmt = $this->pdo->prepare(
                "UPDATE productos SET nombre = ?, precio = ? WHERE id = ?"
            );
            return $stmt->execute([
                $producto->getNombre(),
                $producto->getPrecio(),
                $producto->getId()
            ]);
        }
    }
}

class Producto {
    private int $id;
    private string $nombre;
    private float $precio;

    public function __construct(int $id = 0, string $nombre = '', float $precio = 0.0) {
        $this->id     = $id;
        $this->nombre = $nombre;
        $this->precio = $precio;
    }

    public function getId(): int {
        return $this->id;
    }
    public function setId(int $id): void {
        $this->id = $id;
    }
    public function getNombre(): string {
        return $this->nombre;
    }
    public function setNombre(string $nombre): void {
        $this->nombre = trim($nombre);
    }
    public function getPrecio(): float {
        return $this->precio;
    }
    public function setPrecio(float $precio): void {
        if ($precio < 0) {
            throw new InvalidArgumentException("Precio no puede ser negativo");
        }
        $this->precio = $precio;
    }
}
```
Las propiedades encapsuladas con métodos `getter` / `setter` y lógica en métodos públicos para insertar o actualizar en la base de datos.
##### Método Estático para `count` de filas
```php
class Categoria {
    public static function contarTotal(PDO $pdo): int {
        return (int)$pdo->query("SELECT COUNT(*) FROM categorias")->fetchColumn();
    }
}

// Uso:
$total = Categoria::contarTotal($pdo);
echo "Hay {$total} categorías registradas.";
```
Un método `static` facilita llamar sin instanciar un objeto `Categoría`, directamente con `Categoria::contarTotal($pdo)`.

