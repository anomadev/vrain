Los `access specifiers` o especificadores de acceso en PHP (*`public`, `protected` y `private`*) controlan quién puede ver o modificar las propiedades y métodos de una clase. Elegir correctamente la visibilidad ayuda a encapsular la lógica interna, reducir errores y facilitar el mantenimiento. A nivel práctico, usar `private` para datos internos, `protected` para que subclases los hereden sin exponerlos globalmente, y `public` para la interfaz de la clase, garantiza que cada parte del código trabaje solo con lo que necesita. 

---
### Definiciones Principales
- `public`: Miembros (propiedades/métodos) accesibles desde cualquier parte del código dentro de la clase, subclases, instancias y código externo.
- `protected`: Miembros accesibles solo dentro de la misma clase y sus subclases. Ni el código externo ni las instancias directas de otras clases pueden acceder a ellos.
- `private`: Miembros accesibles únicamente dentro de la propia clase. Ni siquiera las subclases pueden verlos o modificarlos.
- Herencia ([[11.6 Inheritance]]): Mecanismo por el cual una subclase obtiene las propiedades y métodos de su clase padre, respetando las reglas de visibilidad.

---
### Conceptos Clave
1. **Analogía de la caja de herramientas**:
	Imagina una caja de herramientas en un taller:
	- `public` - Herramientas en el estante abierto, cualquiera que entre en el taller puede tomarlas.
	- `protected` - Herramientas en un armario con llave, pero compartido con los aprendices (subclases), solo quienes saben la combinación (clase padre y subclases) pueden abrirlo, no cualquier visitante.
	- `private` - Herramientas en la caja fuerte del dueño del taller (clase padre), nadie más (ni aprendices ni visitantes) puede acceder.
2. **Encapsulación y Robustez**
	- Encapsular datos con `private` evita que código externo los altere sin pasar por validaciones.
	- `protected` permite flexibilidad en subclases para reutilizar lógica, paro mantiene el dato oculto al entorno global.
	- Solo exponemos al mundo lo necesario con `public`, evitando que otros métodos pasen datos incorrectos o rompan invariantes.
3. **Flujo de Acceso**:

|Visibilidad|Acceso en Clase Padre|Acceso en Subclase|Acceso desde Código Externo|
|---|---|---|---|
|public|✔️|✔️|✔️|
|protected|✔️|✔️|❌|
|private|✔️|❌|❌|

---
### Ejemplos Prácticos
##### Modelo Usuario con Propiedades Encapsuladas
```php
<?php
class Usuario {
    private int $id;
    private string $email;
    protected string $rol;     // Subclases pueden ver/modificar
    public string $nombre;     // Todo el mundo puede leer/escribir

    public function __construct(int $id, string $nombre, string $email, string $rol = 'invitado') {
        $this->id     = $id;
        $this->nombre = $nombre;
        $this->setEmail($email); 
        $this->rol    = $rol;
    }

    public function setEmail(string $email): void {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidArgumentException("Email inválido");
        }
        $this->email = $email;
    }

    public function getEmail(): string {
        return $this->email;
    }

    public function getId(): int {
        return $this->id;
    }
}

// Uso:
$u = new Usuario(1, 'Ana', 'ana@example.com');
echo $u->nombre;          // OK (public)
$u->nombre = 'María';     // OK

// echo $u->email;        // Error: email es private
echo $u->getEmail();      // OK (mediante método público)
```
- `$id` y `$mail` están `private` nadie fuera de `Usuario` puede acceder directamente.
- `$rol` es `$protected` una subclase como `UsuarioAdmin` podría verlo.
- `$nombre` es `public` accesible desde cualquier parte
##### Herencia y Visibilidad
```php
<?php
class Usuario {
    protected string $rol;

    public function __construct(string $rol) {
        $this->rol = $rol;
    }

    protected function obtenerRol(): string {
        return $this->rol;
    }
}

class UsuarioAdmin extends Usuario {
    public function mostrarRol(): string {
        // Puede acceder a la propiedad protected $rol y al método protected obtenerRol()
        return "Rol (" . $this->obtenerRol() . ")";
    }
}

$admin = new UsuarioAdmin('admin');
echo $admin->mostrarRol();   // "Rol (admin)"
// echo $admin->obtenerRol(); // Error: correspondiente a protected
```
- `UsuarioAdmin` hereda `protected` `$rol` y `protected` `obtenerRol()`
- Código externo no puede llamar `obtenerRol()` ni leer `$rol` directamente
##### Métodos Privados y Herencia
```php
<?php
class BaseDeDatos {
    private function conectar(): PDO {
        // Lógica de conexión interna
        return new PDO('mysql:host=...;dbname=...', 'user', 'pass');
    }

    public function ejecutarConsulta(string $sql): array {
        $pdo = $this->conectar();
        return $pdo->query($sql)->fetchAll(PDO::FETCH_ASSOC);
    }
}

class RepositorioProductos extends BaseDeDatos {
    public function listarActivos(): array {
        // $this->conectar(); // Error: conectar() es private en la clase padre
        return $this->ejecutarConsulta("SELECT * FROM productos WHERE activo = 1");
    }
}

$repo = new RepositorioProductos();
$productos = $repo->listarActivos();
```
- `conectar()` es `private` en `BaseDeDatos`, por lo que ni `RepositorioProductos` ni código externo pueden invocarlo.
- Solo métodos públicos ([[11.3 Properties and Methods]]) de la clase padre (`ejecutarConsulta`) están disponibles para la subclase.
##### Propiedad y Método Estático
```php
<?php
class Estadisticas {
    private static int $conteoConsultas = 0;

    public static function incrementar(): void {
        self::$conteoConsultas++;
    }

    public static function obtenerConteo(): int {
        return self::$conteoConsultas;
    }
}

// Uso en repositorios o controladores:
Estadisticas::incrementar();
Estadisticas::incrementar();
echo Estadisticas::obtenerConteo(); // 2
```
- `$conteoConsultas` es `private static`: solo accesible dentro de la propia clase
- Los métodos `public static` ([[11.5 Static Methods and Properties]]) permiten incrementarlo y leerlo sin instanciar

---
## ✍️ Notas
- Evitar sobreexponer con `public $property`, es preferible usar métodos públicos `getProperty`/`setProperty` donde se pueda validar o formatear.
- Para contadores globales o caches, usar `static` con cuidado, exponiendo solo mediante métodos `public static` o `protected static` para no permitir asignaciones directas desde fuera.
