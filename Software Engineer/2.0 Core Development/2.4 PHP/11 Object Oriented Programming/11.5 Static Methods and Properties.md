Los métodos y propiedades estáticas (`static`) en PHP pertenece a la clase en sí misma, no a instancias concretas. Esto significa que puedes acceder a ellos sin tener que crear un objeto con `new`. Se usan para datos o comportamientos globales dentro de un contexto de aplicación: contadores globales, configuración compartida, utilidades generales o caches de recursos. Al no depender de instancias, mejoran la coherencia de valores que deben ser únicos y accesibles desde cualquier parte del código. Sin embargo, abusar de ellos puede derivar en estado global descontrolado, dificultando pruebas unitarias y promoviendo dependencias ocultas. Por ello, es clave entender cuándo conviene declarar algo como `static` y cómo combinarlo con conceptos de encapsulación y inyección de dependencias para mantener código limpio y testeable.

---
### Definiciones Principales
**Propiedad estática `static`**: Una variable declarada dentro de la clase con el modificador `static`. Sus valores compartido entre todas las instancias y accesible sin instanciar.
```php
class Example {
	public static $counter = 0;
}
```
**Método estático (`static` Method)**: Una función dentro de la clase marcada con `static` que puede invocarse directamente desde la clase, sin crear un objeto ([[11.1 Classes and Objects]]).
```php
class Example {
	public static function greet() {
		echo "Hello!";
	}
}
```
**Acceso a elementos estáticos**:
- Dentro de la propia clase: `self::$property` y `self:method()`.
- Desde fuera de la clase: `ClassName::$property` y `ClassName::method()`.

---
### Conceptos Clave
##### Propiedades Estáticas como Variables Globales Encapsuladas
Una propiedad estática es similar a una variable global ([[8.2 Super Global Variables]]), pero limitada al alcance de la clase. Sirve para llevar un contador o almacenar datos compartidos (por ejemplo, un objeto de configuración) que deben permanecer iguales independientes de cuántos objetos instanciaes:
```php
class Config {
	public static array $settings = [];
}

// Cargar configuración en algún punto del arranque
Config::$settings = ['db_host' => 'localhost', 'db_name' =>  'app'];

// En otro punto del código
echo Config::$settings['db_host'];  // localhost
```
- **Analogía**: Piensa en una propiedad estática como un "tablero de anuncios" en una oficina donde se pega información general (horarios, políticas), accesible para todos sin tener que entrar a un despacho particular.
##### Métodos estáticos como funciones de utilidad
Los métodos estáticos funcionan como funciones ([[6.0 Functions]]) utilitarias que no dependen del estado de un objeto. Se usan para acciones que no requieren datos de la instancia, como validaciones, formateos o generación de valores.
```php
class Validator {
	public static function isEmail(string $email): boll {
		return filter_var($mail, FILTER_VALIDATE_EMAIL) !== false;
	}
}

// Uso de cualquier parte:
if (Validator::isEmail('test@example.com')) {
	echo "Valid!";
}
```
- **Analogía**: Un método estático es como un cajero automático en la calle: no necesitas "entrar" a un banco en específico (instancia) para usar la función; la usas directamente desde la "fachada" de la clase.
##### Ciclo de vida y memoria
1. Inicialización: Las propiedades estáticas se definen y pueden inicializarse con valores literales cuando se carga la clase.
2. Persistencia: Permanecen en memoria mientras el script esté en ejecución.
3. Unicidad: Todas las instancias de la clase (y cualquier otro lugar que haga `ClassName::...`) ven el mismo valor, no copias por objeto.
##### Alcance y Contexto de `self`, `static` y `parent`
- `self::` accede siempre al miembro estático definido en la misma clase donde se escribe la palabra `self`.
- `static::` (`late static binding`) resuelve a la clase que invoca el método en tiempo de ejecución, útil cuando hay herencia.
- `parent::` accede el miembro estático de la clase padre.
```php
class BaseLogger {
	public static function log(string $msg) {
		echo "[Base] $msg";
	}

	public static function callLog() {
		self::log("Hello");    // Siempre llama a BaseLogger::log
		static::log("World");  // late static building
	}
}

class FileLogger extends BaseLogger {
	public static function log(string $msg) {
		echo "[File] $msg";
	}
}

FileLogger::callLog();
// Output:
// [Base] Hello
// [File] World
```
##### Riesgos y Buenas Prácticas
- Estado Global Oculto: Usar ayudas globales estáticas puede llevar a efectos secundarios difíciles de rastrear. Una prueba unitaria que modifica `ClassName::$prop` puede alterar otras pruebas.
- Dificultad en Pruebas Unitarias: Los métodos estáticos no permiten inyección de dependencias, por lo que resulta más difícil "`mockear`" o reemplazar comportamientos en tests.
- Alternativas: A veces conviene usar `Singleton` (una instancia global con métodos no estáticos) o inyectar un servicio en el constructor en lugar de recurrir a propiedades estáticas.

---
### Ejemplo Prácticos
##### Contador de instancias por propiedad estática
```php
class User {
	private static int $count = 0;
	public string $name;

	public function __construct(string $name) {
		$this->name = $name;
		self::$count++;
	}

	public function __destruct() {
		self::$count--;
	}

	public static function getCount(): int {
		return self::$count;
	}
}

// Uso en el ciclo de vida de la aplicación
$user1 = new User("Alice");
$user2 = new User("Bob");
echo User::getCount(); // 2

unset($user1);
echo User::getCount(); // 1
```
- `User::$count` lleva la cuenta de instancias vivas de `User`.
- `__construct` incrementa, `__destruct` decrementa.
##### Pool de conexiones (`Singleton - like`) con propiedad estática
```php
class Database {
	private static ?PDO $connection = null;

	public static function getConnection(): PDO {
		if (self::$connection == null) {
			$dsn = 'mysql:host=localhost;dbname=myapp;charset=utf8mb4'
			self::conection = new PDO($dsnm 'user', 'pass', [
				PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
			]);
		}
		
		return self::$connection;
	} 
}

// En cualquier parte del código: 
$pdo1 = Database::getConnection();
$pdo2 = Database::getConnection();
var_dump($pdo1 == $pdo2); // true, la misma instancia.
```
- `Database::$connection` es `null` al inicio.
- La primera llamada crea el objeto `PDO` ([[10.1 PDO]]) y las siguientes retornan la misma instancia, simulando un pool simple.
##### Método estático para validación o transformación
```php
class StringHelper {
	public static function camelCase(string $text): string {
		$words = explode(' ', strtolower($text));
		$camel = array_shift($words);

		foreach ($words as $word) {
			$camel .= ucfirst($word);
		}

		return $camel;
	}
}

echo StringHelper::camelCase("hello word example");
```
- Un método utilitario que transforma cualquier cadena a `camelCase` sin instanciar `StringHelper`.
##### `Late Static Binding` y Herencia de Métodos Estáticos
```php
class Notification {
	public static function send(string $message) {
		echo "Base send: $message\n";
	}

	public static function notify(string $msg) {
		// Late Static Binding con static::
		// Hace que llame a la subclase si existe un override
		static::send($msg);
	}
}

class EmailNotification extends Notification {
	public static function send(string $message) {
		echo "Email sent: $message\n";
	}
}

Notification::notify("Test1"); // Base send: Test1
EmailNotification::notify("Test2"); // Email sent: Test2
```
- `static::send()` dentro de `notify()` permite que `Email Notification` sobrescriba `send` y `notify` llame a la versión adecuada.

--- 
## Notas

- Crear de preferencia servicios inyectables antes que utilidades puramente estáticas cuando necesite flexibilidad en pruebas unitarias.