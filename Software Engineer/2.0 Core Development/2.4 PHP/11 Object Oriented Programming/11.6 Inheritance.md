La herencia en PHP permite que una clase hija (subclase) extienda a una clase padre (superclase), heredando sus propiedades y métodos ([[11.3 Properties and Methods]]), y a la vez añadiendo o sobreescribiendo comportamientos específicos. Esto promueve la reutilización de código, evita duplicación y facilita la organización lógica de modelos por ejemplo, una clase genérica `User` puede proveer comportamiento común, mientras que `AdminUser` y `CustomerUser` extiende esa lógica con funcionalidades propias. La herencia también hace posible aplicar polimorfismo ([[11.7 Polymorphism]]), donde distintas subclases pueden ser tratadas de forma uniforme mediante referencias al tipo padre. Usada correctamente, mejora la mantenibilidad y escalabilidad del código; sin embargo, un diseño de jerarquías de herencia demasiado profundo o inapropiado puede complicar la comprensión y generar acoplamientos innecesarios.

---
### Definiciones Principales
- Superclase (`Parent Class`): Clase base que define propiedades y métodos comunes.
- Subclase (`Child Class`): Clase que extiende (hereda) de una superclase, recibiendo sus miembros y pudiendo ampliarlos o modificarlos.
- `Extends`: Palabra clave en PHP para declarar herencia: `class Child extends Parent {...}`
- `Overriding`: La subclase redefine (sobreescribe) un método heredado de la superclase.
- Polimorfismo: Capacidad de usar instancias de distintas clases a través de una referencia al tipo de la superclase, ejecutando el comportamiento apropiado según la clase real del objeto.

---
### Conceptos Clave
##### Sintaxis Básica de Herencia
```php
class Animal {
	public function speak(): string {
		return "Some generic sound";
	}
}

class Dog extends Animal {
	// Hereda speak(), pero puede extenderlo o sobreescribirlo
	public function speak: string {
		return "Woof!";
	}
}
```
- `Dog` extiende a `Animal`, por lo que hereda cualquier método o propiedad `public`/`protected` ([[11.4 Access Specifiers]]) de `Animal`.
- Al sobreescribir (`override`) `speak()`, `Dog::speak()` reemplaza el comportamiento de `Animal::speak()`.
##### Acceso a miembros del padre con `parent::`
La subclase puede llamar al comportamiento original de la superclase usando `parent::`
```php
class Bird extends Animal {
	public function speak(): string {
		$baseSound = parent::speak(); // Some generic sound
		return $baseSound . "Tweet!";
	}
}
```
Interpreta la lógica del padre y luego extiende con más funcionalidad.
##### Visibilidad (`public`, `protected`, `private`) y herencia
- `public`: miembros accesibles desde cualquier parte, incluidos padres y subclases.
- `protected`: miembros accesibles dentro de la clase y sus subclases, pero no desde código externo.
- `private`: miembros accesibles solo dentro de la propia clase; no se heredan directamente (aunque sí "existen", no pueden ser invocados ni sobreescritos por la subclase).
```php
class Vehicle {
	protected int $speed = 0;

	private function secretMehod() {
		// Lógica interna, no heredada
	}

	public function accelerate(int $amount): void {
		$this->speed += $amount;
	}
}

class Car extends Vehicle {
	public function showSpeed(): int {
		return $this->speed; // permitido: $speed es protected
	}

	// No puede acceder a secretMethod() ni sobreescribirlo
}
```
##### Polimorfismo y Tipado de Parámetros
Al declarar parámetros o variables del tipo de la superclase, puedes pasar instancias de cualquier subclase:
```php
function makeAnimalSpeak(Animal $a): void {
	echo $a->speak();
}

$dog = new Dog();
$bird = new Bird();
makeAnimalSpeak($dog);  // Woof!
makeAnimalSpeak($bird); // Some generic sound Tweet!
```
`makeAnimalSpeak` funciona con cualquier objeto que extienda `Animal`.
##### Extensiones múltiples y uso de `Interfaces`/`Traits`
PHP no soporta herencia múltiple directa de clases, pero se pueden usar `interfaces` ([[11.9 Interfaces]]) y `traits` ([[11.10 Traits]]) para mezclar funcionalidades:
```php
interface LoggerInterface {
	public function log(string $msg): void;
}

trait TimestampTrait {
	public function timestamp(): string {
		return date('Y-m-d H:i:s');
	}
}

class FileLogger implements LoggerInterface {
	use TimestampTrait;

	public function log(string $msg): void {
		echo "[" . $this->timestamp() . "] $msg";
	}
}
```
- `FileLogger` implementa `LoggerInterface` y usa `TimestampTrait` para heredar el método `timestamp()`.
- Ofrece "herencia horizontal" de comportamiento que complementa la herencia de clases.

---
### Ejemplos prácticos
##### Modelo base y subclases especializadas
```php
<?php

abstract class User {
    protected string $name;
    protected string $email;

    public function __construct(string $name, string $email) {
        $this->name  = $name;
        $this->email = $email;
    }

    public function getName(): string {
        return $this->name;
    }

    public function getEmail(): string {
        return $this->email;
    }

    // Método abstracto obliga a subclases a implementarlo
    abstract public function getRole(): string;
}

class AdminUser extends User {
    public function getRole(): string {
        return "admin";
    }

    public function deleteUser(int $userId): bool {
        // Lógica para eliminar usuario
        return true;
    }
}

class CustomerUser extends User {
    public function getRole(): string {
        return "customer";
    }

    public function placeOrder(array $items): bool {
        // Lógica para procesar pedido
        return true;
    }
}

// Uso:
$admin = new AdminUser("Alice", "alice@example.com");
echo $admin->getRole(); // "admin"

$customer = new CustomerUser("Bob", "bob@example.com");
echo $customer->placeOrder(['item1', 'item2']); // true
```
- `User` es una clase abstracta ([[11.8 Abstract Classes]]) con métodos comunes (`getName`, `getEmail`) y método abstracto `getRole`.
- `AdminUser` y `CustomerUser` extienden `User` y proveen implementaciones específicas para `getRole`.
##### Repositorio base y repositorios concretos
```php
<?php

abstract class BaseRepository {
    protected PDO $pdo;

    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    protected function fetchAll(string $table): array {
        $stmt = $this->pdo->query("SELECT * FROM $table");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }
}

class UserRepository extends BaseRepository {
    public function getAllUsers(): array {
        return $this->fetchAll('users');
    }

    public function getUserById(int $id): ?array {
        $stmt = $this->pdo->prepare("SELECT * FROM users WHERE id = ?");
        $stmt->execute([$id]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }
}

class ProductRepository extends BaseRepository {
    public function getAllProducts(): array {
        return $this->fetchAll('products');
    }

    public function getProductBySku(string $sku): ?array {
        $stmt = $this->pdo->prepare("SELECT * FROM products WHERE sku = ?");
        $stmt->execute([$sku]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }
}

// Uso:
$pdo = new PDO('mysql:host=localhost;dbname=app', 'user', 'pass');
$userRepo    = new UserRepository($pdo);
$productRepo = new ProductRepository($pdo);

$allUsers    = $userRepo->getAllUsers();
$allProducts = $productRepo->getAllProducts();
```
- `BaseRepository` agrupa la lógica común de acceso a la base de datos (`fetchAll`)
- Las subclases especializadas (`UserRepository`, `ProductRepository`) heredan y extienden con métodos específicos
##### `Override` y llamada a `parent::`
```php
<?php

class Logger {
    public function log(string $msg): void {
        echo "[LOG] $msg\n";
    }
}

class FileLogger extends Logger {
    private string $filePath;

    public function __construct(string $filePath) {
        $this->filePath = $filePath;
    }

    public function log(string $msg): void {
        // Llamar primero al comportamiento base
        parent::log($msg);
        // Luego agregar lógica específica de FileLogger
        file_put_contents($this->filePath, "[" . date('Y-m-d H:i:s') . "] $msg\n", FILE_APPEND);
    }
}

// Uso en runtime:
$fl = new FileLogger('/var/log/myapp.log');
$fl->log('Something happened');
// Imprime [LOG] Something happened y escribe en el archivo de log.
```
`FileLogger::log()` sobreescribe `Logger::log()`, pero llama a `parent::log()` para mantener su comportamiento original antes de añadir lógica personalizada.

---
## Notas

- Evitar usar herencia para compartir utilidades generales: usar `traits` ([[11.10 Traits]]) o clases `helper` estáticas en su lugar, manteniendo la jerarquía de dominio limpia y enfocada.
