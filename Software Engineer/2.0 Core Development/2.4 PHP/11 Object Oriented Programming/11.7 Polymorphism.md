El polimorfismo en PHP permite que objetos de diferentes clases que comparten una interfaz ([[11.9 Interfaces]]) o herencia ([[11.6 Inheritance]]) respondan a las mismas llamadas de métodos de manera específica a su tipo real en tiempo de ejecución. En la práctica, esto significa que puedes escribir funciones o clases ([[11.1 Classes and Objects]]) que operen sobre el tipo base (por ejemplo `Animal` o `Shape`) y luego pasar instancias de subclases (`Dog`, `Cat`, `Circle`, `Square`), confiando en que el comportamiento correcto se ejecutará.
Este enfoque reduce la duplicación de código, aumenta la flexibilidad y facilita la ampliación del sistema, por ejemplo, al agregar nuevos tipos de repositorio, controladores o modelos de negocio, no necesitas modificar la lógica que trabaja con la abstracción base. 

---
### Definiciones
- **Polimorfismo**: Capacidad de diferentes objetos de responder a la misma llamada de método según su implementación propia. 
- **Subtipo/Herencia polimórfica**: Cuando una clase hija extiende a una clase padre y sobreescribe métodos, de modo que instancias de la hija pueden usarse donde se espere la clase padre.
- **Polimorfismo basado en interfaces**: Cuando varias clases implementan la misma interfaz ([[11.9 Interfaces]]), garantizando que todas proveen los métodos ([[11.3 Properties and Methods]]) definidos por dicha interfaz, pero con lógica propia.
- **`Late Static Binding` (LSB)**: Mecanismo de PHP que, usando `static::`, permite que métodos estáticos ([[11.5 Static Methods and Properties]]) en jerarquías de herencia ([[11.6 Inheritance]]) se resuelvan según la clase que invoca el método en tiempo de ejecución.

---
### Conceptos Clave
##### Subtipo Polimórfico con Herencia
```php
abstract class Animal {
    abstract public function speak(): string;
}

class Dog extends Animal {
    public function speak(): string {
        return "Woof!";
    }
}

class Cat extends Animal {
    public function speak(): string {
        return "Meow!";
    }
}

function makeAnimalSpeak(Animal $animal) {
    echo $animal->speak() . PHP_EOL;
}

$dog = new Dog();
$cat = new Cat();

makeAnimalSpeak($dog); // Woof!
makeAnimalSpeak($cat); // Meow!
```
`makeAnimalSpeak()` acepta cualquier instancia de `Animal` (o subclase). Aunque el parámetro está tipado como `Animal`, en tiempo de ejecución `Dog::speak()` o `Cat::speak()` según qué objeto se pase.
##### Polimorfismo con Interfaces
```php
interface LoggerInterface {
    public function log(string $message): void;
}

class FileLogger implements LoggerInterface {
    public function log(string $message): void {
        echo "[FileLog] $message\n";
    }
}

class DatabaseLogger implements LoggerInterface {
    public function log(string $message): void {
        echo "[DatabaseLog] $message\n";
    }
}

function processOrder(LoggerInterface $logger) {
    // ... code to process order ...
    $logger->log("Order processed successfully.");
}

$fileLogger = new FileLogger();
$dbLogger   = new DatabaseLogger();

processOrder($fileLogger);   // [FileLog] Order processed successfully.
processOrder($dbLogger);     // [DatabaseLog] Order processed successfully.
```
`processOrder` no sabe ni le importa qué tipo de `logger` es; solo confía en que cumple con `LoggerInterface`.
##### `Late Static Binding`
```php
class BaseReport {
    public static function getTitle(): string {
        return "Base Report";
    }

    public static function generate(): void {
        echo static::getTitle() . "\n"; // Usa LSB para resolver en tiempo de ejecución
    }
}

class SalesReport extends BaseReport {
    public static function getTitle(): string {
        return "Sales Report";
    }
}

class InventoryReport extends BaseReport {
    public static function getTitle(): string {
        return "Inventory Report";
    }
}

BaseReport::generate();      // Base Report
SalesReport::generate();     // Sales Report
InventoryReport::generate(); // Inventory Report
```
Al usar `static::getTitle()`, `generate()` llama al método sobreescrito en la subclase correspondiente no al de la clase padre.
##### Colecciones polimórficas
```php
class ShapeCollection {
    /** @var array<Shape> */
    private array $shapes = [];

    public function addShape(Shape $shape): void {
        $this->shapes[] = $shape;
    }

    public function drawAll(): void {
        foreach ($this->shapes as $shape) {
            echo $shape->draw() . "\n";
        }
    }
}

abstract class Shape {
    abstract public function draw(): string;
}

class Circle extends Shape {
    public function draw(): string {
        return "Drawing a circle";
    }
}

class Square extends Shape {
    public function draw(): string {
        return "Drawing a square";
    }
}

$collection = new ShapeCollection();
$collection->addShape(new Circle());
$collection->addShape(new Square());
$collection->drawAll();
// Outputs:
// Drawing a circle
// Drawing a square
```
`ShapeCollection` trabaja con cualquier subtipo de `Shape`, llamando al método polimórfico `draw()` de cada objeto.

--- 
### Analogías
- Control Remoto y Dispositivos: Un control remoto universal (función que acepta `RemoteControllableInterface`) puede encender o apagar diferentes dispositivos (`TV`, `SoundSystem`, `AirConditioner`) sin saber su implementación interna. Cada clase implementa métodos `turnOn()` y `turnOff()` a su manera.
- Lista de Reproducción Multimedia: Una playlist (clase) puede contener `AudioFile`, `VideoFile` o `PodcastFile`. Todas implementan `PlayableInterface` con `play()`. Cuando invocas `play()` en cada momentos, ejecuta la lógica específica de cada tipo, aun tratándose uniformemente dentro de un bucle.

---
## Notas

- Usar interface cuando no existe una relación natural de herencia --por ejemplo, distintos tipos de logging (`EmailLogger`, `DatabaseLogger`, `FileLogger`) implementan `LoggerInterface`.
- Inyectar dependencias polimórficas (repositorios, loggers) para poder `mokearlas` y aislar el comportamiento de la clase bajo prueba (test).