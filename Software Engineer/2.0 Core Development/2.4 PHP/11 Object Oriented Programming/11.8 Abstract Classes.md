Las clases abstractas en PHP definen un contrato parcial para sus subclases: pueden contener métodos implementados y métodos abstractos (sin cuerpos), obligando a las clases hijas a completarlos. Esto permite compartir lógica común y asegurar que todas las subclases implementen cierta funcionalidad crítica. en un sistema de repositorios, por ejemplo, una clase abstracta `BaseRepository` puede definir métodos de conexión y forzar a cada repositorio concreto (UserRepository, ProductRepository) a implementar `getTableName()` o `hydrateModel()` Al usar clases abstractas evitas duplicar código y mantienes un diseño coherente, garantizando que cada subclase cumpla el "contrato" base. 

--- 
### Definiciones Principales
- **Clase abstracta**: Una clase declarada con la palabra clave `abstract` que no puede instanciarse directamente. Puede incluir.
	- **Métodos implementados**: Con cuerpo y lógica compartida.
	- **Métodos abstractos**: Declarados sin cuerpo, forzando a las subclases a implementarlos.
- **Método abstracto**: Definido en una clase abstracta con la firma `abstract public function methodName(...);` y sin bloque `{}`. Obliga a la subclase a proporcionar la implementación.

---
### Conceptos Clave
##### Sintaxis de Clases Abstractas
```php
abstract class BaseRepository {
    // Propiedad común
    protected PDO $pdo;

    // Constructor común para todas las subclases
    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    // Método implementado: lógica que todas las subclases comparten
    public function findAll(): array {
        $table = $this->getTableName();
        $stmt  = $this->pdo->query("SELECT * FROM {$table}");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    // Método abstracto: cada subclase debe definirlo
    abstract protected function getTableName(): string;

    // Otro método abstracto que obliga a implementar lógica de hidratación
    abstract protected function hydrateModel(array $data);
}
```
- `BaseRepository` no puede instanciarse (`new BaseRepository(...)` lanzaría error)
- Define `findAll()` (implementado) que usa `getTableName()`, pero no conoce la tabla concreta.
- Declara `abstract protected function getTableName(): string;`, por lo que cada subclase debe devolver el nombre de la tabla.
##### Herencia de clases abstractas
```php
class UserRepository extends BaseRepository {
    protected function getTableName(): string {
        return 'users';
    }

    protected function hydrateModel(array $data): User {
        return new User($data['id'], $data['name'], $data['email']);
    }

    public function findById(int $id): ?User {
        $stmt = $this->pdo->prepare("SELECT * FROM " . $this->getTableName() . " WHERE id = ?");
        $stmt->execute([$id]);
        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row ? $this->hydrateModel($row) : null;
    }
}

class ProductRepository extends BaseRepository {
    protected function getTableName(): string {
        return 'products';
    }

    protected function hydrateModel(array $data): Product {
        return new Product($data['id'], $data['name'], $data['price']);
    }

    public function findBySku(string $sku): ?Product {
        $stmt = $this->pdo->prepare("SELECT * FROM " . $this->getTableName() . " WHERE sku = ?");
        $stmt->execute([$sku]);
        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row ? $this->hydrateModel($row) : null;
    }
}
```
- `UserRepository` y `ProductRepository` extienden `BaseRepository`
- Cada una provee su `getTableName()` y `hydrateModel()`, completado el contrato de la clase abstracta.
- Ambas heredan `findAll()` sin duplicar lógica de listado.
##### Ventajas y Buenas Prácticas
- Compartir lógica común: Al implementar métodos comunes (p. ej. `findAll()`, `save()`), evitas replicar consultas y manejo de conexión.
- Forzar consistencia: Los métodos abstractos establecen "contratos" que todas las subclases deben respetar, reduciendo errores por olvidar implementar funcionalidad esencial.
- Diseño orientado a capas: Una capa de modelos o repositorios pueden definirse mediante clases abstractas que luego se concretan en repositorios específicos.
- Limitación de visibilidad: Normalmente los métodos abstractos se declaran `protected` o `public` ([[11.4 Access Specifiers]]) según si deben ser accesibles externamente o solo para la jerarquía.

> **Analogía**: Una clase abstracta es como una manual de recetas que define ingredientes mínimos y pasos generales (métodos abstractos), pero deja al chef (subclase) decidir detalles como la cocción exacta o los condimentos (implementaciones concretas).

##### Instanciación y tipado
- No puedes hacer `new BaseRepository($pdo)` porque es abstracta
- Sí puedes referirte a variables del tipado abstracto para polimorfismo:
```php
function proccessRepository(BaseRepository $repo) {
	$items = $repo->findAll();
}

$userRepo = new UserRepository($pdo);
processRepository($userRepo);
```

---
### Ejemplos Prácticos
##### Controladores dinámicos de entidad
```php
abstract class BaseController {
    protected BaseRepository $repo;

    public function __construct(BaseRepository $repo) {
        $this->repo = $repo;
    }

    public function index(): void {
        $items = $this->repo->findAll();
        view('list_view', ['items' => $items]);
    }

    // Obligatorio para implementaciones específicas
    abstract public function showForm(): void;
}

class UserController extends BaseController {
    public function showForm(): void {
        view('user_form'); // Renderiza formulario de usuario
    }
}

class ProductController extends BaseController {
    public function showForm(): void {
        view('product_form'); // Renderiza formulario de producto
    }
}

// Enrutamiento genérico
$path = $_GET['path'];
if ($path === 'users') {
    $controller = new UserController(new UserRepository($pdo));
} else {
    $controller = new ProductController(new ProductRepository($pdo));
}
$controller->index();
$controller->showForm();
```
- `BaseController` define `index()` genérico que funciona con cualquier repositorio que herede `BaseRepository`.
- Subclases (`UserController`, `ProductController`) implementan `showForm()` de manera específica, cumpliendo la abstracción.
##### Clases de servicio con contrato abstracto
```php
abstract class NotificationService {
    // Método abstracto que cada implementación debe cubrir
    abstract public function send(string $to, string $subject, string $body): bool;

    // Método implementado opcional: formateo común
    public function formatMessage(string $body): string {
        return "[AppNotification] " . $body;
    }
}

class EmailService extends NotificationService {
    public function send(string $to, string $subject, string $body): bool {
        $formatted = $this->formatMessage($body);
        // Simulación de envío de email
        mail($to, $subject, $formatted);
        return true;
    }
}

class SmsService extends NotificationService {
    public function send(string $to, string $subject, string $body): bool {
        $formatted = $this->formatMessage($body);
        // Simulación de envío de SMS
        // smsApi()->send($to, $formatted);
        return true;
    }
}

// Uso:
function notifyUser(NotificationService $service, string $userContact) {
    return $service->send($userContact, "Welcome", "Thanks for registering!");
}

$emailService = new EmailService();
$smsService   = new SmsService();

notifyUser($emailService, "user@example.com");
notifyUser($smsService, "5551234567");
```
- `NotificationService` define un método abstracto `send()` y un método común `formatMessage()`.
- Subclases implementan el envío concreto de email o SMS sin duplicar `formatMessage()`.

---
## Notas

- Cuando un método abstracto se vuelve muy extenso o necesita mucha lógica compartida, considere extraer esa lógica a una clase `helper` o servicio independiente, manteniendo en la clase abstracta solo la firma y lógica ligera.
