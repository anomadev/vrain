Una interfaz en PHP (declarada como `interface`) define un contrato: un conjunto de métodos sin implementación que toda clase que la implemente debe proporcionar. A diferencia de las clases abstractas ([[11.8 Abstract Classes]]), las interfaces no contienen lógica ni propiedades --solo la firma de los métodos-- obligando a las clases concretas a cumplir ese contrato exacto. Esto permite diseñar código desacoplado y flexible: por ejemplo, múltiples clases de repositorios, servicios o loggers pueden implementarse con la misma interfaz, garantizando que puedan usarse indistintamente en funciones o inyectarse en constructores ([[11.2 Constructor and Destructor]]) sin preocuparse por su implementación interna. Las interfaces facilitan el polimorfismo ([[11.7 Polymorphism]]) y promueven el principio de inversión de dependencias (D de SOLID), donde el código cliente depende de la abstracción (interfaz), no de la implementación concreta.

---
### Definición
```php
interface NombreInterface {
	public function metodoA(array $data): bool;
	public function metodoB(string $input): string;
}
```
- Una interfaz solo declara métodos públicos (implícitamente); cada clase que la implemente debe definir esos métodos exactamente con la mismas firma (mismos nombres, parámetros y tipos de retorno).
- No puede contener propiedades ni lógica en los métodos. Solo puede declarar constantes.
- Una interfaz puede extender otra(s) interfaz(es), combinando varios contratos:
```php
interface A {
	public function foo(): void;
}

interface B extends A {
	public function bar(): void;
}
```

```php
# Para implementar
class MyClass implements NombreInterface {
	public function metodoA (array $data): bool { ... }
	public function metodoB (string $input): string { ... }
}
```
Si falla en implementar algún método declarado, PHP lanzará un error fatal.

---
### Conceptos Clave
##### Contrato y desacoplamiento
- Una interfaz actúa como un acuerdo formal: *cualquiera que implemente esta interfaz garantiza que tendrá estos métodos disponibles*.
- El código que usa la interfaz (tipo `hint`) no necesita saber quién es la clase concreta: solo confía en que cumple el contrato.
##### Polimorfismo y sustitución Liskov
Al tipar con una interfaz en lugar de una clase concreta, puedes pasar cualquier implementación sin cambiar la lógica cliente:
```php
function processPayment(PaymentGatewayInterface $gateway) {
	$gateway->charge(100);
}

$stripe = new StripeGateway();
$paypal = new PayPalGateway();

processPayment($tripe);
processPayment($paypal);
```
Ambas clases (`StripeGateway`, `PayPalGateway`) ofrecen `charge()`, aunque su lógica interna difiera.
##### Composición de interfaces y extensión
Una interfaz puede extender varias interfaces:
```php
interface Readable {
	public function read(int $id): array;
}

interface Writeable {
	public function write(array $data): bool;
}

interface CrudRepository extends Readable, Writeable {
	public function delete(int $id): bool;
}
```
Así `CrudRepository` combina todos los métodos de `Readable` y `Writeable` más su propio `delete()`.
##### Declaración de constantes
Aunque no pueden tener propiedades, sí pueden declarar constantes:
```php
interface StatusInterface {
	public const STATUS_ACTIVE = 'active';
	public const STATUS_INACTIVE = 'inactive';
}

class User implements StatusInterface {
	public function getStatus(): string {
		return self::STATUS_ACTIVE;
	}
}
```
Facilita mantener valores inmutables compartidos entre implementaciones.
##### Diferencia con Clases Abstractas
- **Interfaces**: solo firmar métodos públicos y constantes; no permiten lógica ni propiedades; una clase puede implementar múltiples interfaces.
- **Clases abstractas** ([[11.8 Abstract Classes]]): pueden tener lógica en métodos implementados, propiedades, y métodos abstractos; una clase solo puede extender una clase abstracta (herencia simple).

> Analogía: Una interfaz es como un formulario de especificaciones que dice "este electrodoméstico debe tener enchufe A, pantalla digital y modo de espera"; cualquier fabricante puede crear un modelo diferente mientras cumpla esas condiciones.

--- 
### Ejemplos prácticos
##### `LoggerInterface` y múltiples implementaciones
```php
<?php

interface LoggerInterface {
    public function log(string $message): void;
}

class FileLogger implements LoggerInterface {
    private string $filePath;

    public function __construct(string $filePath) {
        $this->filePath = $filePath;
    }

    public function log(string $message): void {
        file_put_contents($this->filePath, $message . PHP_EOL, FILE_APPEND);
    }
}

class DatabaseLogger implements LoggerInterface {
    private PDO $pdo;

    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }

    public function log(string $message): void {
        $stmt = $this->pdo->prepare("INSERT INTO logs (message) VALUES (?)");
        $stmt->execute([$message]);
    }
}

// En alguna parte del sistema:
function processOrder(LoggerInterface $logger) {
    // ... lógica de procesamiento ...
    $logger->log("Order processed at " . date('Y-m-d H:i:s'));
}

$fileLogger = new FileLogger('/var/log/app.log');
$dbLogger   = new DatabaseLogger($pdo);

processOrder($fileLogger);  // usa FileLogger
processOrder($dbLogger);    // usa DatabaseLogger
```
`processOrder` no sabe ni le importa qué `logger` es; simplemente confía en que tiene un `log()`.
##### `CrudRepository` para entidades
```php
<?php

interface CrudRepositoryInterface {
    public function findAll(): array;
    public function findById(int $id): ?array;
    public function save(array $data): bool;
    public function delete(int $id): bool;
}

abstract class BaseRepository {
    protected PDO $pdo;

    public function __construct(PDO $pdo) {
        $this->pdo = $pdo;
    }
}

class UserRepository extends BaseRepository implements CrudRepositoryInterface {
    public function findAll(): array {
        $stmt = $this->pdo->query("SELECT * FROM users");
        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function findById(int $id): ?array {
        $stmt = $this->pdo->prepare("SELECT * FROM users WHERE id = ?");
        $stmt->execute([$id]);
        return $stmt->fetch(PDO::FETCH_ASSOC) ?: null;
    }

    public function save(array $data): bool {
        if (isset($data['id'])) {
            $stmt = $this->pdo->prepare(
                "UPDATE users SET name = ?, email = ? WHERE id = ?"
            );
            return $stmt->execute([$data['name'], $data['email'], $data['id']]);
        } else {
            $stmt = $this->pdo->prepare(
                "INSERT INTO users (name, email) VALUES (?, ?)"
            );
            return $stmt->execute([$data['name'], $data['email']]);
        }
    }

    public function delete(int $id): bool {
        $stmt = $this->pdo->prepare("DELETE FROM users WHERE id = ?");
        return $stmt->execute([$id]);
    }
}

// Uso:
$userRepo = new UserRepository($pdo);
$allUsers = $userRepo->findAll();
$user     = $userRepo->findById(3);
$userRepo->save(['name' => 'Alice', 'email' => 'alice@example.com']);
$userRepo->delete(3);
```
`UserRepository` se compromete a todos los métodos de `CrudRepositoryInterface` facilitando que otras partes de código puedan trabajar con cualquier repositorio que cumple esa interfaz (por ejemplo, `ProductRepository`).
##### Enrutador genérico basado en controladores que implementan una Interfaz
```php
interface ControllerInterface {
    public function index(): void;
    public function show(int $id): void;
    public function create(array $data): void;
    public function update(int $id, array $data): void;
    public function delete(int $id): void;
}

class UserController implements ControllerInterface {
    private UserRepository $repo;

    public function __construct(UserRepository $repo) {
        $this->repo = $repo;
    }

    public function index(): void {
        $users = $this->repo->findAll();
        view('users.index', ['users' => $users]);
    }

    public function show(int $id): void {
        $user = $this->repo->findById($id);
        view('users.show', ['user' => $user]);
    }

    public function create(array $data): void {
        $this->repo->save($data);
        redirect('/users');
    }

    public function update(int $id, array $data): void {
        $data['id'] = $id;
        $this->repo->save($data);
        redirect('/users');
    }

    public function delete(int $id): void {
        $this->repo->delete($id);
        redirect('/users');
    }
}

// Enrutador:
function handleRequest(string $resource, string $action, $id = null, $data = []) {
    // Mapeo ejemplo estático:
    $controllers = [
        'users' => new UserController(new UserRepository($pdo)),
        'products' => new ProductController(new ProductRepository($pdo)),
    ];
    $controller = $controllers[$resource] ?? null;
    if ($controller instanceof ControllerInterface) {
        switch ($action) {
            case 'index':
                $controller->index();
                break;
            case 'show':
                $controller->show((int)$id);
                break;
            case 'create':
                $controller->create($data);
                break;
            case 'update':
                $controller->update((int)$id, $data);
                break;
            case 'delete':
                $controller->delete((int)$id);
                break;
        }
    } else {
        http_response_code(404);
        echo "Not Found";
    }
}
```
`handleRequest` no conoce detalles de cada controlador, solo exige el contrato `ControllerInterface`.

---
## Notas

- Evitar crear interfaces demasiadas grandes; seguir el principio de ISP dividiéndolas en varias interfaces enfocadas en responsabilidades específicas.
- Usar `Traits` ([[11.10 Traits]]) para lógica compartida de interfaces cuando varias clases deban usar el mismo comportamiento, evitando duplicación sin recurrir a herencia múltiple.