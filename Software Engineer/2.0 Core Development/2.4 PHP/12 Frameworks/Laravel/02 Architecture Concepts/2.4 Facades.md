En Laravel, las `Facades` son clases que actúan como "puertas de entrada" estáticas a los servicios registrados en el `Service Container`, permitiendo un acceso limpio y conciso sin instanciar objetos manualmente [Laravel](https://laravel.com/docs/12.x/facades?utm_source=chatgpt.com).
Bajo el capó, cada `Facade` extiende `Illuminate\Support\Facades\Facade` y usa el método `getFacadeAccesor()` para resolver el servicio subyacente desde el contenedor.
Conceptualmente, se basan en el Patrón `Structural Facade`, que simplifica interfaces complejas ofreciendo un punto único de interacción, como el portero de un edificio que conoce a todos los empleados y te conecta con ellos sin que tengas que buscarlos uno a uno [Reddit](https://www.reddit.com/r/laravel/comments/1e5mf36/what_in_the_world_is_a_facade/?utm_source=chatgpt.com).
Además de mejorar la legibilidad, las `Facades` permiten `mockear` servicios fácil y limpiamente en pruebas gracias a métodos como `shouldReceive()` y `spy()` [api.laravel.com](https://api.laravel.com/docs/12.x/Illuminate/Support/Facades.html?utm_source=chatgpt.com).

---
### Definición
Un `Facade` en Laravel es una clase "estática" que delega llamadas a una instancia real de un servicio a través del `Service Container`. Internamente, la clase base `Facade` utiliza la función `__callStatic` para redirigir métodos a la instancia resuelta según la clave devuelta por `getFacadeAccesor()`.

---
### Conceptos Clave
- **Interfaz estática sobre instancias**: Permiten llamar a métodos de servicios como `Cache::get('key')` sin instanciar `CacheManager` manualmente.
- **Patrón `Structural Facade`**: Sirve como "fachada" o fachada de un subsistema complejo, ocultando la complejidad tras una interfaz simplificada.
- **`Accesor` de `Facade` (`getFacadeAccessor`)**: Cada `Facade` define este método protegido que devuelve la clave del `binding` en el contenedor, p. ej. `cache`, `db` o `view`.
- **No magia, solo sintaxis**: Aunque parecen métodos estáticos, no son estáticos; el contenedor resuelve y entrega la instancia real detrás de escena.
- **`Mocking` y `testing`**: Las `Facades` exponen `helpers` como `shouldReceive()`, `spy()` y `partialMock()` para simular comportamientos en pruebas unitarias sin tocar la lógica interna.
- **`Facades` personalizados**: Puedes crear tus propios `Facades` extendiendo la clase base y definiendo el `accesor`, permitiendo un acceso coherente a servicios hechos por ti.

---
### Ejemplos Prácticos
##### `cache` - Guardar y recuperar
```php
// Almacenar un valor
Cache::put('user_count', 100, now()->addMinutes(5));

// Recuperar valor
$count = Cache::get('user_count');
```
Esto traduce a llamar al servicio `cache` en el contenedor sin instanciación manual.
##### `DB` - Consulta limpia
```php
$users = DB::table('users')->where('active', 1)->get();
```
Detrás de `DB` está el `DatabaseManager`, resuelto vía `Facade`, lo que simplifica acceso a la base de datos.
##### Crear una `Facade` personalizada
```php
namespace App\Facades;
use Illuminate\Support\Facades\Facade;

class InfoFacade extends Facade {
	protected static function getFacadeAccesor() {
		return 'info'; // Clave vínculada en un ServiceProvider
	}
}
```
Luego enlaza `info` en tu `ServiceProvider` y llamas `InfoFacade::someMethod()`
##### `Mocking` en pruebas
```php
Cache::shouldReceive('get')
	->with('key')
	->andReturn('value');
```
Esto crea un `spy` sobre el `Facade Cache` sin modificar el contenedor real.

---
## ✍️ Notas

- Aprovechar `shouldReceive()` en pruebas unitarias para aislar servicios externos (`cache`, `mail`) sin tocar configuraciones reales.
- Para código muy crítico o complejo, usar inyección de dependencias explícita y evitar `Facades` para mejorar claridad y testabilidad.
