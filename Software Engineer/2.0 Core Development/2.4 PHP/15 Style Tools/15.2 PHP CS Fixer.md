> [!info] PHP CS Fixer (Roadmap SH)
> `PHP CS Fixer` es una valiosa utilidad para desarrolladores PHP que examina y corrige su código para garantizar que se alinee con estándares de codificación específicos. Esta potente herramienta reduce el tiempo y el esfuerzo dedicados a la revisión y corrección manual del código. Revisa la sintaxis, la apariencia y la estructura de su código PHP y corrige automáticamente los problemas detectados. `PHP CS Fixer` admite los estándares PSR-1, PSR-2, Symfony y más.

### Definición
`PHP CS Fixer` (`PHP Coding Standards Fixer`) es una herramienta automática que revisa tu código PHP y lo corrige para que siga un conjunto de reglas de estilo predefinidas. Su objetivo principal es eliminar la fricción que se genera cuando diferentes programadores escriben código con estilos distintos en un mismo proyecto.

**Analogía**: Imagina que `PHP CS Fixer` es un "editor de estilos" robotizado para tu equipo En lugar de que una persona tenga que revisar manualmente que todos usen comas, espacios y salto de línea de la misma manera, este robot lo hace por todos de forma instantánea y sin errores. Esto permite que el equipo se enfoque en la lógica y funcionalidad del programa, no en discusiones sobre si la llave "`{`" va en la misma línea o en la siguiente.

### Conceptos Clave
- **Automatización del estilo**: Su función no es solo *detectar* errores de estilo, sino *corregirlos* automáticamente. Este es su mayor valor.
- **Estándares (`Rulesets`)**: Permite aplicar estándares de la comunidad como `PSR-12` ([[18.1 PHP Framework Interoperability Group]]) (El estándar de estilo moderno y recomendado) o el de `Symfony`. No tienes que definir las reglas una por una.
- **Configuración centralizada**: Todo el comportamiento de la herramienta se define en un único archivo en la raíz de tu proyecto, usualmente llamado `.php-cs-fixer.dist.php`. Esto garantiza que todos en el equipo usen exactamente las mismas reglas.
- **Integración**: Se puede integrar en flujos de trabajo CI/CD (Integración Continua) para falla una `build` si el código no cumple el estándar. También se integra con editores de código como `VS Code` o `PHPStorm` para formatear el código al guardar.
- **Simulación (`Dry Run`)**: Puedes ejecutarlo en modo "simulación" (`--dry-run`) para ver qué cambios haría sin aplicarlos realmente. Es muy útil para revisar el impacto antes de confirmar los cambios.
- **Reglas personalizables**: Además de los estándares, puedes habilitar, deshabilitar o configurar reglas específicas para adaptar el estilo a las necesidades de tu proyecto.

### Ejemplos prácticos
##### Instalación (escenario del día a día)
Lo primero es agregar `PHP CS Fixer` a las dependencias de desarrollo de tu proyecto usando `Composer`.
```bash
composer require --dev friendsofphp/php-cs-fixer
```
##### Antes y despues de la magia
Imagina que un desarrollador nuevo en el equipo escribe el siguiente código en un archivo `src\UserService.php`. Es funcional, pero se estilo es inconsistente.

```php
<?php
# Código antes de PHP CS Fixer

namespace App\Services;

class UserService{
    public function findUserById($userId) {
        if($userId <= 0){
            return null;
        }

        // TODO: a very complex database query here
        $user = ['id'  => $userId, 'name'=>'John Doe'];
        return $user;
    }
}
```
*Problemas: La llave `{` de la clase está en la misma línea, el `if` no tiene llaves para una sola línea (aunque se recomienda ponerlas),y hay un doble espacio en la asignación del array*.
Ahora, ejecutamos el `fixer` desde la terminal:

```bash
./vendor/bin/php-cs-fixer fix src/UserService.php
```

```php
<?php
# Código después de PHP CS Fixer

namespace App\Services;

class UserService
{
    public function findUserById($userId)
    {
        if ($userId <= 0) {
            return null;
        }

        // TODO: a very complex database query here
        $user = ['id' => $userId, 'name' => 'John Doe'];

        return $user;
    }
}
```
*Mejoras: El código ahora sigue el estándar PSR-12. Las llaves están en su propia línea, los espacios son consistentes y la estructura es limpia y predecible*.
##### Configuración para un proyecto real
El verdadero poder se libera con un archivo de configuración. Crea un archivo llamado `.php-cs-fixer.dist.php` en la raíz de tu proyecto. Este es un ejemplo práctico y muy común:
```php
<?php
// .php-cs-fixer.dist.php

$finder = (new PhpCsFixer\Finder())
    ->in(__DIR__) // Search in the current directory
    ->exclude('vendor'); // Exclude the vendor folder

return (new PhpCsFixer\Config())
    ->setRules([
        '@PSR12' => true, // Use the PSR-12 standard as a base
        'array_syntax' => ['syntax' => 'short'], // Enforce short array syntax []
        'ordered_imports' => ['sort_algorithm' => 'alpha'], // Order imports alphabetically
        'no_unused_imports' => true, // Remove unused import statements
        'single_quote' => true, // Enforce single quotes for strings
    ])
    ->setFinder($finder);
```
**Explicación del código**:
- `$finder`: Le dice a la herramienta dónde buscar archivos `.php`. Aquí le decimos que busque en todo el proyecto (`__DIR__`) pero que ignore la carpeta `vendor`.
- `setRules`: Este es el corazón de la configuración
	- `@PSR-12 => true`: activa todas las reglas del estándar PSR-12. Este es el 80% del trabajo.
	- `array_sintax ...`: Es una regla adicional que fuerza a usar `[]` en lugar de `array()`.
	- `ordered_imports ...`: Ordena los `use statements` alfabéticamente.
	- `no_unused_imports ...`: Limpia automáticamente los `use` que no estén utilizando en el archivo.
	- `single_quote`: Usa comillas simples `'` en lugar de dobles `"` cuando sea posible.

