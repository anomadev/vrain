> [!info] Static Analysis (Roadmap SH)
> El análisis estático en PHP en un método para inspeccionar el código fuentes antes de ejecutarlo. En lugar de probar programas con entradas específicas (análisis dinámico), el análisis estático se centra en detectar posibles problemas en el código sin ejecutarlo. Puede ayudar a identificar errores de codificación comunes y descubrir problemas complejos como problemas de dependencia, variables no utilizadas, propiedades no declaradas y más. El uso de herramientas como `PHPStan` o `Psalm` proporciona esta función de análisiS estático en PHP. Por ejemplos, usar `PHPStan` implica simplemente instalarlo mediante `Composer` y ejecutarlo en el código fuente.

> [!info] PHPStan (Roadmap SH)
> `PHPStan` es una herramienta de análisis estático para PHP que se centra en detectar errores en el código. A diferencia del análisis dinámico, que funciona mientras el programa se ejecuta, el análisis estático examina el código sin ejecutarlo. `PHPStan` puede detectar una clase entera de errores incluso antes de escribir pruebas para el código, lo que lo convierte en una herramienta valiosa en el desarrollo de PHP. Por ejemplo, `PHPStan` puede evitar problemas como acceder a una clave de matriz no definida o llamar a un método que no existe.

### Definición
`PHPStan` es una herramienta de análisis estático que encuentra errores en tu código PHP sin necesidad de ejecutarlo. Actúa como un inspector que revisa la coherencia y las reglas del lenguaje, detectando problemas que ni los `tests` ni el ojo humano ven fácilmente.

**Analogía**: Si `PHP-CS-Fixer` es el "editor de estilo" que se asegura de que tu libro esté bien formateado, `PHPStan` es el "editor  de contenido". Este editor lee tu manuscrito (el código) y te avisa de errores lógicos como:
- "En el capítulo 3 mencionas a un personaje que no existe" (llamar a un método inexistente).
- "Le estás pidiendo a un personaje que te dé su coche, pero ese personaje es un perro y no tiene uno" (intentar usar un método en una variable que puede ser `null`).
- "Dices que este capítulo solo hablará de números, pero estás incluyendo letras" (pasar un `string` a una función que espera un `int`).
`PHPStan` realiza esta revisión antes de que el libro se imprima (antes de que el código se ejecute en producción), previniendo errores vergonzosos o críticos.

### Conceptos Clave
- **Análisis Estático**: Las clave es que analiza el código "en reposo" (estáticamente), a diferencia de los `tests` unitarios que lo analizan "en movimiento" (dinámicamente). Ambos son complementarios.
- **Niveles (`Levels`)**: `PHPStan` tiene 10 niveles de rigurosidad (del 0 al 9). Un proyecto suele empezar en un nivel bajo (ej. 2) y se va subiendo gradualmente. Esto permite una adopción progresiva, especialmente en proyectos antiguos (`legacy`).
- **Tipado Fuerte (`Type System`)**: `PHPStan` exprime al máximo el sistema de tipos de PHP. Cuanta más información de tipos le des a tu código (`type hints` en argumentos, propiedades y retornos), más poderoso y preciso será `PHPStan`.
- **Configuración (`phpstan.neon`)**: Se configura a través de un archivo `phpstan.neon` o `phpstan.neon.dist`. Aquí se define el nivel, las carpetas a analizar y se pueden ignorar errores específicos.
- **Línea base (`Baseline`)**: Es una funcionalidad CRÍTICA para proyectos existentes. Permite tomar una "foto" de todos los errores actuales y los ignora, creando una línea base. A partir de ese momento, `PHPStan` solo reportará los nuevos errores que se introduzcan, permitiendo al equipo enfocarse en mejorar el código nuevo mientras se pagan las deudas técnicas del antiguo poco a poco.
- **PHPDocs**: Si trabajas en código que no usa `type hints` nativos, `PHPStan` es lo suficientemente inteligente para leer las notaciones de `PHPDocs` (`@param`, `@var`, `@return`) y usarlas para su análisis.

### Ejemplos Prácticos
##### Instalación
Como siempre, lo agregamos al proyecto con `Composer` ([[13.1 Composer]])
```bash
composer require --dev phpstan/phpstan
```
##### Código con errores ocultos
Imagina el siguiente código en `src/NotificationManager.php`. A simple vista, parece correcto.
```php
<?php
// src/NotificationManager.php

class User
{
    public function __construct(public string $name) {}

    public function getName(): string
    {
        return $this->name;
    }
}

class NotificationManager
{
    public function sendWelcomeEmail(?User $user): void
    {
        // Potential bug: $user can be null here!
        $message = 'Welcome, ' . $user->getName();
        echo $message;

        // Bug: We are passing a string to a function that expects an int
        $this->logNotification(date('Y-m-d'));
    }

    private function logNotification(int $timestamp): void
    {
        // ... logs to a file
    }
}
```
*Problemas que `PHPStan` encontrará*:
1. Estamos llamando a `$user->getName()` sin comprobar si `$user` es `null`, lo que causaría un error fatal en producción.
2. Estamos pasando el resultado de `date()`, que es un `string`, al método `logNotification()`, que espera un `int`.
##### Ejecutando `PHPStan` y viendo los errores
Ejecutamos `PHPStan` para que analice la carpeta `src`.
```bash
# Terminal
./vendor/bin/phpstan analyse src
```
Salida de `PHPStan` (los errores que nos ahorró):
```
------ ------------------------------------------------------------------- 
Line NotificationManager.php 
------ ------------------------------------------------------------------- 
20 Calling method getName() on possibly null type User. 
24 Parameter #1 $timestamp of method 
   NotificationManager::logNotification() expects int, string given. 
------ ------------------------------------------------------------------- 

[ERROR] Found 2 errors
```
##### Configuración básica para un proyecto (`phpstan.neon.dist`)
Para no tener que escribir los `paths` cada vez, creamos un archivo `phpstan.neon.dist`.
```
# phpstan.neon.dist

parameters:
    # Level 0 is the loosest, 9 is the strictest.
    # Level 5 is a great start for new projects.
    level: 5

    # Paths to analyse.
    paths:
        - src
        - tests
```
Ahora podemos ejecutar el comando de forma más simple: `./vendor/bin/phpstan analyse`.
##### Introducir `PHPStan` en un proyecto legacy (usando `baseline`)
Imagina que tu proyecto tiene 500 errores. Arreglarlos todos es inviable. Creas una línea base.
```bash
# Terminal
# This command finds all current errors and puts them in a "to-ignore" file
./vendor/bin/phpstan analyse --generate-baseline
```
Esto crea un archivo `phpstan-baseline.neon` y lo incluye automáticamente en tu configuración. Si ahora ejecutas el análisis de nuevo, el resultado será: `[OK] No errors found!`. A partir de ahora, solo te alertará de los nuevos errores que tú o tu equipo introduzca.
