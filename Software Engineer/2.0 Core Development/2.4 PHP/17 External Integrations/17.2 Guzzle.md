> [!info] Guzzle (Roadmap SH)
> `Guzzle` es un cliente HTTP PHP que simplifica la creación de solicitudes HTTP en PHP. Ofrece una forma sencilla y potente de enviar solicitudes HTTP. `Guzzle` puede simplificarte la vida si gestionas API u otras solicitudes HTTP con frecuencia. Es ideal para todo , desde enviar solicitudes `GET` simples hasta cargar archivos con solicitudes `POST` o incluso manejar errores mediante el manejo de excepciones.

### Definición
`Guzzle` es una librería (o cliente) de HTTP para PHP. Su único propósito es hacer que el envío de peticiones HTTP y la integración con servicios web sea una tarea sencilla, moderna y robusta.
Fundamentalmente, `Guzzle` es una abstracción sobre `cURL` ([[17.1 cURL]]). Por defecto, utiliza toda la potencia y fiabilidad de `cURL` "bajo el capó", pero nos presenta una interfaz orientada a objetos (POO) mucho más limpia, intuitiva y fácil de usar. Elimina la necesidad de manejar los detalles de bajo nivel de `cURL`, permitiendo al desarrollador enfocarse en la lógica de la aplicación.

**Analogía**: Si `cURL` es el sistema de mensajería universal con sus complejas palancas y manales de operación, `Guzzle` es la aplicación de envíos premium en tu smartphone. Con `Guzzle`, ya no interactúas con la oficina de correos; simplemente abres una app limpia y bien diseñada.
- Creas un cliente: `new Client()` ([[11.1 Classes and Objects]])
- Eliges un servicio: `$client->get()`, `$client->post()`
- Añades el contenido y las instrucciones: Pasas un simple array de opciones (`['json' => ...]`. `['headers'] => ...`). La app se encarga de empaquetar todo correctamente, poner la etiquetas adecuadas (`Content-Type`) y te notifica de inmediato con un mensaje claro si la entrega falló (una `Exception`), en lugar de hacerte descifrar un código de error manual.

### Conceptos Clave
- **Abstracción, no Reemplazo**: `Guzzle` no reinventa la rueda; se monta sobre los hombros de gigantes como `cURL` para ofrecer una mejor experiencia de desarrollo.
- **Interfaz orientada a objetos** ([[11.1 Classes and Objects]]): Olvídate de la funciones procedurales `curl_*`. Con `Guzzle` trabajas con objetos: creas un objeto `Client` y este te devuelve objetos `Response`. Es más legible y se integra naturalmente en arquitecturas modernas.
- **Cliente (`Client`)**: Es el objeto principal y reutilizable. Generalmente, creas una instancia de `Client` y la usas para realizar todas las peticiones a una API específica.
- **Peticiones como Métodos** ([[11.3 Properties and Methods]]): La API es muy intuitiva. Para hacer una petición `GET`, usas el método `get()`. Para una `POST`, usas `post()`, y así sucesivamente (`put`, `delete`, `patch`, etc.).
- **Manejo de errores con excepciones**: Este es uno de sus mayores beneficios. `Guzzle` convierte los errores en excepción de PHP.
	- **Errores de Red**: Si no se puede conectar, lanza una `ConnectException`.
	- **Errores HTTP** ([[1.05 HTTP Status Codes]]): Lanza una `ClientException` para errores 4xx (ej. 401 `Not Found`, 401 `Unauthorized`) y una `ServiceException` para errores 5xx (ej. 500 `Internal Server Error`). Esto permite usar bloques `try/catch` para un manejo de errores limpio y predecible.
- **Middleware**: Es un sistema avanzado que permite "interceptar" y modificar peticiones y respuestas. Es como una cadena de montaje donde cada estación (`middleware`) puede añadir, modificar o revisar el paquete antes de que sea enviado o al ser recibido. Se usa para tareas como añadir automáticamente un token de autenticación a cada petición, registrar todas las transacciones, etc.

### Ejemplos Prácticos
##### Instalación
`Guzzle` se instala, como toda librería moderna de PHP, a través de `Composer` ([[13.1 Composer]]).
```bash
# Terminal
composer require guzzlehttp/guzzle
```
##### Petición `GET` simple (la forma moderna)
Compara la brevedad y claridad de este código con el ejemplo equivalente en `cURL` ([[17.1 cURL]]).
```php
<?php
require 'vendor/autoload.php';

use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;

$client = new Client();

try {
    $response = $client->get('https://jsonplaceholder.typicode.com/posts/1');

    $statusCode = $response->getStatusCode(); // Get HTTP status code (e.g., 200)
    $body = $response->getBody()->getContents(); // Get response body as a string

    if ($statusCode === 200) {
        $data = json_decode($body, true);
        echo "Post Title: " . $data['title'];
    }

} catch (RequestException $e) {
    // This catches all Guzzle request errors (network, 4xx, 5xx)
    echo "Request failed: " . $e->getMessage();
}
```
##### Petición `POST` con JSON (la ventaja de `Guzzle`)
`Guzzle` hace que enviar JSON sea trivial con la opción `json`. Automáticamente codifica el array y establece el `header` `Content-Type: application/json` ([[1.06 HTTP Headers]]).
```php
<?php
require 'vendor/autoload.php';

use GuzzleHttp\Client;

$client = new Client(['base_uri' => 'https://jsonplaceholder.typicode.com']);

$postData = [
    'title' => 'My Guzzle Post',
    'body' => 'Guzzle makes sending JSON so easy!',
    'userId' => 10,
];

try {
    $response = $client->post('/posts', [
        'json' => $postData
    ]);

    $body = $response->getBody()->getContents();

    echo "Post created successfully! Response:\n";
    print_r(json_decode($body, true));

} catch (\GuzzleHttp\Exception\ClientException $e) {
    // Specifically catch 4xx errors
    echo "Failed to create post: " . $e->getResponse()->getBody()->getContents();
}
```
##### Petición con Autenticación y `Query Params`
Combinando varias opciones comunes.
```php
<?php
require 'vendor/autoload.php';

use GuzzleHttp\Client;

$client = new Client();
$apiKey = 'your_secret_api_key_here';

try {
    $response = $client->get('https://api.example.com/v1/articles', [
        'headers' => [
            'Authorization' => 'Bearer ' . $apiKey,
            'Accept'        => 'application/json',
        ],
        'query' => [
            'status' => 'published',
            'limit'  => 10
        ]
    ]);

    // Process the response...
    echo $response->getBody()->getContents();

} catch (RequestException $e) {
    echo "Request failed: " . $e->getMessage();
}
```
