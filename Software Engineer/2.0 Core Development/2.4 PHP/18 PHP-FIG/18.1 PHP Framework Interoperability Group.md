> [!info] PHP-FIG (Roadmap SH)
> PHP-FIG, también conocido como PHP Framework Interoperability Group, es una parte vital del ecosistema de PHP. Este grupo tiene el objetivo principal de crear estándares PHP que promuevan la interoperabilidad entre marcos PHP, bibliotecas y otras piezas de software basadas en PHP. El grupo es responsable de los estándares PSR, a los que se adhiere la mayoría de los códigos PHP modernos. Normalmente, proporciona directrices sobe estilo de codificación, interfaz de registro, caché HTTP y más. Cada PSR está diseñado para que el código PHP sea más consistente y fácil de mantener. Al adherirse a los estándares PHP-FIG, los desarrolladores mejoran su capacidad para integrar y aprovechar código de terceros en sus proyectos.

El `PHP-FIG (PHP Framework Interoperability Group)` es un grupo formado por representantes de los proyectos PHP más influyentes (`frameworks`, librerías, aplicaciones, etc.). Su objetico principal no es dictar cómo debe ser el lenguaje PHP, sino crear un conjunto de "recomendaciones" para promover la interoperabilidad entre sus proyectos.
Estas recomendaciones se llaman `PSRs (PHP Standards Recommendations)`. Un `PSR` es un documento que define una norma común para resolver un problema específico, como el estilo de código, el `autoloading` ([[13.3 Autoloading]]) de clases o la forma de manejar peticiones HTTP.

**Analogía**: Imagina que el ecosistema PHP es el mundo y cada `framework (Laravel, Symfomy, Drupal, etc.)` es un país. El `PHP-FIG` es la Organización de las Naciones Unidas (ONU) de PHP.
- La ONU no le dice a cada país cómo gobernar o cuál debe ser su cultura interna.
- En cambio, crea acuerdos internacionales (`PSRs`) sobre problemas comunes:
	- Un estándar para los enchufes eléctricos (`PSR-4 Autoloader`), para que puedas usar un secador de pelo de un país en otro.
	- Un estándar para el tamaño de los contenedores de carga (`PSR-7 HTTP Messages`), para que cualquier barco o camión del mundo pueda transportarlos.
	- Un idioma común para los pilotos de avión (`PSR-3 Logger Interface`), para que todos se entiendan en una emergencia.
El objetivo es que el "comercio" y la "cooperación" (interoperabilidad) entre los países (proyectos) sea fluida y sin fricciones.

### Conceptos Clave
- Interoperabilidad es la clave: El objetivo no es que todo el código sea igual, sino que los componentes de diferentes proyectos puedan trabajar juntos sin problemas.
- Proceso comunitario: Los `PSR`s son propuestos, discutidos y votados por los proyectos miembro. Son estándares adoptados voluntariamente por la comunidad, no impuestos desde arriba.
- Interfaces como contratos: Muchos de los `PSR`s más importantes (PSR-3, PSR-7, PSR-11) no son código, sino interfaces de PHP. Definen un "contrato" de cómo un objeto debe comportarse, permitiéndote cambiar la implementación subyacente sin alterar tu aplicación.
- Los `PSR`s más influyentes (El 20% que verás el 80% del tiempo):
	- **`PSR-4 (Autoloader)`**: Es estándar de facto sobre cómo un nombre de clase (`namespace`) ([[11.11 Namespaces]]) se corresponde con una ruta de archivo. Es la base del `autoloading` ([[13.3 Autoloading]]) de `Composer` ([[13.1 Composer]]).
	- **`PSR-12 (Extended Coding Style)`**: La guía de estilo de código moderna que reemplazó a PSR-2. Define todo, desde los espacios y la indentación hasta la posición de la llaves.
	- **`PSR-3 (Logger Interface)`**: Define una interfaz común para las librerías de `logging`. Te permite cambiar de `Monolog` a cualquier otro `logger` compatible sin reescribir tu código.
	- **`PSR-7 (HTTP Message Interface)`**: Define cómo deben ser los objetos que representan una petición y una respuesta HTTP. Es la base de los `frameworks` y clientes HTTP modernos.
	- **`PSR-11 (Container Interface)`**: Define una forma estándar de interactuar con contenedores de inyección de dependencias (`DI Containers`).

### Ejemplos Prácticos
En lugar de un solo ejemplo, veamos cómo impactan los `PSR`s clave en el día a día.
##### `PSR-4 (Autoloader)` 
Esta es la regla que permite que `Composer` encuentre tus clase mágicamente. En tu archivo `composer.json`.
```json
{
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    }
}
```
- El `namespace` base `App\\`...
- ...corresponde a la carpeta `src/`
- Por lo tanto, la clase `App\Service\PaymentGateway` debe estar en el archivo `src/Service/PaymentGateway.php`.
Esta simple regla organiza todo tu proyecto.
##### `PSR-12 (Coding Style)` en código
Este es un fragmento de código con `PSR-12`. Es el estilo que `PHP-CS-Fixer` ([[15.2 PHP CS Fixer]]) aplica por defecto.
```php
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Services\UserService;

class UserController
{
    public function getUser(int $id): void
    {
        if ($id > 0) {
            $service = new UserService();
            // ...
        } else {
            // ...
        }
    }
}
```
Característica notables: `{` en la siguiente línea para clases y métodos, espacio después de `if`, `else` en su propia línea etc.
##### `PSR-3 (Logger)` para máxima flexibilidad
Imagina una clase que necesita registrar eventos. En lugar de depender de una librería específica, depende de la interfaz de `PSR-3`.
```php
<?php
// PHP Code
use Psr\Log\LoggerInterface; // Depending on the PSR-3 interface

class OrderService
{
    public function __construct(
        private LoggerInterface $logger // Type-hinting the interface, not a concrete class
    ) {}

    public function placeOrder(array $orderData): void
    {
        // ... logic to place the order
        $this->logger->info(
            'Order has been placed successfully.',
            ['order_id' => 12345]
        );
    }
}
```
**Explicación**: Ahora puedes "inyectar" cualquier librería de `logging` que implementa `LoggerInterface` (como `Monolog`, `KLogger`, etc.) en `OrderService` sin cambiar una solo línea de su código.
