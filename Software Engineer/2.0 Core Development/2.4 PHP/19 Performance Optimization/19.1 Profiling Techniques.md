> [!info] Profiling Techniques (Roadmap SH)
> La creación de perfiles es un proceso analítico dentro de PHP que se centra en optimizar el rendimiento de la aplicación. Implica identificar cuellos de botella y secciones problemáticas del código PHP que causan un rendimiento deficiente, a menudo mediante herramientas de creación de perfiles. Una de estas herramientas es `Xdebug`, que proporciona información detallada sobre cómo se ejecuta cada línea de código. Este proceso ayuda a comprender cuánto tiempo tarde en ejecutarse una operación, qué partes consumen más memoria y qué funciones/métodos se utilizan con más frecuencia, lo que permite desarrollar una estrategia de optimización.

El `Profiling` (o perfilado de rendimiento) es el proceso de analizar una aplicación de software para determinar cómo está utilizando los recursos, principalmente el tiempo de ejecución y la memoria. A diferencia de una simple medición de tiempo, el `profiling` desglosa el rendimiento por cada función, método y llamada de código.
La herramienta que realiza esta tarea se llama `Profiler`. En PHP, el `profiler` más conocido y potente es el que viene integrado con `Xdebug` ([[21.1 Xdebug]]). Su objetivo es responder a la pregunta: *Por qué mi aplicación es lenta?* no con suposiciones, sino con datos empíricos y precisos.

**Analogía**: Imagina que tu aplicación es un equipo de remo en una competición. Sientes que el bote va lento, pero no sabes por qué.
- *Suponer* sería gritarle al remero que te parece más débil
- *Hacer `profiling`* sería conectar un sensor biométrico a cada remero durante la carrera. Al final, obtienes un informa detallado (`archivo cachegrind`) que te muestra exactamente quién remó más fuerte, quién se cansó primero y quién no estaba sincronizado (el cuello de botella). Con esos datos, sabes exactamente a quién entrenar o qué técnica corregir para que todo el bote vaya más rápido.

### Conceptos Clave
- **Encontrar cuellos de botella (`bottlenecks`)**: Este es el objetivo final. Un cuello de botella es la parte específica del código (a menudo una sola función o unas pocas líneas) que consume la mayor parte del tiempo de ejecución, ralentizando todo lo demás.
- **`Profiling` vs. `Benchmarking`**: Un `benchmark` te dice cuánto tarda algo (ej. Este script tarda 2 segundos). Un `profiler` te dice por qué tarda 2 segundos (ej. De esos 2 segundos, 1.8 se gastaron en la función `calculateComplexStuff()`).
- **Modo `Profiler de Xdebug`**: `Xdebug` es una extensión con múltiples modos. Para activar el `profiling`, necesitas configurar `xdebug.mode=profile` en tu archivo `php.ini`.
- **Archivos "`Cachegrind`"**: El `profiler` no muestra los resultados en la pantalla. Cuando se ejecuta una petición perfilada, genera un archivo de datos (ej. `cachegrind.out.12345`) en un formato estándar llamado `cachegrind`. Este archivo contiene el mapa de todas las llamadas de función y sus costos.
- **La visualización es indispensable**: El archivo `cachegrind` por sí solo es ilegible. Necesitas una herramienta de visualización para abrirlo y analizar los datos. Las más comunes son:
	- `QCacheGrind / KCacheGrind` (Linux, macOS)
	- `WinCacheGrind` (Windows)
	- La herramienta de `Profiling` integrada en `PHPStorm` (muy potente y fácil de usar)
- **Costo Inclusivo vs. Propio (`Inclusive vs. Self Cost`)**: Al analizar los resultados, verás dos métricas principales:
	- **`Self Cost` (Costo Propio)**: El tiempo que se pasó *ejecutando el código dentro* de una función, excluyendo el tiempo de otras funciones a las que llamó. Un "'`Self Cost`" alto indica que la lógica *dentro* de esa función es lenta.
	- **`Inclusice Cost` (Costo Inclusivo)**: El tiempo total que tomó la función, *incluyendo* el tiempo de todas las funciones que llamó. Un "`Inclusive Cost`" alto pero un "`Self Cost`" bajo significa que la función en sí es rápida, pero llama a otras funciones que son las verdaderas culpables de la lentitud.

### Ejemplos Prácticos: El Flujo de Trabajo
El `profiling` es un proceso. Aquí está el flujo de trabajo completo.
##### El código lento a perfilar
Imagina que tenemos este script y sospechamos que es lento.
```php
<?php
// slow_script.php

function process_data(array $items): string
{
    $result = '';
    foreach ($items as $item) {
        // This is a very inefficient way to build a string
        $result .= md5((string)$item) . ' ';
    }
    return $result;
}

function get_user_info(int $userId): array
{
    // Simulate a fast database query
    usleep(10000); // Sleep for 10ms
    return ['id' => $userId, 'name' => 'John Doe'];
}

$items = range(1, 50000);
$userInfo = get_user_info(123);
$processedData = process_data($items); // This is probably the slow part

echo "User {$userInfo['name']} processed " . count($items) . " items.\n";
```
##### Configuración en `php.ini`
Asegúrate de que `Xdebug` ([[21.1 Xdebug]]) está configurado para perfilar
```toml
# php.ini

zend_extension=xdebug
xdebug.mode=profile
xdebug.output_dir="/tmp/xdebug_profiles" ; Choose a directory where you have write permissions
```
(*Recuerda reiniciar tu servidor web o PHP-FPM después de cambiar `php.ini`* ([[20.4 Configuration Files]]))
##### Ejecutar la petición
Simplemente ejecuta el script (o accede a la URL en tu navegador)
```bash
# Terminal
php slow_script.php
```
##### Encontrar el archivo de salida
Ve al directorio que configuraste. Encontrarás un nuevo archivo.
```bash
# Terminal
ls -l /tmp/xdebug_profiles/
# Output: -rw-r--r-- 1 user user 123456 Jul 03 17:00 cachegrind.out.45678
```
##### Analizar con una Herramienta Visual
Abre ese archivo `cachegrind.out.45678` con `QCacheGrind` o `PHPStorm`. Vería algo como esto (representación textual).

|Inclusive Cost|Self Cost|Function Name|Call Count|
|---|---|---|---|
|**1,850 ms**|**1,840 ms**|`process_data`|1|
|10 ms|10 ms|`get_user_info`|1|
|1,500 ms|1,500 ms|`md5`|50,000|
|10 ms|10 ms|`usleep`|1|
|...|...|...|...|

**Conclusión Inmediata**: La función `process_data` tiene el "`Self Cost`" más alto por un margen enorme. dentro de ella, la llamada a `md5` se ejecuta 50,000 veces y es la principal culpable. El cuello de botella ha sido identificado sin ninguna duda.
