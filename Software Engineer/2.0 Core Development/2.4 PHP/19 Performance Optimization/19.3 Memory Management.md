> [!info] Memory Management (Roadmap SH)
> La gestión de memoria es crucial para optimizar el rendimiento de PHP. Un uso eficiente de la memoria puede aumentar significativamente la velocidad y fiabilidad de sus aplicaciones PHP. PHP proporciona automáticamente un recolector de basura que limpia la memoria no utilizada, pero comprender y administrar el uso de memoria de su script puede resultar en un mejor uso de los recursos.

### Definición
La gestión de memoria en PHP es en gran medida un proceso automático. El motor de PHP (`Zend Engine`) se encarga de asignar y liberar memoria para las variables, pero este proceso tiene matices. El mecanismo principal se llama conteo de referencias (`reference counting`). Cuando una variable ya no es referenciada por ninguna parte del código, PHP la elimina.
Sin embargo, este sistema puede fallar en un escenario específico: las referencias circulares. El recolector de basura (`Garbage Collector o GC`) es un subsistema específico diseñado para detectar y limpiar estas referencias circulares, previniendo fugas de memoria (`memory leaks`).

**Analogía**: Imagina que cada variable en tu programa es una persona en una gran fiesta (`zval`). Cada vez que alguien apunta a esa persona (una referencia), su contador de popularidad (`refcount`) aumenta. Cuando todos dejan de apuntarle (`refcount` llega a 0), el personal de seguridad (PHP) la acompaña a la salida (libera la memoria).
El problema surge si dos persona, A y B, solo se señalan mutuamente y nadie más las señala. Su contador de popularidad nunca será 0, así que la seguridad normal los ignora. El `garbage collector (GC)` es un supervisor especial que periódicamente recorre la fiesta buscando estos "círculos cerrados" de personas que solo se apuntan entre sí, y los saca a todos juntos, manteniendo la fiesta limpia.

### Conceptos Clave
- **`zval container`**: Es la estructura de datos interna de C con la que el motor `Zend` representa cualquier variable de PHP. Contiene el valor, el tipo y lo más importante, un campo llamado `refcount`.
- **Conteo de Referencias (`refcount`)**: Es el mecanismo base. Cada `zval` tiene un contador que rastrea cuántos símbolos o variables apuntan hacia él. Cuando el `refcount` de un `zval` llega a cero, PHP sabe que es seguro destruir esa variable y liberar su memoria.
- **El problema: referencias circulares**: ocurre cuando dos o más objetos se referencian entre sí, creando un ciclo. Por ejemplo, un objeto `Order` tiene una referencia a su `Customer`, y el `Customer` tiene una referencia de vuelta a ese `Order`. Aunque el resto del programa "olvide" ambos objetos, sus `refcounts` internos nunca llegarán a cero porque se mantienen "vivos" artificialmente.
- **El recolector de basura (GC) al rescate**: El GC en PHP no se ejecuta constantemente. Se activa periódicamente cuando un "`buffer` raíz" interno se llena.
	1. Realiza una búsqueda en profundidad (`Deep First Search`) para encontrar todos los posibles "círculos".
	2. Simula una disminución del `refcount` en cada nodo del ciclo.
	3. Si después de la simulación los `refcounts` llegan a cero, confirma que son basura y los elimina de verdad.
- **Control Manual**: Aunque el GC es automático, PHP proporciona funciones como `gc_enable()`, `gc_disable()` y `gc_collect_cycles()` para controlarlo manualmente, lo cual es útil en secciones de código muy críticas para el rendimiento.

### Ejemplos Prácticos
##### El caso clásico de una fuga de memoria por referencia circular
Este código crea un ciclo de referencia que sin el GC, permanecería memoria indefinidamente.
```php
<?php
// Enable reporting to see memory usage
error_reporting(E_ALL);
ini_set('display_errors', 1);

echo "Initial memory usage: " . memory_get_usage() . " bytes\n";

class User
{
    public string $name;
    public ?Subscription $subscription = null; // Can hold a Subscription object

    public function __construct(string $name)
    {
        $this->name = $name;
    }

    public function __destruct()
    {
        echo "Destroying User: {$this->name}\n";
    }
}

class Subscription
{
    public ?User $user = null; // Can hold a User object

    public function __destruct()
    {
        echo "Destroying Subscription\n";
    }
}

// Create a cycle
$user = new User('John Doe');
$subscription = new Subscription();

$user->subscription = $subscription; // User points to Subscription
$subscription->user = $user;         // Subscription points back to User

// Unset the initial variables that point to the objects
unset($user, $subscription);

echo "Memory usage after unset: " . memory_get_usage() . " bytes\n";

// At this point, the objects are "lost" but still in memory due to the cycle.
// Let's force the Garbage Collector to run and clean up the cycle.
$cyclesCollected = gc_collect_cycles();

echo "Cycles collected: " . $cyclesCollected . "\n";
echo "Final memory usage: " . memory_get_usage() . " bytes\n";
```
**Explicación del Flujo**:
1. Creamos un `User` y una `Suscripción`
2. Hacemos que el usuario apunte a la suscripción y viceversa, creando un ciclo cerrado.
3. Usamos `unset()` para eliminar las variables `$user` y `$suscription`. Sin el ciclo, esto sería suficiente para que sus `refcounts` lleguen a cero y se destruyan.
4. Sin embargo, debido al ciclo, sus `refcounts` se quedan en 1. La memoria no se libera.
5. Al llamar a `gc_collect_cycles()`, forzamos al GC a buscar estos ciclos. Los encuentra, los identifica como basura y los elimina. Verás los mensajes de los `__destruct` ([[11.2 Constructor and Destructor]]) y una disminución.
