> [!info] Process Control (Roadmap SH)
> El control de procesos, un aspecto crucial de las interacciones del sistema PHP, se refiere a la capacidad de administrar procesos secundarios dentro de scripts PHP más grandes. A través de las extensiones de control de procesos, PHP puede crear, monitorear y controlar estos procesos secundario de manera eficiente. Estas funciones ayudan a desarrollar sistemas cliente-servidor robustos al administrar y brindar capacidades de subprocesos múltiples a scripts PHP de un solo proceso. Por ejemplo, al crear un nuevo proceso secundario utilizando la función `pcntl_fork()`, el valor de retorno en el proceso primario es el PID del proceso secundario recién creado, mientras que el proceso secundario se devuelve `0`. Recuerde que esta función no está habilitada de forma predeterminada en PHP.

### Definición
El Control de Procesos en PHP, facilitado por la extensión `PCNTL (Process Control)`, es la capacidad de un script PHP para crear y gestionar procesos directamente a nivel del sistema operativo. Esto permite a un script principal "bifurcase" (`fork`) en múltiples procesos hijos que pueden ejecutar tareas de forma concurrente.
Es una herramienta de bajo nivel y extremadamente potente, pero con una limitación fundamental: **está diseñada para ser usada casi exclusivamente en entornos de línea de comandos (CLI)**. No funcionará en la mayoría de los entornos web (como Apache ([[22.1 Apache]]) o PHP-FPM ([[19.6 PHP-FPM]])).

**Analogía**: Si un script normal de PHP es un trabajador de oficina que realiza una tarea de principio a fin, usar PCNTL es como si ese trabajador se convirtiera en un gerente de proyectos que puede clonarse a sí mismo. El gerente original (el proceso padre) le asigna una tarea diferente a cada uno de sus clones (los procesos hijos). Mientras los clones trabajan en sus tareas simultáneamente, el gerente puede supervisarlos, esperar a que terminen y recoger sus resultados. Esto permite realizar muchas más tareas en el mismo lapso de tiempo.

### Conceptos Clave
- **Exclusivo para CLI**: Esta es la regla más importante. Las funciones de PCNTL no están disponibles o están deshabilitadas en la mayoría de las configuraciones de servidor web porque el manejo de procesos es responsabilidad de PHP-FPM o el SAPI del servidor.
- **Bifurcación (`pcntl_fork()`)**: Es la función central de PCNTL. Crea una copia exacta del proceso actual. El momento después de la bifurcación es clave:
	- El proceso padre, `pcntl_fork()` devuelve el ID del proceso (PID) del hijo recién creado.
	- En el proceso hijo, `pcntl_fork()` devuelve `0`.
	- Si falla, devuelve `-1`. Este comportamiento permite escribir lógica condicional para que el padre y el hijo hagan cosas diferentes.
- **Esperar a los hijos (`pcntl_wait()` y `pcntl_waitpaid()`)**: El proceso padre debe esperar a que sus hijos terminen. Si el padre termina antes que sus hijos, estos se convierten en "procesos zombies" que permanecen en la table de procesos del sistema hasta que son limpiados. `pcntl_wait()` espera a que cualquier hijo termine.
- **Señales (`Signals`)**: Las señales son una forma de comunicación entre procesos (IPC). PCNTL permite que un script PHP capture y maneje señales del sistema operativo. Poe ejemplo, se puede capturar `SIGINT` (la señal que se envía al presionar `Ctrl+C`) para realiza una limpieza antes de terminar. La función clave aquí es `pcntl_signal()`.
- **Convertirse en un demonio (`Daemon`)**: PCNTL es la base para crear "`daemons`" o "`workers`" en PHP, que son scripts de larga duración que se ejecutan en segundo plano para realizar tareas como procesar colas de trabajo.

### Ejemplos Prácticos
##### Bifurcación simple (`fork`)
Este ejemplo muestra el flujo básico de crear un proceso hijo y esperar a que termine.
```php
<?php
// This script must be run from the command line: php your_script.php

echo "Parent process started with PID: " . getmypid() . "\n";

$pid = pcntl_fork();

if ($pid === -1) {
    die("Could not fork the process.");
} elseif ($pid > 0) {
    // --- This block is executed by the PARENT process ---
    echo "Parent: I have created a child with PID: $pid\n";

    // Wait for the child process to finish
    pcntl_wait($status);
    echo "Parent: My child has finished. Exiting.\n";
} else {
    // --- This block is executed by the CHILD process ---
    // The child gets its own PID
    echo "  Child: I am the child process with PID: " . getmypid() . "\n";
    echo "  Child: I will do some work for 3 seconds...\n";
    sleep(3);
    echo "  Child: I have finished my work. Exiting.\n";
    // The child process must exit to not continue the parent's script
    exit();
}
```
##### Manejo de señales básico
Este script captura la señal de interrupción (`Ctrl+C`) para terminar de forma elegante.
```php
<?php
// This script must be run from the command line

// Define the function that will handle the signal
function signal_handler(int $signal)
{
    echo "\nCaught signal " . $signal . ". Shutting down gracefully.\n";
    exit;
}

// Register the handler for the SIGINT signal (Ctrl+C)
pcntl_signal(SIGINT, 'signal_handler');

echo "Process running with PID " . getmypid() . ". Press Ctrl+C to exit.\n";

// Keep the script alive to be able to catch the signal.
// pcntl_signal_dispatch() is needed in loops to check for pending signals.
while (true) {
    sleep(1);
    pcntl_signal_dispatch();
}
```
