> [!info] Nginx (Roadmap SH)
> `Nginx` a menudo se implementa como un servidor proxy inverso para aplicaciones PHP, lo que ayuda a administrar las soluciones de los clientes y el equilibrio de carga. A diferencia de los servidores tradicionales, `Nginx` maneja numerosas conexiones simultáneas de manera más eficiente, lo que resulta fundamental para entregar contenido PHP más rápido. Para PHP, una configuración común con `Nginx` involucra PHP-FPM. `FastCGI` es una variación del anterior CGI (`Common Gateway Interface`) y permite procesos PHP de larga duración que pueden atender muchas solicitudes, mejorando el rendimiento de las aplicaciones PHP.

### Definición
`Ngix` es un servidor web de código abierto conocido por su alto rendimiento, estabilidad y bajo consumo de recursos. Además de ser un servidor web, a menudo se utiliza como proxy inverso, balanceador de carga y caché HTTP.
Su diseño se basa en una arquitectura asíncrona y basada en eventos, lo que le permite manejar miles de conexiones simultáneas de manera muy eficiente. A diferencia de Apache ([[22.1 Apache]]), `Nginx` no puede procesar PHP directamente; siempre se comunica con un gestor de procesos externo, como `PHP-FPM` ([[19.6 PHP-FPM]]), a través del protocolo `FastCGI`.

**Analogía**: Si apache es el restaurante tradicional, `Nginx` es una cocina fantasma (`ghost kitchen`) de alta tecnología
- El cajero (`Nginx`) es un robot increíblemente rápido que puede tomar miles de pedidos a la vez sin confundirse.
- El cajero no sabe cocinar. Su única tarea es tomar pedidos y, si son para platos sencillos (archivos estáticos), los entrega al instante desde un almacén.
- Si el pedido es complejo (un script PHP), el robot lo envía inmediatamente a una cocina especializada y externa (`PHP-FPM` - [[19.6 PHP-FPM]]) a través de un tubo neumático (el `socket FastCGI`). 
- Este sistema es extremadamente eficiente porque el robot cajero nunca se bloquea esperando a un cocinero; simplemente gestiona un flujo masivo de pedidos.

### Conceptos Clave
- **Arquitectura Basada en Eventos (`Event-Driven`)**: Este es el secreto del rendimiento de `Nginx`. Utiliza un número pequeño y fijo de procesos "`worker`" que operan de forma asíncrona. Cada `worker` puede manejar miles de conexiones en un bucle de eventos, esperando a que ocurra algo (una nueva conexión, datos listos para leer) en lugar de bloquearse. Esto resulta en un uso de memoria muy bajo y predecible.
- **Dependencia Exclusiva de `PHP-FPM`** ([[19.6 PHP-FPM]]): `Nginx` no tiene un equivalente `mod_php`. La comunicación con PHP siempre se realiza a través de `FastCGI`. Esto impone una separación limpia entre el servidor web y el intérprete de PHP, lo cual es que una práctica recomendada moderna.
- **Sin `.htaccess`**: `Nginx` no soporta archivos de configuración por directorio como los `.htaccess` de Apache. Toda la configuración (incluyendo reescritura de URLs y directivas de acceso) se encuentra en un único lugar: los archivos de configuración centrales del servidor.
	- Ventaja: Mayor rendimiento, ya que `Nginx` no necesita escanear el sistema de archivos en busca de archivos `.htaccess` en cada petición.
	- Desventaja: Menos flexibilidad para los desarrolladores que no tienen acceso de administrador al servidor.
- **Rol como Proxy Inverso**: `Ngix` es excepcionalmente bueno en actuar como intermediario. Puede recibir peticiones y distribuirlas a uno o más servidores de aplicaciones (qué podrían ser servidores `Apache`, `Node`, `Python`, etc.). Esto se usa para balanceo de carga, terminación SSL y para servir activos estáticos rápidamente, liberando a los servidores de aplicación.

### Ejemplos Prácticos
##### Configuración básica de un `server block` para PHP
Este es el equivalente de `Nginx` a un `VirtualHost` de Apache. Define un sitio web y cómo maneja las peticiones.
```nginx
# /etc/nginx/sites-available/your-domain.com

server {
    listen 80;
    server_name your-domain.com www.your-domain.com;
    root /var/www/your-domain.com/public;

    index index.php index.html index.htm;

    # Main location block to handle requests
    location / {
        # Tries to find a file with the given URI, then a directory,
        # otherwise falls back to index.php (Front Controller pattern)
        try_files $uri $uri/ /index.php?$query_string;
    }

    # Pass PHP scripts to FastCGI server listening on a Unix socket
    location ~ \.php$ {
        include snippets/fastcgi-php.conf;

        # The crucial part: pass the request to the PHP-FPM socket
        fastcgi_pass unix:/run/php/php8.2-fpm.sock;
    }

    # Deny access to .htaccess files, if they exist
    location ~ /\.ht {
        deny all;
    }
}
```
