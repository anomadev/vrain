Un RDBMS (`Relational Database Management System`) es un sistema que almacena datos estructurados en tablas (filas y columnas) y define relaciones entre ellas usando claves primarias y foráneas. Estas relaciones permiten garantizar la integridad de los datos y realizar consultas complejas de forma sencilla.
- Beneficios: Ofrecen transacciones ACID, normalización, seguridad y facilidad para consultar datos relacionados.
- Limitaciones: suelen tener esquemas rígidos, escalar horizontalmente puede ser costoso y no manejan nativamente datos no estructurados como JSON tan eficientemente como las bases NoSQL.
 
---
### Conceptos Clave
##### Beneficios de un RDBMS
1. Flexibilidad
	- Puedes agregar, modificar o eliminar tablas y relaciones sin cambiar toda la base de datos.
	- Ejemplo práctico: agregar una columna a una tabla sin afectar las aplicaciones existentes.
2. `ACID Compliance` (Atomicidad, Consistencia, Aislamiento, Durabilidad)
	- Atomicidad: las transacciones se completan en su totalidad o no se ejecutan.
	- Consistencia: la base pasa de un estado válido a otro también válido.
	- Aislamiento: transacciones concurrentes no interfieren entre sí.
	- Durabilidad: una vez confirmada la transacción, los cambios persisten incluso tras un fallo.
3. Facilidad de uso: SQ: es un lenguaje declarativo estándar. Un programador puede aprenderlo rápidamente para hace consultas complejas, incluso si no es DBA.
4. Colaboración: Varios usuario pueden leer datos simultáneamente y con bloqueo a nivel de fila o tabla, evitar conflictividad al escribir.
5. Seguridad incorporada: Roles y permisos permiten restringir qué usuarios pueden leer o escribir en cada tabla o columna.
6. Normalización: Técnica para reducir redundancia y mejorar la integridad de datos, dividiendo la información en tablas relacionadas claras (por ejemplo, separar `Clientes` y `Pedidos`).
##### Limitaciones de un RDBMS
1. Esquema rígido:
	- Cambiar la estructura de tables (agregar/eliminar columnas, cambiar tipos) puede requerir bloqueos y mantenimiento.
	- Si necesitas almacenar datos semi-estructurados (JSON, XML) frecuentemente, el modelo relacional puede volverse complejo.
2. Escalabilidad horizontal limitada
	- Tradicionalmente diseñados para escalar verticalmente (más CPU/RAM en el mismo servidor).
	- Particionar (`sharding`) tablas manualmente es laborioso y puede requerir lógica extra en la aplicación.
3. Costo de transacciones complejas a gran escala: A medida que crecen los volúmenes (millones de filas), las operaciones ACID y los JOIN muy grandes pueden volverse lentos si no se indexa adecuadamente.
4. No óptimos para datos no estructurados: Si la aplicación maneja principalmente documentos, multimedia o grafos muy complejos, un RDBMS puro puede no ser la mejor opción.

---
### Ejemplos Prácticos
##### Integridad referencial con claves foráneas
`Escenario`: Tienes tablas de `clientes` y `pedidos`. Deseas asegurarte de que ningún pedido apunte a un cliente inexistente.
```sql
--- Tabla de clientes
CREATE TABLE clientes (
	cliente_id SERIAL PRIMARY KEY,
	nombre VARCHAR(100) NOT NULL,
	direccion TEXT
);

--- Tabla de pedidos, con FOREIGN KEY que referencia clientes(cliente_id)
CREATE TABLE pedidos (
	pedido_id SERIAL PRIMARY KEY,
	cliente_id INT NOT NULL, 
	producto VARCHAR(20),
	cantidad INT,
	fecha_pedido DATE DEFAULT CURRENT_DATE,
	CONSTRAINT fk_cliente
		FOREIGN KEY (cliente_id)
		REFERENCES clientes (cliente_id)
		ON DELETE RESTRICT
);
```
- `PRIMARY_KEY` en `clientes(cliente_id)` garantiza que cada cliente tiene un ID único.
- `FOREIGN_KEY` en `pedidos(cliente_id)` impide insertar un `pedido` con un `cliente_id` que no exista.
- `ON DELETE RESTRICT` no permite eliminar cliente si tiene pedidos asociados.
##### Normalización para evitar redundancia
`Escenario`: Antes de normalizar, estamos guardando el nombre de la ciudad en cada registro de cliente. Si el nombre de la ciudad cambia (o se escribe diferente), los datos quedan desactualizados.
```sql
--- Versión NO normalizada
CREATE TABLE clientes_raw (
	cliente_id SERIAL PRIMARY KEY,
	nombre VARCHAR(100),
	ciudad VARCHAR(50)   -- redundante si muchos clientes comparten ciudad
);

--- Insertar datos
INSERT INTO clientes_raw (nombre, ciudad)
VALUES ('María', 'Ciudad de México'),
       ('Luis',  'Ciudad de México'),
       ('Ana',   'Guadalajara');

-- Supón que "Ciudad de México" se actualiza a "CDMX":
UPDATE clientes_raw
SET ciudad = 'CDMX'
WHERE ciudad = 'Ciudad de México';

-- Ahora todos los registros se sincronizan.
```
`Problema`: Múltiples filas con "Ciudad de México" requieren mismo `UPDATE` si cambia el nombre oficial.
**Despues de normalizar:**
```sql
-- Tabla de ciudades
CREATE TABLE ciudades (
  ciudad_id    SERIAL PRIMARY KEY,
  nombre_ciudad VARCHAR(50) UNIQUE NOT NULL
);

-- Tabla de clientes que referencia ciudades
CREATE TABLE clientes (
  cliente_id   SERIAL PRIMARY KEY,
  nombre       VARCHAR(100),
  ciudad_id    INT NOT NULL,
  CONSTRAINT fk_ciudad
    FOREIGN KEY (ciudad_id)
    REFERENCES ciudades (ciudad_id)
);

-- Insertar ciudades
INSERT INTO ciudades (nombre_ciudad)
VALUES ('Ciudad de México'),
       ('Guadalajara');

-- Insertar clientes indicando ciudad_id en lugar de nombre
INSERT INTO clientes (nombre, ciudad_id)
VALUES ('María', 1),
       ('Luis',  1),
       ('Ana',   2);

-- Supón que "Ciudad de México" cambia a "CDMX":
UPDATE ciudades
SET nombre_ciudad = 'CDMX'
WHERE ciudad_id = 1;
```
- Ahora la información de la ciudad solo está en `ciudades`.
- Si cambia el nombre, se actualiza en una sola fila.
- Evita inconsistencias (`joins` rápidos y sin duplicados).
##### Esquema rígido y alteraciones costosas
`Escenario`: Tienes una tabla con mucho registros y decides cambiar el tipo de dato de una columna; durante el `ALTER TABLE`, la base bloqueará la tabla para reescribirla.
```sql
--- Tabla con muchos registros
CREATE TABLE inventario (
	producto_id SERIAL PRIMARY KEY,
	nombre VARCHAR(100),
	stock INT,
	description TEXT
);

--- Inicialmente, descripcion no admite más de 255 caracteres:
ALTER TABLE inventario
ALTER COLUMN descripcion TYPE VARCHAR(255); 
```
- La base de datos bloque `inventario` mientras copia/transforma datos.
- Para tablas con miles o millones de filas, puede generar `downtime` prolongado.
##### Escalabilidad horizontal compleja
`Escenario`: Quieres distribuir la carga de lecturas y escrituras entre varios servidores (`sharding`). En RDBMS tradicionales, no hay un mecanismo nativo simple; debes repartir manualmente las tablas según rangos, e implementar lógica en la aplicación para consultar el `shard` correcto.
```sql
--- Ejamplo conceptual de shard por rango de IDs
--- Shard 1: IDs de producto 1-100000
--- Shard 2: IDs de producto 100001 - 200000
---
--- No existe un comando SQL para "shard"
--- se hace configurando servidores distribuidos y rutas en la aplicación
```
- Debes mantener múltiples instancias de base de datos.
- La aplicación debe decidir a cuál conectarse según el `producto_id`.
- Aumenta la complejidad operativa y la posibilidad de errores.

