Las bases de datos relaciones (SQL) utilizan un esquema fijo de tables con filas y columnas conectadas por claves, ofreciendo transacciones ACID y relaciones claras. En contraste, las bases de datos NoSQL usan esquemas flexibles o sin esquemas, permitiendo almacenar datos no estructurados (JSON, pares clave-valor, grafos) y escalar horizontalmente más fácilmente.

---
### Conceptos Clave
1. Estructura de Datos
	- SQL (RDBMS): datos organizados en tablas con filas y columnas, cada tabla con un esquema estricto.
	- NoSQL: diversos modelos (documento, clave-valor, columna, grafo) que almacenan datos sin requerir un esquema fijo.
2. Esquemas vs Esquema Flexible
	- SQL: Debe definirse el esquema (tipos, longitud de columnas) antes de insertar datos (p. ej. `CREATE TABLE clientes (id INT PRIMARY KEY, nombre VARCHAR(50));`).
	- NoSQL: Permite insertar documentos con campos dinámicos sin definición previa.
3. Transaccionalidad (ACID) vs Eventual Consistencia
	- SQL: Cumple ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad). Ideal para datos financieros o donde la integridad es crítica.
	- NoSQL: Muchas implementaciones priorizan disponibilidad y particionado horizontal, logrando consistencia eventual en lugar de ACID puro.
4. Escalabilidad
	- SQL: Escalado vertical (aumentar recursos del mismo servidor). El escalado horizontal (`sharding`) es posible, pero requiere configuración manual y lógica extra en la aplicación.
	- NoSQL: Diseñadas para escalado horizontal nativo (añadir nodo), soportando altas cargas de lectura/escritura en clusters distribuidos.
5. Casos de Uso Típicos
	- SQL: Aplicaciones empresariales, sistemas bancarios, ERP, donde la integridad y las transacciones son fundamentales.
	- NoSQL: Aplicaciones con datos semiestructurados o sin estructura (logs, JSON, grandes volúmenes), sistemas en tiempo real, IoT, redes sociales.
6. Consultas y Modelado
	- SQL: Lenguaje declarativo (SELECT, JOIN, GROUP BY), ideal para consultas complejas entre múltiples tablas.
	- NoSQL: Cada tipo de base tiene su propio lenguaje (p. ej. MongoDB usa BSON y operadores específicos). No existe un estándar único como SQL.

---
### Ejemplos prácticos
##### Caso Relacional (SQL)
`Escenario`: Una tienda online que gestiona clientes, productos y pedidos. queremos consultas que unan tablas.
```sql
-- 1. Crear tablas relacionales
CREATE TABLE clientes (
  cliente_id   SERIAL PRIMARY KEY,
  nombre       VARCHAR(100) NOT NULL,
  email        VARCHAR(100) UNIQUE NOT NULL
);

CREATE TABLE productos (
  producto_id  SERIAL PRIMARY KEY,
  nombre       VARCHAR(100) NOT NULL,
  precio       DECIMAL(10,2) NOT NULL
);

CREATE TABLE pedidos (
  pedido_id    SERIAL PRIMARY KEY,
  cliente_id   INT NOT NULL,
  fecha_pedido DATE DEFAULT CURRENT_DATE,
  CONSTRAINT fk_cliente
    FOREIGN KEY (cliente_id)
    REFERENCES clientes(cliente_id)
    ON DELETE CASCADE
);

CREATE TABLE detalle_pedido (
  detalle_id   SERIAL PRIMARY KEY,
  pedido_id    INT NOT NULL,
  producto_id  INT NOT NULL,
  cantidad     INT NOT NULL,
  CONSTRAINT fk_pedido
    FOREIGN KEY (pedido_id)
    REFERENCES pedidos(pedido_id)
    ON DELETE CASCADE,
  CONSTRAINT fk_producto
    FOREIGN KEY (producto_id)
    REFERENCES productos(producto_id)
    ON DELETE RESTRICT
);
```
- Define un esquema fijo con relaciones entre `clientes`, `pedidos` y `productos`.
- Garantiza que un `pedido` siempre apunte a un `cliente` válido y que cada línea en `detalle_pedido` apunte aun `producto` y un `pedido`
- Si eliminas un cliente, todos sus pedidos también se eliminan (`ON DELETE CASCADE`).
**Consulta relacional para obtener detalles de pedidos:**
```sql
SELECT
  p.pedido_id,
  c.nombre AS cliente,
  pr.nombre AS producto,
  dp.cantidad,
  p.fecha_pedido
FROM pedidos p
JOIN clientes c   ON p.cliente_id   = c.cliente_id
JOIN detalle_pedido dp ON p.pedido_id = dp.pedido_id
JOIN productos pr ON dp.producto_id = pr.producto_id
WHERE c.email = 'juan@example.com';
```
- Une 4 tablas para listar todos los productos y cantidades de los pedidos realizados por Juan.
- Resalta la fuerza de `JOIN` en SQL para combinar datos estructurados.
##### Caso "NoSQL-like" con JSON en SQL
`Escenario`: Una aplicación que recibe datos de usuario en formato JSON, variable y con campos que cambian con frecuencia (p. ej. configuración de perfil, preferencias).
En NoSQL, podría almacenarse un documento completo con todos los parámetros. En SQL, simulamos esto usando una columna `JSONB` (PostgreSQL).
```sql
-- 1. Crear tabla con columna JSONB
CREATE TABLE usuarios (
  usuario_id SERIAL PRIMARY KEY,
  nombre     VARCHAR(100) NOT NULL,
  perfil     JSONB NOT NULL  -- almacena campos dinámicos de configuración
);

-- 2. Insertar datos con esquemas variados
INSERT INTO usuarios (nombre, perfil) VALUES
('Ana', '{"theme": "oscuro", "notificaciones": true}'),
('Luis', '{"theme": "claro", "notificaciones": false, "idioma": "es"}');

-- 3. Consultar todos los usuarios con notificaciones activas
SELECT
  usuario_id,
  nombre,
  perfil->>'theme'        AS tema,
  perfil->>'notificaciones' AS notificaciones
FROM usuarios
WHERE perfil->>'notificaciones' = 'true';
```
- La columna `perfil` permite guardar un documento JSON variable sin definir qué campos exactos tendrá.
- La consulta extrae datos dentro del JSON (`perfil->>'campo'`) y filtra por `notificaciones = true`.
Limitación:
- A pesar de la flexibilidad, no hay integridad referencial ni validación de esquemas para los campos internos de `perfil`. Si cambias el nombre de un campo (`notificaciones` a `notif`), las consultas deben actualizarse manualmente.
- Además, las consultas sobre JSON profundas (anidar arrays, funciones JSON) pueden ser menos eficientes que las consultas sobre columnas nativas.
##### Caso de Escalado Horizontal (Ilustración conceptual)
En SQL puro, el escalado horizontal (`sharding`) requiere dividir manualmente las tablas por rangos y dirigir consultas a distintos nodos. A continuación, un ejemplo conceptual (no un comando único en SQL, sino la estrategia):
```sql
-- Supongamos que queremos shardear la tabla pedidos en 2 nodos según pedido_id:

-- Nodo A: pedidos con ID entre 1 y 50000
-- Nodo B: pedidos con ID > 50000

-- En la práctica, configuraríamos dos instancias de PostgreSQL:
--   1) InstanciaA: contiene "pedidos" y "detalle_pedido" donde pedido_id <= 50000
--   2) InstanciaB: contiene "pedidos" y "detalle_pedido" donde pedido_id > 50000

-- La aplicación, antes de insertar o consultar, decidiría:
--   IF nuevo_pedido_id <= 50000 THEN conectar a InstanciaA
--   ELSE conectar a InstanciaB
```
- En RDBMS clásicos, no existe un solo comando SQL para `shardear` automáticamente
- Se requiere particionar manual y lógicamente los datos, manteniendo dos o más bases en paralelo.
- Esto añade complejidad en la capa de aplicación para enrutar consultas.
##### Escalado Horizontal Nativo (NoSQL)
Para compara, en MongoDB un coleccionista de documentos se `shardea` automáticamente por `shard key`. Ejemplo conceptual (pseudocódigo, NoSQL):
```javascript
// MongoDB (ilustración, NO SQL)
sh.enableSharding("miBaseDatos");
db.pedidos.createIndex({ pedido_id: 1 });
sh.shardCollection("miBaseDatos.pedidos", { pedido_id: 1 });
```
- MongoDB distribuye automáticamente los datos según rangos de `pedido_id` entre varios nodos.
- La aplicación no necesita lógica extra para decidir a qué nodo conectarse.
