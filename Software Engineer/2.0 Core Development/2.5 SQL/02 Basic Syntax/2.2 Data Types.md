Los tipos de datos en SQL definen la naturaleza y el formato de la información que puede almacenarse en una columna de una tabla. Elegir el tipo de dato adecuado:
- Valida que los valores insertados cumplan con el formato esperado (por ejemplo, que un campo de fecha solo acepte fechas)
- Optimiza el uso del espacio en disco y la memoria
- Mejora el rendimiento de las consultas y operaciones de índice

---
### Conceptos Clave
1. **Categorías principales de tipos de datos**
	- **Numéricos**: enteros y de punto flotante, exactos o aproximados.
	- **Fecha y hora**: fechas, horas, marcas de tiempo (`TIMESTAMP`).
	- **Cadenas de caracteres**: texto de longitud fija (`CHAR`) o variable (`VARCHAR`/`TEXT`).
	- **Unicode**: versiones de cadenas que soportan múltiples alfabetos (`NCHAR`, `NVARCHAR`).
	- **Binarios**: datos en formato binario (imágenes, archivos) (`BINARY`, `VARBINARY`, `BLOB`).
	- **Misceláneos**: tipos específicos según el proveedor (JSON, XML, UUID, etc.).
2. **Precisión vs. Espacio**
	- Para cantidades monetarias, usamos `DECIMAL(p,s)` o `NUMERIC(p,s)` para **precisión exacta**, evitando errores de redondeo.
    - `FLOAT`/`REAL` ofrecen **precisión aproximada** y se usan en cálculos científicos, pero no en finanzas.
3. **Longitud fija vs. variable**
	- `CHAR(n)`: reserva siempre _n_ bytes, incluso si la cadena es más corta. Útil para códigos de longitud fija (p. ej., “A1001”).
	- `VARCHAR(n)`: almacena hasta _n_ bytes y solo ocupa el espacio justo. Ideal para nombres, descripciones, etc.
4. **Rangos y límites de cada tipo**
	- `TINYINT` (0 a 255), `SMALLINT` (−32 768 a 32 767), `INT` (−2 147 483 648 a 2 147 483 647), `BIGINT` (±9×10^18).
	- Fechas en formato `YYYY-MM-DD` en `DATE`, horas en `HH:MI:SS` en `TIME`, y combinadas en `DATETIME` o `TIMESTAMP`.
5. **Compatibilidad entre gestores**
	- No todos los DBMS implementan los mismos tipos: MySQL no admite `CLOB`, Oracle no tiene `DATETIME` como tal, SQL Server usa `DATETIME2` en lugar de `TIMESTAMP`. Por ello, siempre verificar la documentación propia de cada motor.
6. **Uso de tipos especiales**
	- `JSON` o `JSONB` (en PostgreSQL) para datos semiestructurados.
	- `UUID` para identificadores únicos globales.
	- `ENUM` (MySQL) para valores limitados a un conjunto predefinido.

---
### Ejemplos Prácticos
##### Inventario de una tienda (Numéricos y Fecha)
`Escenario`: Queremos llevar el control de stock y precios de productos, así como la fecha en que llegaron al inventario.
```sql
CREATE TABLE Productos (
  ProductoID INT PRIMARY KEY,     -- Identificador único
  Nombre VARCHAR(100) NOT NULL,   -- Nombre variable hasta 100 caracteres
  Precio DECIMAL(10,2) NOT NULL,  -- Precio con 2 decimales, exacto
  Cantidad SMALLINT NOT NULL,     -- (valores entre -32 768 a 32 767)
  FechaIngreso DATE DEFAULT CURRENT_DATE  -- Fecha en formato YYYY-MM-DD
);
```
- `DECIMAL(10, 2)` para evitar errores de redondeo en montos monetarios
- `SMALLINT`: si la tienda nunca tendrá más de 32767 unidades por producto, ahorramos espacio frente a un `INT`
- `DATE`: almacenar solo la fecha de ingreso sin hora.
Insertar registros de ejemplo:
```php
INSERT INTO Productos (ProductoID, Nombre, Precio, Cantidad, FechaIngreso)
VALUES
  (1, 'Cafetera Eléctrica', 49.99,  25, '2025-05-10'),
  (2, 'Taza Cerámica',       5.50,  100, '2025-05-12'),
  (3, 'Filtro de Café',      3.75,  200, '2025-05-12');
```
##### Base de datos de empleados (Cadenas y Binarios)
`Escenario`: Guardamos información de empleados, incluyendo su nombre completo fecha de nacimiento y fotografía
```sql
CREATE TABLE Empleados (
  EmpleadoID INT PRIMARY KEY,        -- Identificador único
  NombreCompleto VARCHAR(100) NOT NULL,  -- Nombre variable (apellido largo)
  CorreoElectronico VARCHAR(150) UNIQUE NOT NULL, -- Correo con restricción de unicidad
  FechaNacimiento DATE NOT NULL, -- Solo fecha (YYYY-MM-DD)
  FotoPerfil BLOB NULL          -- Archivo binario para la foto (hasta varios MB)
);
```
- `VARCHAR(100)`: suficiente para nombres largos de hasta 100 caracteres
- `BLOB`: almacenar la imagen en formato binario; si el archivo supera cierto tamaño, conviene guardarlo externamente y almacenar solo la ruta.
Insertar con campo binario (pseudocódigo, asumiendo un `loader`)
```sql
-- Supongamos que tenemos una función para leer la foto como binario:
-- LOAD_FILE('/ruta/a/foto.jpg') devuelve VARBINARY en MySQL.

INSERT INTO Empleados (EmpleadoID, NombreCompleto, CorreoElectronico, FechaNacimiento, FotoPerfil)
VALUES
  (1, 'Ana Gómez', 'ana.gomez@empresa.com', '1990-07-15', LOAD_FILE('/fotos/ana_gomez.jpg')),
  (2, 'Luis Pérez', 'luis.perez@empresa.com', '1985-11-02', LOAD_FILE('/fotos/luis_perez.jpg'));
```
##### Reseñas de producto con JSON (Datos misceláneos)
`Escenario`: En vez de usar tablas normalizadas para reseñas, queremos almacenar la reseña completa como JSON (p. ej. comentario con lista de etiquetas) en un DBSM que permita JSON (ej. PostgreSQL).
```sql
CREATE TABLE Reseñas (
  ReseñaID   SERIAL PRIMARY KEY,
  ProductoID INT    NOT NULL,
  UsuarioID  INT    NOT NULL,
  Fecha      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,  -- Fecha y hora
  Contenido  JSONB  NOT NULL   -- Guarda texto, calificación y etiquetas
);
```
Ejemplo de inserción:
```sql
INSERT INTO Reseñas (ProductoID, UsuarioID, Contenido)
VALUES
  (
    1,
    101,
    '{"texto": "Excelente cafetera, hace muy buen café.", 
      "calificacion": 5, 
      "etiquetas": ["rápido", "fácil de usar", "buena relación calidad-precio"]}'
  ),
  (
    2,
    102,
    '{"texto": "La taza es frágil, se rompió a la primera.", 
      "calificacion": 2, 
      "etiquetas": ["frágil", "diseño bonito"]}'
  );
```
Consulta que extrae campo interno JSON
```sql
SELECT
  ReseñaID,
  Contenido->>'calificacion'    AS Calificación,
  Contenido->'etiquetas'->>0    AS PrimeraEtiqueta
FROM Reseñas
WHERE (Contenido->>'calificacion')::INT >= 4;
```
- Permite flexibilidad en el esquema de las reseñas
- Podemos indexar campos específicos (por ejemplo `calificacion`) usando índices GIN para consultas rápidas.
##### Fechas y horas en un sistema de reservas
`Escenario`: Una plataforma de reservaciones para un restaurante necesita almacenar la fecha y hora de cada reserva por separado y combinado.
```sql
CREATE TABLE Reservas (
  ReservaID     SERIAL PRIMARY KEY,
  MesaID        INT     NOT NULL,
  FechaReserva  DATE    NOT NULL,                    -- Solo fecha
  HoraReserva   TIME    NOT NULL,                    -- Solo hora
  CreadoEn      TIMESTAMP DEFAULT CURRENT_TIMESTAMP  -- Fecha y hora del registro
);
```
- `DATE`: para agrupar fácilmente por día o generar repostes diarios
- `TIME`: para verificar franjas horarias (p. ej. "18:30:00")
- `TIMESTAMP`: combina fecha y hora para auditoría o historiales
##### `Dumps` de sesión con `INTERVAL` (Datos misceláneos avanzados)
`Escenarios`: Queremos medir la duración de una sesión de usuario en un sitio web. Almacenar fecha de inicio, fecha de fin y calcular intervalo.
```sql
CREATE TABLE Sesiones (
  SesionID    SERIAL PRIMARY KEY,
  UsuarioID   INT    NOT NULL,
  Inicio      TIMESTAMP NOT NULL,
  Fin         TIMESTAMP NOT NULL,
  Duracion    INTERVAL GENERATED ALWAYS AS (Fin - Inicio) STORED
);
```
- `INTERVAL` calcula automáticamente la diferencia entre `Fin` e `Inicio`
- Útil para reportes de tiempos de conexión, análisis de uso, facturación por tiempo.
