`TRUNCATE TABLE` es una sentencia DDL (`Data Definition Language`) que elimina todas las filas de una tabla sin borrar su estructura (columnas, índices o restricciones). A diferencia de `DELETE`, que elimina fila por fila y genera registros en lo log `TRUNCATE` funciona internamente como la combinación de un `DROP TABLE` y un `CREATE TABLE`, liberando espacio de almacenamiento y restableciendo contadores de `auto-increment` (por ejemplo `SERIAL` o `AUTO_INCREMENT`).

> Analogía: imagina una habitación (tabla) llena de muebles (filas)
> Con `DELETE`, quitas mueble por mueble, guardando un inventario de cada objeto que retiras.
> Con `TRUNCATE`, vacías la habitación de golpe, tiras todos los muebles a la basura en un solo paso y dejas la habitación lista, como si la hubieras borrado y reconstruido sin muebles.

---
### Conceptos Clave
1. Rápido y no transaccional
	- `TRUNCATE TABLE` es más rápido que `DELETE FROM ...` porque no registra cada fila en el log, solo la desasignación de páginas de datos.
	- En la mayoría de motores, no puede deshacerse (no es completamente transaccional). Si se ejecuta dentro de una transacción, en muchos casos el comando hace un `COMMIT` implícito antes y después.
2. Restablece el contador de identidad
	- Si la tabla tiene una columna con `SERIAL` o `AUTO_INCREMENT`, `TRUNCATE` reinicia ese contador al valor inicial (normalmente 1).
	- Contrasta con `DELETE`, que deja el siguiente valor de identidad sin cambio (ej. si borras todo, el siguiente `INSERT` con ID autoincremental seguirá con el número que hubiera sido).
3. Mantiene la estructura y las restricciones
	- Tran truncar, la estructura de la tabla (columnas, tipos, índices, claves foráneas, triggers) permanece intacta.
	- No puede truncar una table referenciada por una clave foránea si no manejas primero la relación (por ejemplo, eliminando o truncando la tabla referenciada).
4. Permisos requeridos
	- Se considera un comando DDL, por lo que requiere privilegios de `ALTER` o `DROP` (dependiendo del motor)
	- No basta con permisos de `DELETE`: en muchos DBMS debes tener privilegio de `ALTER TABLE`.
5. Comparación con `DELETE` y `DROP`
	- `DELETE`: elimina fila a fila, registra cada eliminación y permite usar `WHERE`. Puede deshacerse si va dentro de una transacción (`ROLLBACK`). No reinicia contadores.
	- `TRUNCATE`: elimina todas las filas de un solo golpe, reinicia contadores, no registra fila a fila, no puede usar `WHERE`. Generalmente ejecuta `COMMIT` implícito.
	- `DROP`: elimina la tabla entera (estructura + datos), perdiendo índices, `constraints` y definiciones. Para volver a usarla hay que volver a crearla.
6. Bloqueos y rendimiento
	- `TRUNCATE` bloque la tabla completa (`table lock`), pero es muy eficiente porque solo desasigna páginas de datos.
	- En tablas muy grandes, `DELETE` con `WHERE` puede tardar mucho y llenar logs; `TRUNCATE` se recomienda cuando se quiere vaciar por completo.

---
### Ejemplos Prácticos
##### Vaciar una tabla de registros de eventos
`Escenario`: En un sistema de monitoreo, guardas eventos de sistema en la tabla `eventos_sistema` diariamente para estadísticas. A fin de mese quisiera vaciarla para empezar de cero.
```sql
-- Crear tabla de ejemplo
CREATE TABLE eventos_sistema (
  evento_id SERIAL PRIMARY KEY,
  fecha      TIMESTAMP NOT NULL,
  tipo       VARCHAR(50),
  detalles   TEXT
);

-- Insertar algunas filas de prueba
INSERT INTO eventos_sistema (fecha, tipo, detalles)
VALUES
  ('2025-05-01 08:00:00', 'INFO', 'Inicio de servicio'),
  ('2025-05-01 12:30:00', 'ERROR', 'Fallo en módulo X'),
  ('2025-05-02 09:15:00', 'WARN', 'Latencia alta');

-- Consultar cuántas filas hay antes de truncar
SELECT COUNT(*) AS total_eventos FROM eventos_sistema;
-- Resultado: total_eventos = 3

-- TRUNCATE TABLE para vaciar rápidamente
TRUNCATE TABLE eventos_sistema;

-- Consultar después de truncar
SELECT COUNT(*) AS total_eventos FROM eventos_sistema;
-- Resultado: total_eventos = 0
```
1. Crea la tabla `eventos_sistema` con `SERIAL` para `evento_id`
2. Inserta 3 eventos distintos
3. Con `TRUNCATE TABLE`, borra las 3 filas de un solo gesto, reiniciando el contador `evento_id` a 1
4. Tras ejecutar, `COUNT(*)` muestra 0 filas.
##### Reiniciar una tabla de usuario de prueba
`Escenario`: Tienes una tabla `usuarios_pruba` para datos de prueba internas que se poblaba automáticamente durante testing. Quieres eliminar todos los usuarios de prueba cada 24 horas.
```sql
-- Crear tabla de usuarios de prueba
CREATE TABLE usuarios_prueba (
  usuario_id   INT AUTO_INCREMENT PRIMARY KEY,
  nombre       VARCHAR(100),
  correo       VARCHAR(150),
  creado_en    DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Supón que tras pruebas hay cientos de filas:
-- Luego, al final del día, vacías la tabla:

TRUNCATE TABLE usuarios_prueba;
```
- Elimina todas las filas de `usuarios_prueba` en solo paso, y reinicia `usuario_id` a 1 para el siguiente ciclo de pruebas.
##### Diferencias entre `TRUNCATE` y `DELETE` (misma tabla)
`Escenario`: Compara temporalmente `DELETE` vs `TRUNCATE` en la tabla `clientes_temp`
```sql
-- Crear tabla de clientes temporales
CREATE TABLE clientes_temp (
  id   SERIAL PRIMARY KEY,
  nombre VARCHAR(50)
);

-- Insertar 1000 filas de prueba
INSERT INTO clientes_temp (nombre)
SELECT 'Cliente_' || generate_series(1, 1000);

-- 1) Usar DELETE
DELETE FROM clientes_temp;
-- Esto borra 1000 filas de a una y registra cada operación. El contador de SERIAL ahora está en 1001.

-- Insertar un nuevo registro para verificar el contador
INSERT INTO clientes_temp (nombre) VALUES ('NuevoCliente');
SELECT id FROM clientes_temp; 
-- Resultado: id = 1001

-- Volver a poblar la tabla
INSERT INTO clientes_temp (nombre)
SELECT 'Cliente_' || generate_series(1, 1000);

-- 2) Usar TRUNCATE
TRUNCATE TABLE clientes_temp;
-- Borra 1000 filas de un solo golpe y reinicia el contador.

-- Insertar un nuevo registro para verificar
INSERT INTO clientes_temp (nombre) VALUES ('OtroCliente');
SELECT id FROM clientes_temp;
-- Resultado: id = 1
```
- Con `DELETE` borras fila a fila, y el contador `SERIAL` no resetea (sigue aumentando)
- Con `TRUNCATE`, borras todas las filas y el contador regresa a 1.
##### Restricciones de clave foránea y `TRUNCATE`
`Escenario`: Intentas truncar la tabla `pedidos` que tiene clave foránea a `clientes`
```sql
-- Tabla clientes
CREATE TABLE clientes (
  cliente_id SERIAL PRIMARY KEY,
  nombre     VARCHAR(50)
);

-- Tabla pedidos con FK a clientes
CREATE TABLE pedidos (
  pedido_id  SERIAL PRIMARY KEY,
  cliente_id INT NOT NULL,
  producto   VARCHAR(100),
  FOREIGN KEY (cliente_id) REFERENCES clientes(cliente_id)
);

-- Insertar datos de ejemplo
INSERT INTO clientes (nombre) VALUES ('Ana'), ('Luis');
INSERT INTO pedidos (cliente_id, producto) VALUES (1, 'Libro'), (2, 'Película');

-- Intentar truncar pedidos sin preparar
TRUNCATE TABLE pedidos;
-- ERROR: no se puede truncar porque existe dependencia de clave foránea

-- Para permitir truncar, primero quitar la restricción o deshabilitarla:
ALTER TABLE pedidos DROP CONSTRAINT pedidos_cliente_id_fkey;

-- Ahora sí:
TRUNCATE TABLE pedidos;
```
1. Crea `clientes` y `pedidos`, donde `pedidos.cliente_id` referencia a `clientes(cliente_id)`
2. Al intentar `TRUNCATE TABLE pedidos`, el motor rechaza porque la FK impide eliminar filas sin respetar integridad referencial.
3. Con `ALTER TABLE ... DROP CONSTRAINT`, quitas la relación y luego puedes truncar `pedidos`.
