> [!info] HTTP Versions in API Design (Roadmap SH)
> El protocolo HTTP o Protocolo de Transferencia de Hipertexto es fundamental en el diseño de API. Las versiones HTTP especifican cómo deben empaquetarse los datos, así como cómo los servidores web y navegadores deben responder a los comandos. Comprender las diferentes versiones HTTP y sus características es esencial para los diseñadores de API, ya que afecta directamente la capacidad de una API para comunicarse con otro software y sistemas. Desde HTTP/1.0, la versión inicial de HTTP hasta HTTP/2 y la última versión HTTP/3, cada versión incorpora mejoras en velocidad, capacidades de transmisión de datos y seguridad. Seleccionar una versión HTTP adecuada es crucial para la eficiencia y el rendimiento de la API.

### Definición
HTTP (Protocolo de transferencia de Hipertexto) es un protocolo fundamental utilizado para las comunicaciones en la World Wide Web. Permite la carga de recursos, como documentos HTML, imágenes y videos. Las "Versiones HTTP" se refieren a las diferentes iteraciones y evoluciones de este protocolo, cada una introduciendo mejoras en rendimiento, seguridad y funcionalidad sobre su predecesora. Comprender su evolución es clave para entender cómo funciona la web moderna y cómo se optimizan las interacciones cliente-servidor.

### Conceptos Clave
##### HTTP/0.9 (El Protocolo de una Línea)
- Características: Extremadamente simple. Solicitudes consistían en una sola línea (ej. `GET /mipagina.html`).
- Limitaciones: Solo soportaba el método `GET`. No había cabeceras HTTP, ni códigos de estado, ni versionamiento. La respuesta era solo el archivo HTML.
##### HTTP/1.0 (Extensibilidad)
- Mejoras clave
	- Versioning: Introduce la información de la versión en las solicitudes (ej. `GET /mipagina.html HTTP/1.0`).
	- Cabeceras HTTP (`Headers`): Permite enviar metadatos tanto en la solicitud como en la respuesta (ej. `Content-Type`, `User-Agent`).
	- Códigos de Estado (`Status Code`): informan el resultado de la solicitud (ej. `200 OK`, `404 Not Found`).
	- Más métadatos: Introducción de `POST` y `HEAD` además de `GET`.
- Problema Principal: Por defecto, abría una nueva conexión TCP para cada par solicitud/respuesta, lo cual era ineficiente (alto `overhead` de establecimiento de conexión).
##### HTTP/1.1 (El Estándar Duradero)
- **Mejoras Clave**:
	- **Conexiones Persistentes (`Persistent Connections/Keep-Alive`)**: La mejora más significativa. Permite múltiples solicitudes/respuestas sobre la misma conexión TCP, reduciendo la latencia. Habilitadas por defecto.
	- **`Pipelining`**: Permite a un cliente enviar múltiples solicitudes a través de una conexión persistente sin esperar la respuesta de cada una. Sin embargo, su implementación fue problemática y propensa a errores (`Head-of-Line Blocking`).
	- **Cabecera `Host`**: Obligatoria. Permite el alojamiento virtual (múltiples dominios en la misma dirección IP).
	- **Mejoras en `Caching`**: Más control sobre el almacenamiento en caché (ej. `Cache-Control`).
	- **`Transfer Encoding (Chunked Transfers)`**: Permite enviar contenido en fragmentos, útil cuando el tamaño total no se conoce de antemano.
	- **`Byte Rangers`**: Permite solicitar solo partes de un recurso (ej. reanudar descargas).
- **Problema Principal: `Head-of-Line (HOL) Blocking`**: Si una solicitud en la cola se retrasa, bloque todas las solicitudes posteriores en la misma conexión, incluso si esas respuestas podrían estar listas. El `pipelining` intentó solucionar esto pero tenía sus propios problemas. 
##### HTTP/2 (Optimización del Rendimiento)
- **Objetivo Principal**: Abordar las limitaciones de rendimiento de HTTP/1.1, especialmente el `HOL Blocking` a nivel de aplicación.
- **Mejoras Clave**:
	- **Multiplexación (`Multiplexing`)**: Permite múltiples flujos de solicitudes/respuesta simultáneamente sobre una única conexión TCP, sin que se bloqueen entre sí. Es la característica estrella.
	- **Protocolo Binario (`Binary Protocol`)**: En lugar de texto plano, HTTP/2 utiliza tramas binarias. Más eficientes de parsear, menos propenso a errores y más compacto.
	- **Compresión de Cabeceras (`HPACK`)**: Reduce significativamente el `overhead` de las cabeceras HTTP, que pueden ser redundantes en múltiples solicitudes.
	- **`Server Push`**: Permite al servidor enviar proactivamente recursos que sabe que el cliente necesitará (ej. enviar `style.css` y `script.js` junto con `index.html` sin que el cliente los solicite explícitamente).
- **Limitación Persistente**: Aunque resuelve el `HOL Blocking` a nivel de aplicación, aún depende de TCP. Si un paquete TCP se pierde, todas las transacciones multiplexadas en esa conexión TCP se detienen hasta que se recupera el paquete (`HOL blocking` a nivel de transporte).
##### HTTP/3 (El Futuro sobre QUIC)
- **Objetivo Principal**: Superar las limitaciones de TCP, especialmente `HOL blocking` a nivel de transporte, y mejorar el rendimiento en redes con pérdida de paquetes.
- **Mejoras Clave**
	- **Sobre QUIC (`Quick UDP Internet Connections`)**: HTTP/3 no usa TCP, sino QUIC, un nuevo protocolo de transporte que se ejecuta sobre UDP.
	- **Multiplexación Integrada en QUIC**: QUIC maneja los flujos de forma independiente, por lo que la pérdida de un paquete en un flujo no afecta a los demás. Esto elimina efectivamente el `HOL blocking` a nivel del transporte.
	- **Establecimiento de Conexión más Rápido**: QUIC a menudo combina el `handshake` de transporte y el cifrado (`TLS`), reduciendo los viajes de ida y vuelta (`RTTs`) necesarios para establece una conexión segura. 
	- **Cifrado Integrado (`TLS 1.3` o superior)**: QUIC integra TLS, haciendo que el cifrado sea una parte fundamental y obligatoria del protocolo, mejorando la seguridad.
	- **Mejor Control de Congestión**: Algoritmos de control de congestión más avanzados y flexibles.
	- **Migración de Conexión**: Permite que las conexiones persistan incluso si el cliente cambia de dirección IP (ej. al cambiar de `Wi-Fi` a datos móviles).

### Ejemplos Prácticos
- **HTTP/1.0:** Si cargas una página web con 10 imágenes, se necesitarían 11 conexiones TCP (1 para el HTML, 10 para las imágenes). Lento.
- **HTTP/1.1:** Con conexiones persistentes, esas 11 solicitudes podrían usar una sola conexión TCP secuencialmente (o unas pocas en paralelo si el navegador abre múltiples conexiones). Mucho más rápido, pero el `HOL blocking` podría ralentizar la carga si un recurso tarda mucho. Los navegadores suelen abrir múltiples conexiones (ej. 6 por host) para mitigar esto, pero es una solución parcial.
- **HTTP/2:** Todas las solicitudes para los 11 recursos (HTML + imágenes) pueden enviarse sobre una única conexión TCP de forma concurrente. Los recursos pequeños no esperan a los grandes. El `Server Push` podría incluso enviar las imágenes junto con el HTML si el servidor lo considera apropiado. Resultado: carga de página significativamente más rápida.
```js
// Conceptual: HTTP/2 allows concurrent streams over one connection 
// Connection: [Client] <---TCP Connection---> [Server] 
// Stream 1: Request HTML -> Response HTML 
// Stream 2: Request CSS -> Response CSS 
// Stream 3: Request JS -> Response JS 
// (All happening "at the same time" over the single connection)
```
- **HTTP/3:** Similar a HTTP/2 en cuanto a multiplexación, pero si estás en una red móvil con algo de pérdida de paquetes, la pérdida de un paquete de una imagen no detendrá la descarga del HTML u otras imágenes que viajan en flujos diferentes dentro de la misma conexión QUIC. Las conexiones también se establecen más rápido.

### Notas
- **La importancia de la multiplexación:** Es el concepto central para entender el salto de HTTP/1.1 a HTTP/2. Cambió radicalmente cómo se gestionan las solicitudes.
- **TCP como cuello de botella:** HTTP/2 hizo un gran trabajo, pero estaba limitado por las características inherentes de TCP. HTTP/3, al cambiar a QUIC (sobre UDP), busca romper esas barreras.
- **Impacto en el diseño de APIs:** Aunque las versiones de HTTP son más sobre el "transporte" de las llamadas API, las mejoras de rendimiento (especialmente en HTTP/2 y HTTP/3) significan que las APIs pueden ser más responsivas y manejar más solicitudes eficientemente, lo que puede influir en cómo se diseñan los payloads o se gestionan las interacciones cliente-servidor.