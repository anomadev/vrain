> [!info] HTTP Headers in API Design (Roadmap SH)
> Los encabezados HTTP juegan un papel crucial en el diseño de API ya que proporcionan información esencial entre el cliente y el servidor con respecto a los datos que se intercambiarán. Los encabezados son parte del mensaje de solicitud y respuesta HTTP, con tipos que incluyen encabezados estándar, no estándar, comunes o poco comunes. Pueden definir parámetros como el tipo de contenido, la autenticación, el estado de la respuesta, las cookies y más. Comprender y utiliza eficazmente los encabezados HTTP es fundamental para diseñar API robustas y seguras. Un conjunto de encabezados bien definido garantiza un intercambio de datos exitoso, maneja los errores con elegancia y mejora la comunicación general entre el cliente y el servidor.

### Definición
Las cabeceras HTTP (`HTTP Headers`) son pares de clave-valor que se transmiten tanto en los mensajes de solicitud como en los de respuesta HTTP. Su propósito es proporcionar metadatos e información contextual sobre el mensaje. Permiten que el cliente y el servidor se comuniquen y negocien sobre aspectos como el formato de los datos, la autenticación, el almacenamiento en caché y el manejo de la conexión, sin afectar el cuerpo (`payload`) del mensaje en sí.

### Conceptos Clave
Las cabeceras se pueden clasificar según su contexto, aunque una misma cabecera puede pertenecer a más de una categoría.
- **Cabeceras de Solicitud (`Request Headers`)**: Contienen más información sobre el recurso a obtener o sobre el cliente que realiza la solicitud.
- **Cabeceras de Respuestas (`Response Headers`)**: Contienen información adicional sobre la respuesta, como la ubicación del recurso o sobre el servidor que la proporciona.
- **Cabeceras de Representación (`Representation Headers`)**: Describen la representación (el formato y la codificación) de los datos en el cuerpo del mansaje. Anteriormente se llamaban "`Entity Headers`".
- **Cabeceras de Carga Útil (`Payload Headers`)**: Describe la carga útil en sí, independientemente de la representación del mensaje, como el `Content-Length`.
#### Cabeceras Esenciales
##### Cabeceras de Negociación de Contenido
- **`Accept` (Solicitud)**: Le dice al servidor qué tipo(s) de contenido (`MIME types`) puede entender el cliente. Ej. `Accept: application/json`.
- **`Content-Type` (Solicitud/Respuesta)**: Especifica el tipo de contenido del cuerpo del mensaje. Es fundamental en `POST`/`PUT` y en respuestas con cuerpo. Ej. `Content-Type: application/json`.
##### Cabeceras de Autenticación
- **`Authorization` (Solicitud)**: Contiene las credenciales para autenticar al cliente ante el servidor. Es la cabecera más común para enviar tokens (ej. `Bearer`, `Basic`). Ej. `Authorization: Bearer <jwt_token>`.
- **`WWW-Authenticate` (Respuesta)**: Enviada con una respuesta `401 Unauthorized`, indica qué método de autenticación se requiere. Ej. `WWW-Authenticate: Bearer realm="example"`.
##### Cabeceras de Caching
- **`Cache-Control` (Solicitud/Respuesta)**: Contiene directivas para el almacenamiento en caché. Permite un control muy granular. Ej. `Cache-Control: no-cache, max-age=3600`.
- **`ETag` (Respuesta)**: Un identificador único para una versión específica de un recurso. Se usa para validación de caché.
- **`If-None-Match` (Solicitud)**: El cliente envía el valor `ETag` que tuene. Si coincide con el `ETag` actual del servidor, este puede responder con un `304 Not Modified`.
##### Otras Cabeceras Importantes
- **`Location` (Respuesta)**: Se usa para indicar la URL a la que se debe redirigir el cliente (en respuestas `3xx`) o la URL de un recurso recién creado (en respuestas `201 Created`).
- **`User-Agent` (Solicitud)**: Una cadena que identifica el agente de usuario (navegador, cliente, HTTP, etc.) que realiza la solicitud.
- **`Host` (Solicitud)**: Especifica el nombre de dominio del servidor (y opcionalmente el puerto). El obligatoria en `HTTP/1.1` y posteriores.
- **`Content-Length` (Solicitud/Respuesta)**: Indica el tamaño del cuerpo del mensaje en bytes.

### Ejemplos Prácticos
##### Solicitud del Cliente (Crear un post en un blog)
El cliente quiere crear un nuevo post. Le dice al servidor que está enviando JSON (`Content-Type`), que puede aceptar JSON de vuelta (`Accept`), y que está autorizado con token (`Authorization`).
```http
POST /api/posts HTTP/1.1
Host: my-awesome-api.com
User-Agent: MyApiClient/1.0
Accept: application/json
Content-Type: application/json
Content-Length: 57
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

{
  "title": "Understanding HTTP Headers",
  "content": "..."
}
```
##### Respuesta del Servidor (Post creado exitosamente)
El servidor responde que el post fue creado (`201 Created`), indica la ubicación del nuevo recurso (`Location`), confirma que está devolviendo JSON (`Content-Type`), y especifica su propio software (`Server`).
```http
HTTP/1.1 201 Created
Date: Mon, 09 Jun 2025 19:21:28 GMT
Server: Nginx/1.18.0
Content-Type: application/json
Location: /api/posts/987
Cache-Control: no-cache
ETag: "w/xyz123"

{
  "id": 987,
  "title": "Understanding HTTP Headers",
  "message": "Post created successfully."
}
```

### Notas
- Mientras que los métodos son los verbos y las URIs los sustantivos, las cabeceras son los adjetivos y adverbios que añaden todo el contexto y matiz. Una API bien diseñada hace un uso extensivo y semántico de las cabeceras.
- **Dominar la negociación de contenido es fundamental**: Usar `Accept` y `Content-Type` correctamente permite que tu API evolucione. Podrías soportar `application/json` hoy y `application/vnd.api+json` mañana, y los clientes bien construidos podrán negociar la versión que entienden.
- **El caching es tu mejor aliado de rendimiento**: Entender a fondo `Cache-Control`, `ETag`, `Expires`, etc., es una de las habilidades más importantes para diseñar APIs rápidas y escalables. Una estrategia de caché inteligente puede reducir drásticamente la carga del servidor.