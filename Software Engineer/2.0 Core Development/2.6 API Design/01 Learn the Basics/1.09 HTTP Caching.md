> [!info] HTTP Caching in API Design (Roadmap SH)
> El almacenamiento en caché HTTP es un aspecto clave del diseño de API que implica almacenar copias de las respuestas a las solicitudes HTTP para acelerar las solicitudes futuras. Cuando una API recibe la misma solicitud varias veces, en lugar de procesar cada solicitud por separado, puede utilizar una respuesta previamente almacenada, mejorando así el rendimiento y la eficiencia. La memoria caché está gobernada por los encabezados de las solicitudes y respuestas HTTP. Comprender e implementar el almacenamiento en caché HTTP en el diseño de API puede reducir drásticamente la latencia, el tráfico de red y mejorar la velocidad de una API.

### Definición
El `Caching HTTP` es el proceso de almacenar temporalmente copias de recursos web (como respuestas de API, imágenes o páginas) para poder reutilizarlas en solicitudes posteriores. El objetivo principal es evitar la necesidad de volver a generar y transferir datos que no han cambiado, lo que resulta en una mejora significativa del rendimiento (respuestas más rápidas), una reducción de la carga en el servidor y un menor consumo de ancho de banda. Es una de las características más importantes del protocolo HTTP para construir aplicaciones rápidas y escalables.

### Conceptos Clave
Existen dos estrategias principales de `caching` que funcionan en conjunto:
##### `Caching` por expiración (`Freshness`)
- **Concepto**: El servidor le dice al cliente (o a un caché intermedio) durante cuánto tiempo puede considerar "fresca" una respuesta y usarla sin volver a consultar al servidor.
- **Cabecera principal**: `Cache-Control`. Esta cabecera es la más moderna y potente para controlar la expiración.
- **Directivas clave de `Cache-Control`**:
	- `max-age-=<segundos>`: Especifica la duración máxima que una respuesta puede ser considerada fresca. Ej.: `max-age=3600` (1 hora).
	- `private`: La respuesta es para un solo usuario y no debe ser almacenada por cachés compartidos (como un proxy o CDN). Típico para datos de usuario personalizados.
	- `public`: La respuesta puede ser almacenada por cualquier caché.
	- `no-store`: La dice al caché que no almacene esta respuesta bajo ninguna circunstancia. Se usa para datos extremadamente sensibles.
	- `no-cache`: Significa que el cliente debe revalidar la respuesta con el servidor antes de usar una versión cacheada. Obliga al uso de la estrategia de validación.
- Cabecera antigua: `Expires`. Especifica una fecha y horas exactas de expiración. `Cache-Control` tiene precedencia si ambas están presentes.
##### `Caching` por validación (`Revalidation`)
- **Concepto**: Una vez que una respuesta cacheada expira (deja de ser "fresca"), el caché no la descarta. En su lugar, le pregunta al servidor si la versión que tiene sigue siendo válida.
- **Funcionamiento**: Si la versión sigue siendo válida, el servidor responde con un código de esta `304 Not Modified` y un cuerpo vacío. El cliente entonces utiliza la copia que ya tenía en su caché. Esto ahorra el ancho de banda de no tener que volver a descargar el recurso completo.
- **Mecanismos de Validación (`Validators`)**:
	- `ETag` / `If-None-Match` (preferido):
		1. El servidor envía la respuesta con una cabecera `Etag` (`Entity Tag`), que es un identificador único para la versión específica del recurso (como un hash del contenido).
		2. Cuando el cliente necesita revalidar , envía la solicitud con una cabecera `If-None-Match` que contiene el `ETag` que contiene.
		3. El servidor compara el `ETag` del cliente con el actual. Si coinciden, responde `304`. Si no, responde `200 OK` con el nuevo recurso y el nuevo `ETag`.
	- `Last-Modified` / `If-Modified-Since`:
		1. El servidor envía la respuesta con una cabecera `Last-Modified`, que contiene la fecha y hora de la última modificación del recurso.
		2. Para revalidar, el cliente envía esa fecha en la cabecera `If-Modified-Since`.
		3. El servidor compara la fecha. Si el recurso no ha sido modificado desde entonces, responde `304`.

### Ejemplos Prácticos
##### Flujo de Caching por Expiración
Un cliente solicita una lista de productos que no cambia muy a menudo.

`Primera Solicitud:`
```http
GET /api/products HTTP/1.1
Host: mi-tienda.com
```

`Respuesta del Servidor (con Cache-Control)`
```http
HTTP/1.1 200 OK
Cache-Control: private, max-age=600
ETag: "v1-abcdef123456"
Content-Type: application/json

{ "id": 123, "name": "Diana Prince", "email": "diana@example.com" }
```
**Segunda Solicitud (dentro de la próxima hora)**: El navegador ve que tiene una copia "fresca" en su caché. No se realiza ninguna solicitud de red. La respuesta es servida instantáneamente desde el caché local.
##### Flujo de Caching por Validación (con `ETag`)
El cliente solicita el perfil de un usuario. La copia en caché ha expirado.

`Primera Solicitud`
```http
GET /api/users/123 HTTP/1.1
Host: mi-api.com
```

`Respuesta del Servidor (con ETag)`
```http
HTTP/1.1 200 OK
Cache-Control: private, max-age=600
ETag: "v1-abcdef123456"
Content-Type: application/json

{ "id": 123, "name": "Diana Prince", "email": "diana@example.com" }
```

**Segunda Solicitud (después de 10 minutos, el caché ha expirado)**: El navegador envía la solicitud, pero incluye la cabecera `If-None-Match` para revalidar.
```http
GET /api/users/123 HTTP/1.1
Host: mi-api.com
If-None-Match: "v1-abcdef123456"
```

**Respuestas del Servidor (el perfil no ha cambiado)**: El servidor ve que el `ETag` coincide. Responde con `304 Not Modified`.
```http
HTTP/1.1 304 Not Modified
Cache-Control: private, max-age=600
ETag: "v1-abcdef123456"

(Cuerpo de la respuesta vacío)
```
El navegador ahora sabe que su copia es válida por otros 10 minutos y la muestra al usuario.
### Notas
- **El `caching` no es un extra, es parte de la arquitectura**: Una estrategia de `caching` bien pensada es una de las formas más baratas y efectivas de hacer que una API escale. Debe ser una consideración desde las primeras fases del diseño, no un parche de última hora.
- **Aplica `caching` agresivamente a recurso públicos**: Los `endpoints` que devuelven datos públicos e inmutables (o que cambian con poca frecuencia) son candidatos perfectos para un `max-age` largo. Piensa en listas de países, categorías de productos, etc. Esto puede descargar una cantidad masiva de trabajo a `CDNs` y cachés de navegador.
- **Distingue claramente los datos públicos de los privados**: Usa `Cache-Control: public` para recursos que son iguales para todos y `Cache-Control: private` para datos específicos de un usuario (ej. `/api/me/profile`). Mezclar esto es una receta para fugas de datos.
- Una API bien cacheada es una API feliz: Al reducir las solicitudes que realmente golpean tu lógica de aplicación y tu base de datos, no solo mejoras la experiencia del usuario, sino que también reduces tus costos de infraestructura. el estado `304 Not Modified` es tu mejor amigo para logar un balance entre datos frescos y rendimiento.