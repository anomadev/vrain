## Definición
REST (Representational State Tranfer) no es un protocolo ni un estándar, sino un estilo arquitectónico para sistemas distribuidos de hipermedia. Introducido por Roy Fielding en su tesis doctoral (2000), un sistema es considerado `RESTful` cuando cumple con una serie de restricciones (`constraints`) que permiten que la web sea escalable, resiliente y eficiente. Se basa en la manipulación de recursos a través de sus representaciones utilizando los métodos estándar de HTTP.

## Conceptos Clave
- **`Uniform Interface (Interfaz Uniforme)`**: Es el pilar central. Los recursos se identifican de forma única mediante `URIs`, se manipulan mediante representaciones (`JSON/XML`), los mensajes son auto-descriptivo y se utiliza `HATEOAS` (Hypermedia as the Engine of Application State) para navegar el estado de la aplicación.
- **`Stateless` (Sin estado)**: El servidor no guarda ninguna sesión del cliente. Cada solicitud debe contener toda la información necesaria para ser procesada. Esto facilita la escalabilidad horizontal.
- `Client-Server`: Separación de preocupaciones. El cliente se encarga de la interfaz de usuario y el servidor del almacenamiento y lógica, permitiendo que ambos evolucionen de forma independiente.
- `Cacheable`: Las respuestas deben definirse explícitamente como cacheables o no para mejorar el rendimiento y reducir la latencia.
- **`Layered System` (Sistema de Capas)**: El cliente no puede saber si está conectado directamente al servidor final o a un intermediario (balanceador, proxy, CDN).
- `Code on Demand` (Opcional): El servidor puede enviar código ejecutable al cliente (como scripts de JS) para ampliar su funcionalidad.
**Recursos vs. Verbos**: En `REST`, el recurso es el sustantivo (`/users`) y el método `HTTP` es el verbo (`GET`, `POST`).

## Ejemplos Prácticos 
Una estructura de `API RESTful` siempre debe centrarse en los sustantivos y la jerarquía de recursos:
```bash
# Good: Resource-based URLs
GET    /users              # List all users
POST   /users              # Create a new user
GET    /users/123          # Get details of user 123
PUT    /users/123          # Replace user 123
PATCH  /users/123          # Partially update user 123
DELETE /users/123          # Remove user 123

# Bad: Action-based URLs (RPC style)
GET    /getAllUsers
POST   /createUser
POST   /updateUser?id=123
```
**Representación JSON (`Self-descriptive message`):** 
```json
// GET /users/123
{
  "id": 123,
  "name": "G",
  "role": "Software Architect",
  "_links": { // HATEOAS example
    "self": { "href": "/users/123" },
    "orders": { "href": "/users/123/orders" }
  }
}
```

## Analogía
Imagina una **Máquina Expendedora**.
- **Recurso**: el producto (un refresco).
- **Interfaz Uniforme**: Siempre usas el mismo panel de botones y el mismo ranurado para monedas, no importa si vas a comprar papas o refrescos.
- `Stateless`: A la máquina no le importa quién eres ni qué compraste ayer. Introduces el dinero y el código, y ella te da el producto. Si quieres otro, tienes que volver a introducir el dinero y el código.
- **Representación**: No te llevas el inventario de la máquina, te llevas una lata (la representación del refresco).

## Buenas Prácticas
- **Usa sustantivos en plural**: `/customers` es mejor que `/customer`.
- **Jerarquía lógica**: `/authors/45/books` para recursos anidados.
- **Versionado en la cabecera o URL**: `/v1/users` o mediante el `Accept` `header`.
- **Manejo de errores**: Usa siempre los códigos de estado `HTTP` adecuados (ej. `400` para errores de validación, no `200` con un mensaje de error.)
- **Limita el anidamiento**: No vayas más allá de dos o tres niveles (ej. `/users/1/posts/2/ comments` es aceptable, más de eso se vuelve difícil de mantener).

## Notas Personales
- Muchos desarrolladores dicen hacer "`REST`" pero solo están haciendo "`HTTP` con `JSON`". Para que sea `REST` real, debe cumplir con `HATEOAS` y la interfaz uniforme.
- La escalabilidad que ofrece `REST` gracias al `Stateless` y al `Caching` es lo que permitió que la web creciera al nivel actual.
- Como Arquitecto, mi punto crítico es: no fuerces `REST` si tu sistema requiere una comunicación pesada en tiempo real o transacciones complejas; para eso existen alternativas como `WebSockets` o `gRPC`.
