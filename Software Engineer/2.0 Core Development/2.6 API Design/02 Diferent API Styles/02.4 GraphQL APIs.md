## Definición
`GraphQL` es un lenguaje de consulta para `APIs` y un tiempo de ejecución (*`runtime`*) para completar esas consultas con tus datos existentes. A diferencia de `REST`, que se centra en recursos alojados en múltiples `URLs`, `GraphQL` permite a los cliente solicitar exactamente los datos que necesitan y nada más, utilizando un único punto de entrada (*`endpoint`*). Proporciona una descripción completa y comprensible de los datos en tu `API`, facilitando la evolución de la misma con el tiempo sin necesidad de versionado.

## Conceptos Clave
- **`Typed Schema`**: El contrato central donde describes todos los tipos de datos posibles y sus relaciones mediante el *`Schema Definition Language (SDL)`*.
- **`Single Endpoint`**: Todas las interacciones ocurren a través de una sola `URL` (normalmente `/graphql`), eliminando la complejidad de gestionar decenas de rutas.
- **`Operations`**:
	- **`Queries`**: Para lectura de datos (equivalente a `GET`).
	- **`Mutations`**: Para modificar datos (equivalente a `POST`, `PUT`, `DELETE`).
	- **`Subscriptions`**: Para actualizaciones en tiempo real basadas en eventos.
- **`Declarative Data Fetching`**: El cliente define la "forma" del `JSON` que espera recibir, evitando el `Over-fetching` (recibir datos de más) y el `Under-fetching` (tener que hacer múltiples llamadas para completar una vista).
- **`Resolves`**: Funciones en el servidor que se encargan de obtener los datos reales para cada campo definido en el esquema.
- **`Introspection`**: La capacidad de la `API` para describirse a sí misma, lo que permite herramientas de autocompletado y documentación automática (como `GraphiQL`).

## Ejemplos Prácticos
##### Defining a Schema (`SDL`)
```graphql
type Creator {
  id: ID!
  name: String
  videos: [Video] # Relationship: One-to-Many
}

type Video {
  id: ID!
  title: String
  duration: Int
  creator: Creator # Relationship: Belongs-To
}

type Query {
  video(id: ID!): Video
  allVideos: [Video]
}
```
##### Executing a Query (Client side):
El cliente solicita solo el título y el nombre del creador, ignorando el resto de los campos.
```graphql
query GetVideoDetails($videoId: ID!) {
  video(id: $videoId) {
    title
    creator {
      name
    }
  }
}
```
##### Response (`JSON`)
```json
{
  "data": {
    "video": {
      "title": "GraphQL Explained in 100 Seconds",
      "creator": {
        "name": "Fireship"
      }
    }
  }
}
```

## Analogía
Imagina que vas a un **Restaurante de Comida Rápida (`REST`)**: pides el "Combo #1" y recibes una hamburguesa, papas y refresco, quieras las papas o no (`Over-fetching`). Si quieres un postre, tiene que hacer otra file (`Under-fetching`).
**`GraphQL`** es como un **Buffet Personalizado con un Mesero Inteligente**: Le das una lista exacta de lo que quieres: "Quiero 2 trozos de pizza, 1 hora de lechuga y media naranja". El mesero va, recolecta exactamente eso de diferentes estaciones y te lo trae todo en un solo plato, perfectamente organizado.

## Buenas Prácticas
- **`Business Logic in Service Layer`**: No pongas la lógica de negocio dentro de los *`Resolvers`*. Estos deben ser delgados y delegar la lógica a una capa de servicios o modelos.
- **`Use Dataloader`**: Para evitar el problema de consultas $N+1$ (donde se ejecutan múltiples consultas a la DB por cada elemento de una lista), utiliza una librería de *`batching`* y *`catching`* como `DataLoader`.
- **`Strongly Typed Input Objects`**: Usa tipos `input` específicos para las mutaciones en lugar de pasar muchos argumentos sueltos; esto mejora la legibilidad y el mantenimiento.
- **`Pagination`**: Implementa paginación basada en cursor (*`Connections`*) en lugar de *`offset`* para manejar grandes volúmenes de datos de forma eficiente.
- **`Versioning by Deprecation`**: En lugar de crear `/v2`, añade nuevos campos y marca los antiguos con la directiva `@deprecated`. `GraphQL` permite que ambos coexistan sin romper clientes existentes.

## Notas Personales
- `GraphQL` otorga un poder enorme al `frontend`, lo cual es excelente para la agilidad, pero requiere que como arquitecto pongas mucha atención en el `Cost Analysis` de las `queries`. Un cliente malicioso podría solicitar una `query` profundamente anidada que tumbe el servidor.
- La implementación de `Catching` es más compleja que en `REST` (donde puedes cachear por `URL`). En `GraphQL`, el cacheo suele ocurrir a nivel de objeto o mediante el uso de clientes inteligentes como `Apollo` o `Relay`.
- Para un proyecto de lógica de negocio compleja, la combinación de una arquitectura limpia en el `backend` y `GraphQL` como capa de transporte es imbatible en términos de experiencia de desarrollador (`DX`).
