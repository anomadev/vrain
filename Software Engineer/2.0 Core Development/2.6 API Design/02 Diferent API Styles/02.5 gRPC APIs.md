## Definición
`gRPC` es un framework de alto rendimiento, de código abierto y desarrollado originalmente por Google, que permite la comunicación entre servicios utilizando el modelo de Llamada a Procedimiento Retomo (`RPC`). A diferencia de `REST`, que se basa en recursos y verbos `HTTP`, `gRPC` permite que una aplicación cliente llame directamente a un método en un servidor remoto como si fuera una función local. `Protocol Buffers (Protobuf)` para la serialización de datos y `HTTP/2` como protocolo de transporte, lo que lo hace extremadamente eficiente en términos de latencia y ancho de banda.

## Conceptos Clave
- **`Protocol Buffers (Protobuf)`**: Actúa tanto como `Interface Definition Language (IDL)` como un formato de serialización. Es binario, tipado y mucho más compacto que `JSON`.
- **`HTTP/2`**: El motor de transporte que habilita el `Multiplexing` (múltiples llamadas sobre una misma conexión `TCP`), comprensión de cabeceras (`HPACK`) y `Binary Framing`.
- `Service Definition`: Se define en archivos `.proto` donde se especifican los métodos y los tipos de mensajes de entrada/salida.
- **`4 tipos de RPC`**:
	- **`Unary`**: Un `request`, un `response` (estilo tradicional).
	- **`Server Streaming`**: El cliente envía un `request` y el servidor devuelve el flujo de mensajes.
	- **`Cliente Streaming`**: El cliente envía un flujo de mensajes y el servidor responde con un solo.
	- **`Bidirectional Streaming`**: Ambos lados envían flujos de mensajes de forma independiente y simultánea.
- **`Stubs (Clients)`**: Código autogenerado que el cliente utiliza para invocar los métodos remotos.
- **`Channels`**: Representan una conexión virtual a un `endpoint` que puede manejar múltiples conexiones `HTTP/2` internas para optimizar el rendimiento.

## Ejemplos Prácticos
##### Service Definition (`greeter.proto`)
```proto
syntax = "proto3";

package greeter;

// The greeting service definition.
service Greeter {
  // Sends a greeting (Unary RPC)
  rpc SayHello (HelloRequest) returns (HelloReply) {}

  // Stream of greetings (Server Streaming)
  rpc LotsOfReplies (HelloRequest) returns (stream HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings.
message HelloReply {
  string message = 1;
}
```
##### Client Stub Invocation (`Go Example`)
```go
// English: Calling the remote method as a local function
client := pb.NewGreeterClient(conn)
resp, err := client.SayHello(ctx, &pb.HelloRequest{Name: "G"})
if err != nil {
    log.Fatalf("could not greet: %v", err)
}
fmt.Printf("Greeting: %s", resp.GetMessage())
```

## Analogía
Imagina que `REST` es como enviar **cartas por correo tradicional**: escribes en un lenguaje humano (`JSON`), usas sobres estándar, y esperas a que el cartero vaya y vuelva para cada mensaje. Es fácil de leer para cualquiera, pero lento y con mucho "papel" innecesario.
`gRPC` es como un **sistema de tubos neumáticos industriales** dentro de un edificio:
1. **`Protobuf`** es el contenedor metálico ultracompacto diseñado específicamente para encajar en el tubo.
2. `HTTP/2` es el aire comprimido que permite que múltiples contenedores viajen simultáneamente por el mismo tubo sin chocar (`Multiplexing`).
3. Es increíblemente rápido y eficiente, pero necesitas equipo especial (`Stubs/Compiler`) para meter y sacar la información de los contenedores.

## Buenas Prácticas
- **`Reuse Channels`**: No crees un canal por cada petición; son objetos pesados diseñados para ser reutilizados y compartir conexiones `HTTP/2` subyacentes.
- **`Deadline Propagation`**: Siempre define `deadlines (timeouts)`. En microservicios, si el servicio `A` llama al `B`, y el `B` al `C`, el `timeout` debe propagarse para evitar "`zombies requests`" que consuman recursos.
- **`Versioning by Field ID`**: Nunca cambies el número identificador de un campo en un mensaje `Protobuf (string name = 1;)`. Si quieres eliminarlo, márcalo como `reserved` para evitar colisiones futuras.
- **`Load Balancing`**: `gRPC` rompe el balanceo de carga tradicional de L4 (`TCP`) porque las conexiones son persistentes. Utiliza un `Service Mesh (Envoy/Istio)` o balanceo en el lado del cliente (`Client-side LB`).
- **`Interception`**: Utiliza interceptores (`middleware`) para manejar `logs`, autenticación y métricas de forma transversal sin ensuciar la lógica de negocio.

## Notas Personales
- **Punto Crítico**: `gRPC` brilla en la comunicación `Internal Microservices (East-West traffic)` donde la latencia es ley. Para `APIs` públicas, `REST` sigue siendo el rey por su facilidad de consumo y compatibilidad universal.
- **Curva de Aprendizaje**: Al principio, el proceso de compilación de archivos `.proto` puede ser frustrante, pero una vez automatizado en el `CI/CD`, el tipado estricto te ahorra cientos de errores de `runtime`.